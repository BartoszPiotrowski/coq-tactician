From 0e3412364237a9c4901874a947cb38d9f68389ca Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Tue, 4 Aug 2020 15:13:22 +0100
Subject: [PATCH 01/76] small optimization to PathCube.v

---
 theories/Cubical/PathCube.v | 94 +++++++++++++++++++++++--------------
 1 file changed, 60 insertions(+), 34 deletions(-)

diff --git a/theories/Cubical/PathCube.v b/theories/Cubical/PathCube.v
index 9bd78d4e41..1596becdd5 100644
--- a/theories/Cubical/PathCube.v
+++ b/theories/Cubical/PathCube.v
@@ -500,42 +500,68 @@ Proof.
   apply cu_fill_right.
 Defined.
 
-(* PathCube concatenation *)
-Section PathCubeConcat.
+(** PathCube concatenation *)
 
-  Context {A} {x000 x010 x100 x110 x001 x011 x101 x111 x201 x200 x210 x211 : A}
-    {p0i0 : x000 = x010} {p1i0 : x100 = x110} {pi00 : x000 = x100}
-    {pi10 : x010 = x110} {p0i1 : x001 = x011} {p1i1 : x101 = x111}
-    {pi01 : x001 = x101} {pi11 : x011 = x111} {p00i : x000 = x001}
-    {p01i : x010 = x011} {p10i : x100 = x101} {p11i : x110 = x111}
-    {pj01 : x101 = x201} {pj11 : x111 = x211} {pj10 : x110 = x210}
-    {pj00 : x100 = x200} {p2i1 : x201 = x211} {p2i0 : x200 = x210}
-    {p20i : x200 = x201} {p21i : x210 = x211}
-    {s0ii : PathSquare p0i0 p0i1 p00i p01i} {s1ii : PathSquare p1i0 p1i1 p10i p11i}
-    {sii0 : PathSquare p0i0 p1i0 pi00 pi10} {sii1 : PathSquare p0i1 p1i1 pi01 pi11}
-    {si0i : PathSquare p00i p10i pi00 pi01} {si1i : PathSquare p01i p11i pi10 pi11}
-    {sji0 : PathSquare p1i0 p2i0 pj00 pj10} {sji1 : PathSquare p1i1 p2i1 pj01 pj11}
-    {sj0i : PathSquare p10i p20i pj00 pj01} {sj1i : PathSquare p11i p21i pj10 pj11}
-    {s2ii : PathSquare p2i0 p2i1 p20i p21i}.
-
-  (* We only define left right concatenation for now since that is what we
-     need. The other concatenations will not be as nice however, due to the
-     orientation of the faces of the cubes. *)
-
-  (* TODO: Work out why this is so slow *)
-  (* Left right concatenation *)
-  Definition cu_concat_lr : PathCube s0ii s1ii sii0 sii1 si0i si1i
-    -> PathCube s1ii s2ii sji0 sji1 sj0i sj1i
-    -> PathCube s0ii s2ii (sq_concat_h sii0 sji0) (sq_concat_h sii1 sji1)
-         (sq_concat_h si0i sj0i) (sq_concat_h si1i sj1i).
-  Proof.
-    intros a b.
-    destruct b.
-    unfold sq_concat_h.
-    by destruct a.
-  Defined.
+(* Left right concatenation *)
+(** Note that we don't construct this with tactics as it is quite slow. The body of this definition was generated by tactics then inlined here for performance reasons. *)
+Definition cu_concat_lr {A} {x000 x010 x100 x110 x001 x011 x101 x111 x201 x200 x210 x211 : A}
+  {p0i0 : x000 = x010} {p1i0 : x100 = x110} {pi00 : x000 = x100}
+  {pi10 : x010 = x110} {p0i1 : x001 = x011} {p1i1 : x101 = x111}
+  {pi01 : x001 = x101} {pi11 : x011 = x111} {p00i : x000 = x001}
+  {p01i : x010 = x011} {p10i : x100 = x101} {p11i : x110 = x111}
+  {pj01 : x101 = x201} {pj11 : x111 = x211} {pj10 : x110 = x210}
+  {pj00 : x100 = x200} {p2i1 : x201 = x211} {p2i0 : x200 = x210}
+  {p20i : x200 = x201} {p21i : x210 = x211}
+  {s0ii : PathSquare p0i0 p0i1 p00i p01i} {s1ii : PathSquare p1i0 p1i1 p10i p11i}
+  {sii0 : PathSquare p0i0 p1i0 pi00 pi10} {sii1 : PathSquare p0i1 p1i1 pi01 pi11}
+  {si0i : PathSquare p00i p10i pi00 pi01} {si1i : PathSquare p01i p11i pi10 pi11}
+  {sji0 : PathSquare p1i0 p2i0 pj00 pj10} {sji1 : PathSquare p1i1 p2i1 pj01 pj11}
+  {sj0i : PathSquare p10i p20i pj00 pj01} {sj1i : PathSquare p11i p21i pj10 pj11}
+  {s2ii : PathSquare p2i0 p2i1 p20i p21i}
+  : PathCube s0ii s1ii sii0 sii1 si0i si1i
+  -> PathCube s1ii s2ii sji0 sji1 sj0i sj1i
+  -> PathCube s0ii s2ii (sq_concat_h sii0 sji0) (sq_concat_h sii1 sji1)
+       (sq_concat_h si0i sj0i) (sq_concat_h si1i sj1i)
+  := fun a b => match b in
+      (@PathCube _ x002 x012 x102 x112 x003 x013 x103 x113 p0i2 p1i2 pi02 pi12 p0i3 p1i3 pi03 pi13 p00i0 p01i0
+        p10i0 p11i0 s0ii0 s1ii0 sii2 sii3 si0i0 si1i0)
+       return
+         (forall (pi04 : paths x000 x002) (pi14 : paths x010 x012) (pi05 : paths x001 x003)
+            (pi15 : paths x011 x013) (sii4 : PathSquare p0i0 p0i2 pi04 pi14)
+            (sii5 : PathSquare p0i1 p0i3 pi05 pi15) (si0i1 : PathSquare p00i p00i0 pi04 pi05)
+            (si1i1 : PathSquare p01i p01i0 pi14 pi15) (_ : PathCube s0ii s0ii0 sii4 sii5 si0i1 si1i1),
+          PathCube s0ii s1ii0 (sq_concat_h sii4 sii2) (sq_concat_h sii5 sii3) (sq_concat_h si0i1 si0i0)
+            (sq_concat_h si1i1 si1i0))
+     with
+     | idcube x
+      => fun (pi02 : paths x000 x) (pi12 : paths x010 x) (pi03 : paths x001 x) (pi13 : paths x011 x)
+        (sii2 : PathSquare p0i0 (@idpath A x) pi02 pi12) (sii3 : PathSquare p0i1 (@idpath A x) pi03 pi13)
+        (si0i0 : PathSquare p00i (@idpath A x) pi02 pi03) (si1i0 : PathSquare p01i (@idpath A x) pi12 pi13)
+        (a0 : PathCube s0ii (@sq_id A x) sii2 sii3 si0i0 si1i0) =>
+      match a0 in
+        (@PathCube _ x002 x012 x102 x112 x003 x013 x103 x113 p0i2 p1i2 pi04 pi14 p0i3 p1i3 pi05 pi15 p00i0 p01i0
+            p10i0 p11i0 s0ii0 s1ii0 sii4 sii5 si0i1 si1i1)
+           return
+             (PathCube s0ii0 s1ii0 (equiv_sq_ccGG (inverse (concat_p1 pi04)) (inverse (concat_p1 pi14)) sii4)
+                (equiv_sq_ccGG (inverse (concat_p1 pi05)) (inverse (concat_p1 pi15)) sii5)
+                (equiv_sq_ccGG (inverse (concat_p1 pi04)) (inverse (concat_p1 pi05)) si0i1)
+                (equiv_sq_ccGG (inverse (concat_p1 pi14)) (inverse (concat_p1 pi15)) si1i1))
+         with
+         | idcube x0 => idcube x0
+         end
+     end pi00 pi10 pi01 pi11 sii0 sii1 si0i si1i a.
+
+(** The original proof can be constructed with the following tactics:
+
+Proof.
+  intros a b.
+  destruct b.
+  unfold sq_concat_h.
+  by destruct a.
+Defined.
+
+*)
 
-End PathCubeConcat.
 
 (* Notation for left right concatenation *)
 Notation "x '@lr' y" := (cu_concat_lr x y) : cube_scope.
-- 
2.29.1


From 3a97e1a57694b4ce7471178e3bdbce6d5b57754c Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 6 Aug 2020 00:18:05 +0100
Subject: [PATCH 02/76] fix fragile-hint-constr warning

---
 coq/theories/Init/Notations.v                     |  2 --
 coq/theories/Init/Peano.v                         | 15 ++++++++++-----
 theories/Basics/Overture.v                        | 10 ++--------
 .../Adjoint/Composition/AssociativityLaw.v        |  2 +-
 .../Categories/Adjoint/Composition/IdentityLaws.v |  2 +-
 theories/Categories/Category/Core.v               |  6 +++---
 theories/Categories/Category/Morphisms.v          |  5 ++++-
 theories/Categories/Functor/Composition/Laws.v    |  4 ++--
 theories/Categories/Functor/Core.v                |  6 +++---
 theories/Categories/NaturalTransformation/Core.v  |  2 +-
 .../Categories/PseudonaturalTransformation/Core.v |  2 +-
 11 files changed, 28 insertions(+), 28 deletions(-)

diff --git a/coq/theories/Init/Notations.v b/coq/theories/Init/Notations.v
index e157081dc0..f5254bbb24 100644
--- a/coq/theories/Init/Notations.v
+++ b/coq/theories/Init/Notations.v
@@ -97,5 +97,3 @@ Declare ML Module "ltac_plugin".
 
 Global Set Default Proof Mode "Classic".
 
-(** Currently, Coq 8.12 throws this warning when aritrary terms are passed to the hint database. The recommended behaviour is to define a global reference for the term and pass that instead. This is however tedious to do in practice so we ignore this warning. In the future Coq 8.13 might have autogenerated names for arbitary terms in hints which may allow us to keep the current code. See coq/coq#11970 and coq/coq#12493 *)
-Global Set Warnings "-fragile-hint-constr".
diff --git a/coq/theories/Init/Peano.v b/coq/theories/Init/Peano.v
index 1ac83e72bf..df0ceb0fde 100644
--- a/coq/theories/Init/Peano.v
+++ b/coq/theories/Init/Peano.v
@@ -34,8 +34,10 @@ Local Notation "0" := O.
 
 Definition eq_S := f_equal S.
 
-Hint Resolve (f_equal S): v62.
-Hint Resolve (f_equal (A:=nat)): core.
+Local Definition f_equal_S := f_equal S.
+Local Definition f_equal_nat := f_equal (A:=nat).
+Hint Resolve f_equal_S : v62.
+Hint Resolve f_equal_nat : core.
 
 (** The predecessor function *)
 
@@ -93,8 +95,10 @@ Fixpoint plus (n m:nat) : nat :=
 
 where "n + m" := (plus n m) : nat_scope.
 
-Hint Resolve (f_equal2 plus): v62.
-Hint Resolve (f_equal2 (A1:=nat) (A2:=nat)): core.
+Local Definition f_equal2_plus := f_equal2 plus.
+Local Definition f_equal2_nat := f_equal2 (A1:=nat) (A2:=nat).
+Hint Resolve f_equal2_plus : v62.
+Hint Resolve f_equal2_nat : core.
 
 Lemma plus_n_O : forall n:nat, n = n + 0.
 Proof.
@@ -133,7 +137,8 @@ Fixpoint mult (n m:nat) : nat :=
 
 where "n * m" := (mult n m) : nat_scope.
 
-Hint Resolve (f_equal2 mult): core.
+Local Definition f_equal2_mult := f_equal2 mult.
+Hint Resolve f_equal2_mult : core.
 
 Lemma mult_n_O : forall n:nat, 0 = n * 0.
 Proof.
diff --git a/theories/Basics/Overture.v b/theories/Basics/Overture.v
index ad94279cc0..18aafe1e3b 100644
--- a/theories/Basics/Overture.v
+++ b/theories/Basics/Overture.v
@@ -4,9 +4,6 @@
 (** Import the file of reserved notations so we maintain consistent level notations throughout the library *)
 Require Export Basics.Notations.
 
-(** Currently, Coq 8.12 throws this warning when aritrary terms are passed to the hint database. The recommended behaviour is to define a global reference for the term and pass that instead. This is however tedious to do in practice so we ignore this warning. In the future Coq 8.13 might have autogenerated names for arbitary terms in hints which may allow us to keep the current code. See coq/coq#11970 and coq/coq#12493 *)
-Global Set Warnings "-fragile-hint-constr".
-
 (** Currently, Coq 8.12 complains when we use the numeral notations from the Decimal module. Since we only use a copy of the real standard library we will supress this warning. In the future, our copy of the standard library will be completely removed together with this warning. *)
 Global Set Warnings "-decimal-numeral-notation".
 
@@ -666,11 +663,8 @@ Global Arguments path_forall {_ A%type_scope P} (f g)%function_scope _.
    The hints in [path_hints] are designed to push concatenation *outwards*, eliminate identities and inverses, and associate to the left as far as  possible. *)
 
 (** TODO: think more carefully about this.  Perhaps associating to the right would be more convenient? *)
-Hint Resolve
-  @idpath @inverse
- : path_hints.
-
-Hint Resolve @idpath : core.
+Hint Resolve idpath inverse : path_hints.
+Hint Resolve idpath : core.
 
 Ltac path_via mid :=
   apply @concat with (y := mid); auto with path_hints.
diff --git a/theories/Categories/Adjoint/Composition/AssociativityLaw.v b/theories/Categories/Adjoint/Composition/AssociativityLaw.v
index 204d427013..88ac021375 100644
--- a/theories/Categories/Adjoint/Composition/AssociativityLaw.v
+++ b/theories/Categories/Adjoint/Composition/AssociativityLaw.v
@@ -47,4 +47,4 @@ Section composition_lemmas.
   Qed.
 End composition_lemmas.
 
-Hint Resolve @associativity : category.
+Hint Resolve associativity : category.
diff --git a/theories/Categories/Adjoint/Composition/IdentityLaws.v b/theories/Categories/Adjoint/Composition/IdentityLaws.v
index 9754887565..f97ae637f9 100644
--- a/theories/Categories/Adjoint/Composition/IdentityLaws.v
+++ b/theories/Categories/Adjoint/Composition/IdentityLaws.v
@@ -52,4 +52,4 @@ Section identity_lemmas.
 End identity_lemmas.
 
 Hint Rewrite @left_identity @right_identity : category.
-Hint Immediate @left_identity @right_identity : category.
+Hint Immediate left_identity right_identity : category.
diff --git a/theories/Categories/Category/Core.v b/theories/Categories/Category/Core.v
index 49792bf031..1604bf7a58 100644
--- a/theories/Categories/Category/Core.v
+++ b/theories/Categories/Category/Core.v
@@ -113,9 +113,9 @@ Create HintDb category discriminated.
 (** create a hint db for morphisms in categories *)
 Create HintDb morphism discriminated.
 
-Hint Resolve @left_identity @right_identity @associativity : category morphism.
-Hint Rewrite @left_identity @right_identity : category.
-Hint Rewrite @left_identity @right_identity : morphism.
+Hint Resolve left_identity right_identity associativity : category morphism.
+Hint Rewrite left_identity right_identity : category.
+Hint Rewrite left_identity right_identity : morphism.
 
 (** ** Simple laws about the identity morphism *)
 Section identity_unique.
diff --git a/theories/Categories/Category/Morphisms.v b/theories/Categories/Category/Morphisms.v
index 7b1efa4c9b..1f502a8dd1 100644
--- a/theories/Categories/Category/Morphisms.v
+++ b/theories/Categories/Category/Morphisms.v
@@ -374,7 +374,10 @@ Section EpiMono.
   End iso.
 End EpiMono.
 
-Hint Immediate @isepimorphism_identity @ismonomorphism_identity @ismonomorphism_compose @isepimorphism_compose : category morphism.
+Hint Immediate
+  isepimorphism_identity ismonomorphism_identity
+  ismonomorphism_compose isepimorphism_compose
+  : category morphism.
 
 (** ** Lemmas about [idtoiso] *)
 Section iso_lemmas.
diff --git a/theories/Categories/Functor/Composition/Laws.v b/theories/Categories/Functor/Composition/Laws.v
index 5e3b40b666..5f50f103d1 100644
--- a/theories/Categories/Functor/Composition/Laws.v
+++ b/theories/Categories/Functor/Composition/Laws.v
@@ -42,7 +42,7 @@ End identity_lemmas.
 
 Hint Rewrite @left_identity @right_identity : category.
 Hint Rewrite @left_identity @right_identity : functor.
-Hint Immediate @left_identity @right_identity : category functor.
+Hint Immediate left_identity right_identity : category functor.
 
 Section composition_lemmas.
   Context `{fs : Funext}.
@@ -65,7 +65,7 @@ Section composition_lemmas.
     := @path_functor_uncurried_fst _ _ _ ((H o G) o F) (H o (G o F)) 1%path 1%path.
 End composition_lemmas.
 
-Hint Resolve @associativity : category functor.
+Hint Resolve associativity : category functor.
 
 Section coherence.
   Context `{fs : Funext}.
diff --git a/theories/Categories/Functor/Core.v b/theories/Categories/Functor/Core.v
index a9e98e6ebd..d3382204c7 100644
--- a/theories/Categories/Functor/Core.v
+++ b/theories/Categories/Functor/Core.v
@@ -60,6 +60,6 @@ Module Export FunctorCoreNotations.
   Notation "F '_1' m" := (morphism_of F m) : morphism_scope.
 End FunctorCoreNotations.
 
-Hint Resolve @composition_of @identity_of : category functor.
-Hint Rewrite @identity_of : category.
-Hint Rewrite @identity_of : functor.
+Hint Resolve composition_of identity_of : category functor.
+Hint Rewrite identity_of : category.
+Hint Rewrite identity_of : functor.
diff --git a/theories/Categories/NaturalTransformation/Core.v b/theories/Categories/NaturalTransformation/Core.v
index 3c4d69e727..de9f30b94c 100644
--- a/theories/Categories/NaturalTransformation/Core.v
+++ b/theories/Categories/NaturalTransformation/Core.v
@@ -64,7 +64,7 @@ Global Arguments components_of {C D}%category {F G}%functor T%natural_transforma
 Global Arguments commutes {C D F G} !T / _ _ _ : rename.
 Global Arguments commutes_sym {C D F G} !T / _ _ _ : rename.
 
-Hint Resolve @commutes : category natural_transformation.
+Hint Resolve commutes : category natural_transformation.
 
 (** ** Helper lemmas *)
 (** Some helper lemmas for rewriting.  In the names, [p] stands for a
diff --git a/theories/Categories/PseudonaturalTransformation/Core.v b/theories/Categories/PseudonaturalTransformation/Core.v
index f788a9c7c5..b8f3b4b961 100644
--- a/theories/Categories/PseudonaturalTransformation/Core.v
+++ b/theories/Categories/PseudonaturalTransformation/Core.v
@@ -229,4 +229,4 @@ Create HintDb pseuodnatural_transformation discriminated.
 Arguments p_components_of {_} {X}%category {F G}%pseudofunctor T%pseudonatural_transformation
           a%object : rename, simpl nomatch.
 
-Hint Resolve @p_commutes_respects_identity @p_commutes_respects_composition : category pseudonatural_transformation.
+Hint Resolve p_commutes_respects_identity p_commutes_respects_composition : category pseudonatural_transformation.
-- 
2.29.1


From d101b1ede4b08f9f39626738950944984e0abec6 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Wed, 22 Apr 2020 16:28:29 +0100
Subject: [PATCH 03/76] encode for ClassifyingSpace respects concatenation

---
 coq-HoTT                             |  2 +-
 etc/coq-dpdgraph                     |  2 +-
 theories/Homotopy/ClassifyingSpace.v | 20 +++++++++++++++++++-
 3 files changed, 21 insertions(+), 3 deletions(-)

diff --git a/coq-HoTT b/coq-HoTT
index c97b82cda0..aea8e0b975 160000
--- a/coq-HoTT
+++ b/coq-HoTT
@@ -1 +1 @@
-Subproject commit c97b82cda0ba4c0b9ad8199658c3a09461f3a8d7
+Subproject commit aea8e0b9754c43f05d4c82f35ce495974cdd3501
diff --git a/etc/coq-dpdgraph b/etc/coq-dpdgraph
index 42636fc7fd..13b19bb86a 160000
--- a/etc/coq-dpdgraph
+++ b/etc/coq-dpdgraph
@@ -1 +1 @@
-Subproject commit 42636fc7fdd0cc918254308d428db594c9d7d81c
+Subproject commit 13b19bb86a23092f7408d26e7d8e4ca733fa3f28
diff --git a/theories/Homotopy/ClassifyingSpace.v b/theories/Homotopy/ClassifyingSpace.v
index 6efa0474b4..04b26cc23b 100644
--- a/theories/Homotopy/ClassifyingSpace.v
+++ b/theories/Homotopy/ClassifyingSpace.v
@@ -185,7 +185,7 @@ Section EncodeDecode.
 
   Context `{Univalence} {G : Group}.
 
-  Local Definition codes : B G -> 0 -Type.
+  Local Definition codes : B G -> 0-Type.
   Proof.
     srapply ClassifyingSpace_rec.
     + srapply (BuildhSet G).
@@ -258,6 +258,24 @@ Section EncodeDecode.
     reflexivity.
   Defined.
 
+  Local Lemma encode_pp' (x : B G) (p q : bbase = x)
+    : encode _ (p @ q^) = transport (fun x : B G => codes x) q^ (encode x p).
+  Proof.
+    destruct q; cbn.
+    f_ap; apply concat_p1.
+  Defined.
+
+  Local Lemma encode_pp (p q : bbase = bbase)
+    : encode _ (p @ q) = encode _ p * encode _ q.
+  Proof.
+    refine (_ @ codes_transport _ _).
+    refine (_ @ transport2 codes _^ (encode bbase p)).
+    2: rapply decode_encode.
+    rewrite <- (inv_V q).
+    generalize q^; intro q'; clear q.
+    apply encode_pp'.
+  Defined.
+
 End EncodeDecode.
 
 (** When G is an abelian group, BG is a H-space. *)
-- 
2.29.1


From dc413acba1fc2043c741b32cee6a27e561c9270b Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 23 Apr 2020 17:08:45 +0100
Subject: [PATCH 04/76] equiv_loops_bg_g is an isomorphism

---
 theories/Homotopy/ClassifyingSpace.v | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/theories/Homotopy/ClassifyingSpace.v b/theories/Homotopy/ClassifyingSpace.v
index 04b26cc23b..0a4ee838c5 100644
--- a/theories/Homotopy/ClassifyingSpace.v
+++ b/theories/Homotopy/ClassifyingSpace.v
@@ -278,9 +278,29 @@ Section EncodeDecode.
 
 End EncodeDecode.
 
+(** We also have that the equivalence is a group isomorphism. *)
+
+(** First we show that the loop space of a pointed 1-type is a group *)
+Definition LoopGroup (X : pType) `{IsTrunc 1 X} : Group
+  := Build_Group (loops X) concat idpath inverse
+    (Build_IsGroup _ _ _ _
+      (Build_IsMonoid _ _ _
+        (Build_IsSemiGroup _ _ _ concat_p_pp) concat_1p concat_p1)
+      concat_Vp concat_pV).
+
+Definition grp_iso_loopgroup_bg `{Univalence} (G : Group)
+  : GroupIsomorphism (LoopGroup (B G)) G.
+Proof.
+  snrapply Build_GroupIsomorphism'.
+  1: exact equiv_loops_bg_g.
+  intros x y.
+  apply encode_pp.
+Defined.
+
 (** When G is an abelian group, BG is a H-space. *)
 Section HSpace_bg.
 
+  (** TODO: funext can probably be avoided here *)
   Context `{Funext} {G : AbGroup}.
 
   Definition bg_mul : B G -> B G -> B G.
-- 
2.29.1


From ae3ad90e1b5aa13436ff33f00ff91d6f3a9ade3f Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Mon, 13 Jul 2020 10:44:07 +0100
Subject: [PATCH 05/76] free groups

---
 _CoqProject                                   |   3 +
 theories/Algebra/Groups/FreeGroup.v           |  45 +++
 .../Groups/FreeGroup/KrausAltenkirch.v        | 361 ++++++++++++++++++
 theories/Algebra/Groups/Group.v               |  25 ++
 4 files changed, 434 insertions(+)
 create mode 100644 theories/Algebra/Groups/FreeGroup.v
 create mode 100644 theories/Algebra/Groups/FreeGroup/KrausAltenkirch.v

diff --git a/_CoqProject b/_CoqProject
index 6f8f2d1cdb..f0c49b327e 100644
--- a/_CoqProject
+++ b/_CoqProject
@@ -348,6 +348,9 @@ theories/Algebra/Groups/QuotientGroup.v
 theories/Algebra/Groups/Image.v
 theories/Algebra/Groups/Kernel.v
 theories/Algebra/Groups/GrpPullback.v
+theories/Algebra/Groups/FreeGroup.v
+
+theories/Algebra/Groups/FreeGroup/KrausAltenkirch.v
 
 #
 #   Tactics
diff --git a/theories/Algebra/Groups/FreeGroup.v b/theories/Algebra/Groups/FreeGroup.v
new file mode 100644
index 0000000000..1da0981a2a
--- /dev/null
+++ b/theories/Algebra/Groups/FreeGroup.v
@@ -0,0 +1,45 @@
+Require Import Basics Types.
+Require Import Groups.Group.
+Require Import WildCat.
+
+(** Free groups are defined in Group.v. In this file we prove properties of free groups. There are various constructions of free groups to choose from, all of which can be found in the FreeGroup folder. *)
+
+(** In this file, and in the rest of the library we choose a modified version of the free group which can be found in Kraus-Altenkirch 2018 arXiv:1805.02069. This is a very simple HIT in a similar manner to the abelianization HIT used in Algebra.AbGroup.Abelianization. *)
+Require Export Algebra.Groups.FreeGroup.KrausAltenkirch.
+
+(** Properties of free groups *)
+
+(** We can state the universal property of free groups as an equivalence: (F(A) $-> G) <~> (A -> G) *)
+Theorem equiv_isfreegroup_rec `{Funext} (G F : Group) (A : Type) (i : A -> F)
+  `{IsFreeGroupOn A F i}
+  : (F $-> G) <~> (A -> G).
+Proof.
+  snrapply Build_Equiv.
+  { intros f.
+    exact (f o i). }
+  nrapply isequiv_contr_map.
+  intro f.
+  unfold hfiber.
+  snrapply contr_equiv'.
+  1: exact (FactorsThroughFreeGroup A F i G f).
+  { rapply equiv_functor_sigma_id.
+    intro g.
+    apply equiv_path_forall. }
+  exact _.
+Defined.
+
+(** The above theorem is true regardless of the implementation of free groups. This let's us state the more specific theorem about the free groups themselves. This can be read as [FreeGroup] is left adjoint to the forgetful functor [group_type]. *)
+Theorem equiv_freegroup_rec `{Funext} (G : Group) (A : Type)
+  : (FreeGroup A $-> G) <~> (A -> G).
+Proof.
+  rapply equiv_isfreegroup_rec.
+Defined.
+
+(** TODO: Nielsen-Schreier theorem: Subgroups of free groups are free. Proofs of this statement are non-trivial. We can prove it using covering spaces which haven't yet been considered in this library. In fact, every known proof requires the axiom of choice in some crucical way. *)
+
+(** Here is a sketch of such a proof. If F is a free group on a type X, then it is the fundamental group of the suspension of (X + 1) (This coule be by definition). A subgroup is then the fundamental group of a covering space of Susp (X + 1). This space is a connected 1-type and using choice we can show it has a spanning tree (since it is a topological graph). By shrinking the spanning tree we get that this cover is also the suspension of some non-empty type, hence is a free group. This "proof" is however a sketch and there may be serious problems when allowing groups to be free over arbitrary types. *)
+
+(** TODO: If F(A) $<~> F(B) then the cardinalities of [A] and [B] are the same. *)
+
+(** A proof might go like this: If F(A) $<~> F(B) then so are their abelianizations F(A)^ab $<~> F(B)^ab. It can be shown that F(A)^ab = Z^A hence we need only compare ranks of free abelian groups. It is not clear to me at the time of writing that this is now easier to prove however. *)
+
diff --git a/theories/Algebra/Groups/FreeGroup/KrausAltenkirch.v b/theories/Algebra/Groups/FreeGroup/KrausAltenkirch.v
new file mode 100644
index 0000000000..96779831cb
--- /dev/null
+++ b/theories/Algebra/Groups/FreeGroup/KrausAltenkirch.v
@@ -0,0 +1,361 @@
+Require Import Basics Types.
+Require Import Groups.Group.
+Require Import Truncations.
+Require Import HIT.Coeq.
+
+Local Open Scope mc_scope.
+Local Open Scope mc_mult_scope.
+
+(** In this file we construct the free abelian group on a type [A] as a higher inductive type. This construction is due to Kraus and Altenkirch. Their construction is actually more general, but we set truncate it to suit our needs which is the free group as a set. *)
+
+Section Reduction.
+
+  Context (A : Type).
+
+  (** We define words (with inverses) on A to be lists of marked elements of A *)
+  Definition Words : Type := list (A + A).
+
+  (** Given a marked element of A we can change its mark *)
+  Definition change_sign : A + A -> A + A
+    := fun x => match x with
+                | inl a => inr a
+                | inr a => inl a
+                end.
+
+  (** We introduce a local notation for [change_sign]. It is only defined in this section however. *)
+  Notation "x ^" := (change_sign x).
+
+  (** Changing sign is an involution *)
+  Definition change_sign_inv a : a^^ = a.
+  Proof.
+    by destruct a.
+  Defined.
+
+  (** We can concatenate words using list concatenation *)
+  Definition word_concat : Words -> Words -> Words := @app _.
+
+  (** We introduce a local notation for word_concat. *)
+  Infix "@" := word_concat.
+
+  Definition word_concat_w_nil x : x @ nil = x.
+  Proof.
+    induction x; trivial.
+    cbn; f_ap.
+  Defined.
+
+  Definition word_concat_w_ww x y z : x @ (y @ z) = (x @ y) @ z.
+  Proof.
+    revert x z.
+    induction y; intros x z.
+    { f_ap; symmetry.
+      apply word_concat_w_nil. }
+    simpl; revert z y IHy.
+    induction x; trivial.
+    intros z y IHy.
+    simpl; f_ap.
+    apply IHx, IHy.
+  Defined.
+
+  (** Singleton word *)
+  Definition word_sing (x : A + A) : Words := (cons x nil).
+
+  Notation "[ x ]" := (word_sing x).
+
+  (** We define an inductive family [Red] on [Words] which expresses whether a given word can be reduced to the empty list *)
+  Inductive Red : Words -> Type :=
+    | red_zero : Red nil
+    | red_step (y z : Words) (a : A + A)
+      : Red (y @ z) -> Red (y @ [a] @ [a^] @ z).
+
+  (** Now we wish to define the free group on A as the following HIT: 
+
+    HIT N(A) : hSet
+     | eta : Words -> N(A)
+     | tau (x : Words) (a : A + A) (y : Words)
+         : eta (x @ [a] @ [a^] @ y) = eta (x @ y).
+
+    Since we cannot write our HITs directly like this (without resorting to private inductive types), we will construct this HIT out of HITs we know. In fact, we can define N(A) as a coequalizer. *)
+
+  Definition map1 : Words * (A + A) * Words -> Words.
+  Proof.
+    intros [[x a] y].
+    exact (x @ [a] @ [a^] @ y).
+  Defined.
+
+  Definition map2 : Words * (A + A) * Words -> Words.
+  Proof.
+    intros [[x a] y].
+    exact (x @ y).
+  Defined.
+
+  (** Now we can define the underlying type of the free group as the 0-truncated coequalizer of these two maps *)
+  Definition freegroup_type : Type := Tr 0 (Coeq map1 map2).
+
+  (** This is the point constructor *)
+  Definition freegroup_eta : Words -> freegroup_type := tr o coeq.
+
+  (** This is the path constructor *)
+  Definition freegroup_tau (x : Words) (a : A + A) (y : Words)
+    : freegroup_eta (x @ [a] @ [a^] @ y) = freegroup_eta (x @ y).
+  Proof.
+    apply path_Tr, tr.
+    exact ((cglue (x, a, y))).
+  Defined.
+
+  (** The group operation *)
+  Global Instance sgop_freegroup : SgOp freegroup_type.
+  Proof.
+    intros x y.
+    strip_truncations.
+(*      apply tr. *)
+    revert x; snrapply Coeq_rec.
+    { intros x; revert y.
+      snrapply Coeq_rec.
+      { intros y.
+        exact (freegroup_eta (x @ y)). }
+      intros [[y a] z]; cbn.
+      refine (concat (ap _ _) _).
+      { refine (concat (word_concat_w_ww _ _ _) _).
+        rapply (ap (fun t => t @ _)).
+        refine (concat (word_concat_w_ww _ _ _) _).
+        rapply (ap (fun t => t @ _)).
+        refine (word_concat_w_ww _ _ _). }
+      refine (concat _ (ap _ _^)).
+      2: apply word_concat_w_ww.
+      apply freegroup_tau. }
+    intros [[c b] d].
+    simpl.
+    revert y.
+    snrapply Coeq_ind.
+    { simpl.
+      intro a.
+      rewrite <- word_concat_w_ww.
+      rewrite <- (word_concat_w_ww _ _ a).
+      rapply (freegroup_tau c b (d @ a)). }
+    intro; rapply path_ishprop.
+  Defined.
+
+  (** The unit of the free group is the empty word *)
+  Global Instance monunit_freegroup_type : MonUnit freegroup_type.
+  Proof.
+    apply freegroup_eta.
+    exact nil.
+  Defined.
+
+  (** We can change the sign of all the elements in a word and reverse the order. This will be the inversion in the group *)
+  Fixpoint word_change_sign (x : Words) : Words.
+  Proof.
+    destruct x as [|x xs].
+    1: exact nil.
+    exact (word_change_sign xs @ [change_sign x]).
+  Defined.
+
+  (** Changing the sign changes the order of word concatenation *)
+  Definition word_change_sign_ww (x y : Words)
+    : word_change_sign (x @ y) = word_change_sign y @ word_change_sign x.
+  Proof.
+    induction x.
+    { symmetry.
+      apply word_concat_w_nil. }
+    simpl.
+    refine (concat _ (inverse (word_concat_w_ww _ _ _))).
+    f_ap.
+  Defined.
+
+  (** This is also involutive *)
+  Lemma word_change_sign_inv x : word_change_sign (word_change_sign x) = x.
+  Proof.
+    induction x.
+    1: reflexivity.
+    simpl.
+    rewrite word_change_sign_ww.
+    cbn; f_ap.
+    apply change_sign_inv.
+  Defined.
+
+  (** Changing the sign gives us left inverses *)
+  Lemma word_concat_Vw x : freegroup_eta (word_change_sign x @ x) = mon_unit.
+  Proof.
+    induction x.
+    1: reflexivity.
+    cbn.
+    set (a' := a^).
+    rewrite <- (change_sign_inv a).
+    change a^ with a'.
+    change (freegroup_eta ((word_change_sign x @ [a']) @ ([a'^] @ x)) = mon_unit).
+    rewrite word_concat_w_ww.
+    rewrite freegroup_tau.
+    apply IHx.
+  Defined.
+
+  (** And since changing the sign is involutive we get right inverses from left inverses *)
+  Lemma word_concat_wV x : freegroup_eta (x @ word_change_sign x) = mon_unit.
+  Proof.
+    set (x' := word_change_sign x).
+    rewrite <- (word_change_sign_inv x).
+    change (freegroup_eta (word_change_sign x' @ x') = mon_unit).
+    apply word_concat_Vw.
+  Defined.
+
+  (** Negation is defined by changing the order of a word that appears in eta. Most of the work here is checking that it is agreeable with the path constructor. *)
+  Global Instance negate_freegroup_type : Negate freegroup_type.
+  Proof.
+    intro x.
+    strip_truncations.
+    revert x; srapply Coeq_rec.
+    { intro x.
+      apply freegroup_eta.
+      exact (word_change_sign x). }
+    intros [[b a] c].
+    unfold map1, map2.
+    refine (concat _ (ap _ (inverse _))).
+    2: apply word_change_sign_ww.
+    refine (concat (ap _ _) _).
+    { refine (concat (word_change_sign_ww _ _) _).
+      apply ap.
+      refine (concat (ap _ (inverse (word_concat_w_ww _ _ _))) _).
+      refine (concat (word_change_sign_ww _ _) _).
+      rapply (ap (fun t => t @ word_change_sign b)).
+      apply word_change_sign_ww. }
+    refine (concat _ (freegroup_tau _ a _)).
+    apply ap.
+    refine (concat (word_concat_w_ww _ _ _) _); f_ap.
+    refine (concat (word_concat_w_ww _ _ _) _); f_ap.
+    f_ap; cbn; f_ap.
+    apply change_sign_inv.
+  Defined.
+
+  (** Now we can start to prove the group laws. Since these are hprops we can ignore what happens with the path constructor. *)
+
+  (** Our operation is associative *)
+  Global Instance associative_freegroup_type : Associative sg_op.
+  Proof.
+    intros x y z.
+    strip_truncations.
+    revert x; snrapply Coeq_ind; intro x; [ | apply path_ishprop].
+    revert y; snrapply Coeq_ind; intro y; [ | apply path_ishprop].
+    revert z; snrapply Coeq_ind; intro z; [ | apply path_ishprop].
+    cbn; apply ap.
+    apply word_concat_w_ww.
+  Defined.
+
+  (** Left identity *)
+  Global Instance leftidentity_freegroup_type : LeftIdentity sg_op mon_unit.
+  Proof.
+    rapply Trunc_ind.
+    srapply Coeq_ind; intro x; [ | apply path_ishprop].
+    reflexivity.
+  Defined.
+
+  (** Right identity *)
+  Global Instance rightidentity_freegroup_type : RightIdentity sg_op mon_unit.
+  Proof.
+    rapply Trunc_ind.
+    srapply Coeq_ind; intro x; [ | apply path_ishprop].
+    apply (ap tr), ap.
+    apply word_concat_w_nil.
+  Defined.
+
+  (** Left inverse *)
+  Global Instance leftinverse_freegroup_type : LeftInverse sg_op negate mon_unit.
+  Proof.
+    rapply Trunc_ind.
+    srapply Coeq_ind; intro x; [ | apply path_ishprop].
+    apply word_concat_Vw.
+  Defined.
+
+  (** Right inverse *)
+  Global Instance rightinverse_freegroup_type : RightInverse sg_op negate mon_unit.
+  Proof.
+    rapply Trunc_ind.
+    srapply Coeq_ind; intro x; [ | apply path_ishprop].
+    apply word_concat_wV.
+  Defined.
+
+  (** Finally we have defined the free group on [A] *)
+  Definition FreeGroup : Group.
+  Proof.
+    snrapply (Build_Group freegroup_type); repeat split; exact _.
+  Defined.
+
+  Definition words_rec (G : Group) (s : A -> G) : Words -> G.
+  Proof.
+    intro x.
+    induction x as [|x xs].
+    1: exact mon_unit.
+    refine (_ * IHxs).
+    destruct x as [x|x].
+    1: exact (s x).
+    exact (- s x).
+  Defined.
+
+  Lemma words_rec_coh (G : Group) (s : A -> G) (a : A + A) (b c : Words)
+    : words_rec G s (map1 (b, a, c)) = words_rec G s (map2 (b, a, c)).
+  Proof.
+    
+  Admitted.
+
+  Lemma words_rec_pp  (G : Group) (s : A -> G)  (x y : Words)
+    : words_rec G s (x @ y) = words_rec G s x * words_rec G s y.
+  Proof.
+    induction x.
+    1: symmetry; apply left_identity.
+    cbn; rewrite <- simple_associativity.
+    f_ap.
+  Defined.
+
+  (** Given a group [G] we can construct a group homomorphism [FreeGroup A -> G] if we have a map [A -> G] *)
+  Definition FreeGroup_rec (G : Group) (s : A -> G)
+    : GroupHomomorphism FreeGroup G.
+  Proof.
+    snrapply Build_GroupHomomorphism.
+    { rapply Trunc_rec.
+      srapply Coeq_rec.
+      1: apply words_rec, s.
+      intros [[b a] c].
+      apply words_rec_coh. }
+    intros x y; strip_truncations.
+    revert x; snrapply Coeq_ind; hnf; intro x; [ | apply path_ishprop ].
+    revert y; snrapply Coeq_ind; hnf; intro y; [ | apply path_ishprop ].
+    simpl.
+    apply words_rec_pp.
+  Defined.
+
+  (** Now we need to prove that the free group satisifes the unviersal property of the free group. *)
+  (** TODO: remove funext from here and universal property of free group *)
+  Global Instance isfreegroupon_freegroup `{Funext}
+    : IsFreeGroupOn A FreeGroup (freegroup_eta o word_sing o inl).
+  Proof.
+    intros G f.
+    snrapply Build_Contr.
+    { srefine (_;_); simpl.
+      1: apply FreeGroup_rec, f.
+      intro x; simpl.
+      apply right_identity. }
+    intros [g h].
+    nrapply path_sigma_hprop; [ exact _ |].
+    simpl.
+    apply equiv_path_grouphomomorphism.
+    intro x.
+    rewrite <- (path_forall _ _ h).
+    strip_truncations; revert x.
+    snrapply Coeq_ind; intro x; [|apply path_ishprop].
+    hnf; symmetry.
+    induction x.
+    1: apply (grp_homo_unit g).
+    refine (concat (grp_homo_op g (freegroup_eta [a]) (freegroup_eta x)) _).
+    simpl.
+    f_ap.
+    destruct a.
+    1: reflexivity.
+    exact (grp_homo_inv g (freegroup_eta [inl a])).
+  Defined.
+
+  (** Typeclass search can already find this but we leave it here as a definition for reference. *)
+  Definition isfreegroup_freegrup `{Funext} : IsFreeGroup FreeGroup := _.
+
+End Reduction.
+
+
+
+
diff --git a/theories/Algebra/Groups/Group.v b/theories/Algebra/Groups/Group.v
index cda193bef6..4ad1509c2c 100644
--- a/theories/Algebra/Groups/Group.v
+++ b/theories/Algebra/Groups/Group.v
@@ -31,6 +31,8 @@ Arguments group_sgop {_}.
 Arguments group_unit {_}.
 Arguments group_inverse {_}.
 Arguments group_isgroup {_}.
+(** We never need to unfold the proof that something is a group *)
+Opaque group_isgroup.
 
 (** We coerce groups back to types. *)
 Coercion group_type : Group >-> Sortclass.
@@ -538,3 +540,26 @@ Proof.
   intros x.
   apply path_contr.
 Defined.
+
+(** ** Free groups *)
+
+Definition FactorsThroughFreeGroup (S : Type) (F_S : Group)
+  (i : S -> F_S) (A : Group) (g : S -> A) : Type
+  := {f : F_S $-> A & f o i == g}.
+
+(** Universal property of a free group on a set (type). *)
+Class IsFreeGroupOn (S : Type) (F_S : Group) (i : S -> F_S)
+  := contr_isfreegroupon : forall (A : Group) (g : S -> A),
+      Contr (FactorsThroughFreeGroup S F_S i A g).
+Global Existing Instance contr_isfreegroupon.
+
+(** A group is free if there exists a generating type on which it is a free group *)
+Class IsFreeGroup (F_S : Group)
+  := isfreegroup : exists S i, IsFreeGroupOn S F_S i.
+
+Global Instance isfreegroup_isfreegroupon (S : Type) (F_S : Group) (i : S -> F_S)
+  {H : IsFreeGroupOn S F_S i}
+  : IsFreeGroup F_S
+  := (S; i; H).
+
+
-- 
2.29.1


From 1ae248ab277ee4c62636353a3f4fde6306e7ce80 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Mon, 13 Jul 2020 10:44:52 +0100
Subject: [PATCH 06/76] fundamental group of 1-truncation

---
 theories/Homotopy/HomotopyGroup.v | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/theories/Homotopy/HomotopyGroup.v b/theories/Homotopy/HomotopyGroup.v
index c28f2a5af6..e3199a5169 100644
--- a/theories/Homotopy/HomotopyGroup.v
+++ b/theories/Homotopy/HomotopyGroup.v
@@ -264,3 +264,23 @@ Lemma pmap_pi_functor {X Y : pType} (f : X ->* Y) (n : nat)
 Proof.
   srapply Build_pHomotopy. 1: reflexivity. apply path_ishprop.
 Defined.
+
+(** Homotopy groups of truncations *)
+
+(** The fundamental group 1st truncation of X is isomorphic to the fundamental group of X *) 
+Theorem grp_iso_pi1_Tr `{Univalence} (X : pType)
+  : GroupIsomorphism (Pi1 (pTr 1 X)) (Pi1 X).
+Proof.
+  symmetry.
+  snrapply Build_GroupIsomorphism'.
+  { unfold Pi1.
+    unfold group_type.
+    refine ((Trunc_functor_equiv _ _ )^-1%equiv oE _).
+    1: symmetry; rapply ptr_loops.
+    rapply equiv_tr. }
+  intros x y.
+  strip_truncations.
+  apply path_Tr, tr.
+  exact (ap_pp tr x y).
+Defined.
+
-- 
2.29.1


From edb48d58b0b7654908ad4ba3ec524ab7746239fe Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Mon, 13 Jul 2020 10:45:15 +0100
Subject: [PATCH 07/76] fixed typo in ClassifyingSpace.v

---
 theories/Homotopy/ClassifyingSpace.v | 4 ++--
 theories/Homotopy/EMSpace.v          | 2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/theories/Homotopy/ClassifyingSpace.v b/theories/Homotopy/ClassifyingSpace.v
index 0a4ee838c5..95db5f8eb3 100644
--- a/theories/Homotopy/ClassifyingSpace.v
+++ b/theories/Homotopy/ClassifyingSpace.v
@@ -149,12 +149,12 @@ Defined.
 (** Now we focus on the classifying space of a group. *)
 
 (** The classifying space of a group is the following pointed type. *)
-Definition pClassifingSpace (G : Group)
+Definition pClassifyingSpace (G : Group)
   := Build_pType (ClassifyingSpace G) bbase.
 
 (** To use the B G notation for pClassifyingSpace import this module. *)
 Module Import ClassifyingSpaceNotation.
-  Definition B G := pClassifingSpace G.
+  Definition B G := pClassifyingSpace G.
 End ClassifyingSpaceNotation.
 
 Import ClassifyingSpaceNotation.
diff --git a/theories/Homotopy/EMSpace.v b/theories/Homotopy/EMSpace.v
index cac0fd1c15..8e1716b149 100644
--- a/theories/Homotopy/EMSpace.v
+++ b/theories/Homotopy/EMSpace.v
@@ -199,7 +199,7 @@ Section EilenbergMacLane.
   Fixpoint EilenbergMacLane (G : Group) (n : nat) : pType
     := match n with
         | 0    => Build_pType G _
-        | 1    => pClassifingSpace G
+        | 1    => pClassifyingSpace G
         | m.+1 => pTr m.+1 (psusp (EilenbergMacLane G m))
        end.
 
-- 
2.29.1


From 20bba629d2b682edaf83fd149555954bc7f3e709 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Mon, 13 Jul 2020 10:45:43 +0100
Subject: [PATCH 08/76] inclusion functor of Group into ooGroup

---
 theories/Algebra/ooGroup.v | 41 ++++++++++++++++++++++++++++++++++----
 1 file changed, 37 insertions(+), 4 deletions(-)

diff --git a/theories/Algebra/ooGroup.v b/theories/Algebra/ooGroup.v
index d416e2e6bf..7beae44263 100644
--- a/theories/Algebra/ooGroup.v
+++ b/theories/Algebra/ooGroup.v
@@ -1,9 +1,11 @@
 (* -*- mode: coq; mode: visual-line -*-  *)
-Require Import Basics.
-Require Import Types.
+Require Import Basics Types.
 Require Import Pointed.
 Require Import Truncations.
 Require Import Colimits.Quotient.
+Require Import Homotopy.ClassifyingSpace.
+Require Import Algebra.Groups.
+Require Import WildCat.
 
 Local Open Scope path_scope.
 Local Open Scope pointed_scope.
@@ -37,7 +39,7 @@ Coercion group_type : ooGroup >-> Sortclass.
 
 (** Every pointed type has a loop space that is an oo-group. *)
 Definition group_loops (X : pType)
-: ooGroup.
+  : ooGroup.
 Proof.
   (* Work around https://coq.inria.fr/bugs/show_bug.cgi?id=4256 *)
   pose (x0 := point X);
@@ -57,7 +59,7 @@ Defined.
 
 (** Unfortunately, the underlying type of that oo-group is not *definitionally* the same as the ordinary loop space, but it is equivalent to it. *)
 Definition loops_group (X : pType)
-: loops X <~> group_loops X.
+  : loops X <~> group_loops X.
 Proof.
   unfold loops, group_type. simpl.
   exact (equiv_path_sigma_hprop (point X ; tr 1) (point X ; tr 1)).
@@ -283,3 +285,34 @@ Section Subgroups.
   Definition cosets := Quotient in_coset.
 
 End Subgroups.
+
+(** The wild category of oo-groups is induced by the wild category of pTypes *)
+
+Global Instance isgraph_oogroup : IsGraph ooGroup := Build_IsGraph _ ooGroupHom.
+Global Instance is01cat_oogroup : Is01Cat ooGroup := Build_Is01Cat _ _ grouphom_idmap (@grouphom_compose).
+Global Instance is1cat_oogroup : Is1Cat ooGroup := induced_1cat classifying_space.
+
+(** ** 1-groups as oo-groups *)
+
+Definition group_to_oogroup : Group -> ooGroup
+  := fun G => Build_ooGroup (pClassifyingSpace G) _.
+
+Global Instance is0functor_group_to_oogroup : Is0Functor group_to_oogroup.
+Proof.
+  snrapply Build_Is0Functor.
+  intros G H f.
+  by rapply functor_pclassifyingspace.
+Defined.
+
+Global Instance is1functor_group_to_oogroup : Is1Functor group_to_oogroup.
+Proof.
+  snrapply Build_Is1Functor.
+  1: exact @functor2_pclassifyingspace.
+  1: exact functor_pclassifyingspace_idmap.
+  exact functor_pclassifyingspace_compose.
+Defined.
+
+
+
+
+
-- 
2.29.1


From 7579e5327e43164bf440c6a9e44147ff111d2488 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Mon, 13 Jul 2020 10:46:05 +0100
Subject: [PATCH 09/76] pre/post comp with pEquiv

---
 theories/Pointed/pEquiv.v | 51 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 51 insertions(+)

diff --git a/theories/Pointed/pEquiv.v b/theories/Pointed/pEquiv.v
index 0ad4d8e88f..c05c0af94a 100644
--- a/theories/Pointed/pEquiv.v
+++ b/theories/Pointed/pEquiv.v
@@ -108,3 +108,54 @@ Proof.
   apply pmap_postwhisker.
   symmetry; apply peisretr.
 Defined.
+
+Definition equiv_pequiv_precompose `{Funext} {A B C : pType} (f : A <~>* B)
+  : (B ->* C) <~> (A ->* C).
+Proof.
+  snrapply equiv_adjointify.
+  1: exact (fun g => g o* f).
+  1: exact (fun h => h o* f^-1*).
+  { intros g.
+    rapply equiv_path_pforall.
+    snrapply Build_pHomotopy.
+    { intro x; cbn.
+      apply ap, eissect. }
+    pointed_reduce.
+    unfold moveR_equiv_V.
+    hott_simpl. }
+  intros h.
+  rapply equiv_path_pforall.
+  snrapply Build_pHomotopy.
+  { intro x; cbn.
+    apply ap, eisretr. }
+  pointed_reduce.
+  unfold moveR_equiv_V.
+  hott_simpl.
+  refine (ap _ _ @ (ap_compose _ h _)^).
+  rapply eisadj.
+Defined.
+
+Definition equiv_pequiv_postcompose `{Funext} {A B C : pType} (f : B <~>* C)
+  : (A ->* B) <~> (A ->* C).
+Proof.
+  snrapply equiv_adjointify.
+  1: exact (fun g => f o* g).
+  1: exact (fun h => f^-1* o* h).
+  { intros g.
+    rapply equiv_path_pforall.
+    snrapply Build_pHomotopy.
+    { intro x; cbn.
+      apply eisretr. }
+    pointed_reduce.
+    unfold moveR_equiv_V.
+    hott_simpl.
+    apply eisadj. }
+  intros h.
+  rapply equiv_path_pforall.
+  snrapply Build_pHomotopy.
+  { intro x; cbn.
+    apply eissect. }
+  pointed_reduce.
+  unfold moveR_equiv_V.
+  hott_simpl.
+Defined.
-- 
2.29.1


From 1b2d569f5a366b5f46292a74fdc0d3b86fe05bc5 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Mon, 13 Jul 2020 10:46:30 +0100
Subject: [PATCH 10/76] precomp with cat_equiv

---
 theories/WildCat/Equiv.v | 26 ++++++++++++++++++++++++++
 1 file changed, 26 insertions(+)

diff --git a/theories/WildCat/Equiv.v b/theories/WildCat/Equiv.v
index 513b4e29f1..ac5e181ff3 100644
--- a/theories/WildCat/Equiv.v
+++ b/theories/WildCat/Equiv.v
@@ -323,3 +323,29 @@ Proof.
   - apply cate_issect.
   - apply cate_isretr.
 Defined.
+
+(** ** Pre/post-composition with equivalences *)
+
+(** Precompositon with a cat_equiv is an equivalence between the homs *)
+Definition equiv_precompose_cat_equiv {A : Type} `{HasEquivs A} `{!HasMorExt A}
+  {x y z : A} (f : x $<~> y)
+  : (y $-> z) <~> (x $-> z).
+Proof.
+  snrapply equiv_adjointify.
+  1: exact (fun g => g $o f).
+  1: exact (fun h => h $o f^-1$).
+  { intros h.
+    apply path_hom.
+    refine (cat_assoc _ _ _ $@ _).
+    refine (_ $@ _).
+    { rapply cat_postwhisker.
+      apply cate_issect. }
+    apply cat_idr. }
+  intros g.
+  apply path_hom.
+  refine (cat_assoc _ _ _ $@ _).
+  refine (_ $@ _).
+  { rapply cat_postwhisker.
+    apply cate_isretr. }
+  apply cat_idr.
+Defined.
-- 
2.29.1


From a1ddb2dd44076279f0f748f0dc0c5aa60a82bb8f Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Mon, 13 Jul 2020 10:47:19 +0100
Subject: [PATCH 11/76] made group_type argument explicit

---
 theories/Algebra/Groups/Group.v | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/theories/Algebra/Groups/Group.v b/theories/Algebra/Groups/Group.v
index 4ad1509c2c..28bbd8505b 100644
--- a/theories/Algebra/Groups/Group.v
+++ b/theories/Algebra/Groups/Group.v
@@ -26,7 +26,7 @@ Record Group := {
   group_isgroup : IsGroup group_type;
 }.
 
-Arguments group_type {_}.
+(* Arguments group_type {_}. *)
 Arguments group_sgop {_}.
 Arguments group_unit {_}.
 Arguments group_inverse {_}.
-- 
2.29.1


From c24182374b968ee300fb7adefe718286d4e4b5fd Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Mon, 13 Jul 2020 10:47:42 +0100
Subject: [PATCH 12/76] classifying space of fundamental group

---
 theories/Homotopy/ClassifyingSpace.v | 210 +++++++++++++++++++++++++++
 1 file changed, 210 insertions(+)

diff --git a/theories/Homotopy/ClassifyingSpace.v b/theories/Homotopy/ClassifyingSpace.v
index 95db5f8eb3..24300770a7 100644
--- a/theories/Homotopy/ClassifyingSpace.v
+++ b/theories/Homotopy/ClassifyingSpace.v
@@ -3,6 +3,8 @@ Require Import Algebra.AbGroups.
 Require Import Homotopy.HSpace.
 Require Import TruncType.
 Require Import Truncations.
+Require Import Homotopy.HomotopyGroup.
+Require Import Homotopy.WhiteheadsPrinciple.
 
 Local Open Scope pointed_scope.
 Local Open Scope trunc_scope.
@@ -387,3 +389,211 @@ Section HSpace_bg.
           bg_mul_right_id.
 
 End HSpace_bg.
+
+(** Functoriality of B(-) *)
+
+Definition functor_pclassifyingspace {G H : Group} (f : GroupHomomorphism G H)
+  : B G ->* B H.
+Proof.
+  snrapply Build_pMap.
+  { srapply ClassifyingSpace_rec.
+    1: exact (point _).
+    1: exact (bloop o f).
+    intros x y.
+    refine (ap bloop (grp_homo_op f x y) @ _).
+    apply bloop_pp. }
+  reflexivity.
+Defined.
+
+Definition functor2_pclassifyingspace {G H : Group} {f g : GroupHomomorphism G H}
+  : f == g -> functor_pclassifyingspace f ==* functor_pclassifyingspace g.
+Proof.
+  intro p.
+  snrapply Build_pHomotopy.
+  { srapply ClassifyingSpace_ind_hset.
+    1: reflexivity.
+    intro x.
+    unfold functor_pclassifyingspace.
+    rapply equiv_sq_dp^-1.
+    simpl.
+    rewrite 2 ClassifyingSpace_rec_beta_bloop.
+    apply sq_1G.
+    apply ap.
+    exact (p x). }
+  reflexivity.
+Defined.
+
+Definition functor_pclassifyingspace_idmap (G : Group)
+  : functor_pclassifyingspace (@grp_homo_id G) ==* pmap_idmap.
+Proof.
+  snrapply Build_pHomotopy.
+  { srapply ClassifyingSpace_ind_hset.
+    1: reflexivity.
+    intro x.
+    rapply equiv_sq_dp^-1.
+    simpl.
+    rewrite ClassifyingSpace_rec_beta_bloop.
+    apply sq_1G.
+    symmetry.
+    apply ap_idmap. }
+  reflexivity.
+Defined.
+
+Definition functor_pclassifyingspace_compose (A B C : Group)
+  (g : GroupHomomorphism A B) (f : GroupHomomorphism B C)
+  : functor_pclassifyingspace (grp_homo_compose f g)
+  ==* functor_pclassifyingspace f o* functor_pclassifyingspace g.
+Proof.
+  snrapply Build_pHomotopy.
+  { srapply ClassifyingSpace_ind_hset.
+    1: reflexivity.
+    intro x.
+    rapply equiv_sq_dp^-1.
+    simpl.
+    rapply sq_ccGG.
+    1,2: symmetry.
+    2: refine (ap_compose (ClassifyingSpace_rec _ _ _ (fun x y =>
+      ap bloop (grp_homo_op g x y) @ bloop_pp (g x) (g y))) _ (bloop x)
+      @ ap _ _ @ _).
+    1-3: nrapply ClassifyingSpace_rec_beta_bloop.
+    apply sq_1G.
+    reflexivity. }
+  reflexivity.
+Defined.
+
+(** Interestingly, [functor_pclassifyingspace] is an equivalence *)
+Global Instance isequiv_functor_pclassifyingspace `{U : Univalence} (G H : Group)
+  : IsEquiv (@functor_pclassifyingspace G H).
+Proof.
+  snrapply isequiv_adjointify.
+  { intros f.
+    refine (grp_homo_compose _ (grp_homo_compose _ (grp_iso_inverse _))).
+    1,3: rapply grp_iso_loopgroup_bg.
+    snrapply Build_GroupHomomorphism.
+    1: by nrapply loops_functor.
+    intros x y.
+    apply loops_functor_pp. }
+  { intros f.
+    rapply equiv_path_pforall.
+    snrapply Build_pHomotopy.
+    { srapply ClassifyingSpace_ind_hset.
+      { cbn; symmetry.
+        rapply (point_eq f). }
+      { intro g.
+        rapply equiv_sq_dp^-1.
+        unfold functor_pclassifyingspace.
+        unfold Build_pMap.
+        unfold pointed_fun.
+        rewrite ClassifyingSpace_rec_beta_bloop.
+        simpl.
+        rapply sq_ccGc.
+        1: symmetry; rapply decode_encode.
+        apply equiv_sq_path.
+        hott_simpl. } }
+      symmetry; apply concat_1p. }
+  intros f.
+  rapply equiv_path_grouphomomorphism.
+  simpl; intro g.
+  rapply (moveR_equiv_M' equiv_loops_bg_g).
+  rewrite concat_1p, concat_p1.
+  rewrite ClassifyingSpace_rec_beta_bloop.
+  reflexivity.
+Defined.
+
+(** Hence we have that group homomorphisms are equivalent to pointed maps between their deloopings. *)
+Theorem equiv_grp_homo_pmap_bg `{U : Univalence} (G H : Group)
+  : (GroupHomomorphism G H) <~> (B G ->* B H).
+Proof.
+  snrapply Build_Equiv.
+  2: apply isequiv_functor_pclassifyingspace.
+Defined.
+
+(** TODO: clean up and speed up *)
+(** Using Whitehead's principle we can prove that B(Pi 1 X) = X for a 0-connected 1-truncated X. *)
+Theorem pequiv_pclassifyingspace_pi1 `{Univalence}
+  (X : pType) `{IsConnected 0 X} `{IsTrunc 1 X}
+  : B (Pi1 X) <~>* X.
+Proof.
+  snrapply Build_pEquiv'.
+  { snrapply Build_Equiv.
+    (** First we give the map inducing equivalences between homotopy groups. *)
+    { srapply ClassifyingSpace_rec.
+      1: exact (point _).
+      { apply Trunc_rec.
+        exact idmap. }
+      intros x y.
+      strip_truncations.
+      reflexivity. }
+    (** Now we apply Whitehead's principle *)
+    snrapply whiteheads_principle.
+    1: exact _.
+    1: exact 1.
+    1,2: exact _.
+    1: apply isequiv_contr_contr.
+    (** We need to show that this map induces equivalences for all homotopy groups *)
+    intros x n.
+    revert x.
+    snrapply ClassifyingSpace_ind_hset.
+    1: exact _.
+    2: intro x; apply equiv_dp_path_transport, path_ishprop.
+    hnf.
+    unfold pmap_from_point.
+    unfold Build_pMap.
+    (** The case for n = 1 follows from the universal property of BG *)
+    destruct n.
+    { simpl.
+      snrapply isequiv_homotopic'.
+      { simpl.
+        transitivity (loops (pClassifyingSpace (Pi1 X))).
+        1: symmetry; rapply equiv_tr.
+        rapply equiv_loops_bg_g. }
+      intro x.
+      strip_truncations.
+      simpl.
+      unfold Trunc_functor.
+      unfold O_functor.
+      unfold O_rec.
+      simpl.
+      revert x.
+      snrapply equiv_ind.
+      2: apply equiv_loops_bg_g.
+      1: exact _.
+      intro p.
+      simpl.
+      rewrite ClassifyingSpace_rec_beta_bloop.
+      unfold encode.
+      rewrite codes_transport.
+      strip_truncations.
+      apply path_Tr, tr.
+      hott_simpl. }
+    (** The case for n > 1 follows since higher homotopy groups are trivial *)
+    snrapply isequiv_contr_contr.
+    { nrapply contr_equiv'.
+      { apply equiv_tr.
+        Search IsTrunc Contr.
+        nrapply trunc_contr.
+        apply equiv_istrunc_contr_iterated_loops.
+        snrapply trunc_leq.
+        1: exact 1.
+        { induction n.
+          1: exact tt.
+          rapply trunc_index_leq_transitive. }
+        exact _. }
+      apply equiv_istrunc_contr_iterated_loops.
+      induction n; exact _. }
+    { nrapply contr_equiv'.
+      { apply equiv_tr.
+        Search IsTrunc Contr.
+        nrapply trunc_contr.
+        apply equiv_istrunc_contr_iterated_loops.
+        snrapply trunc_leq.
+        1: exact 1.
+        { induction n.
+          1: exact tt.
+          rapply trunc_index_leq_transitive. }
+        exact _. }
+      apply equiv_istrunc_contr_iterated_loops.
+      induction n; exact _. } }
+  (** Finally we need to show that this equivalence is pointed *)
+  reflexivity.
+Defined.
-- 
2.29.1


From 0457437cb8fb2368b29b326a3067c67f4fa80793 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Mon, 13 Jul 2020 10:48:42 +0100
Subject: [PATCH 13/76] partial implementation of free group as fundamental
 group of suspension

---
 _CoqProject                                  |   1 +
 theories/Algebra/Groups/FreeGroup/LoopSusp.v | 128 +++++++++++++++++++
 2 files changed, 129 insertions(+)
 create mode 100644 theories/Algebra/Groups/FreeGroup/LoopSusp.v

diff --git a/_CoqProject b/_CoqProject
index f0c49b327e..b86b50a664 100644
--- a/_CoqProject
+++ b/_CoqProject
@@ -351,6 +351,7 @@ theories/Algebra/Groups/GrpPullback.v
 theories/Algebra/Groups/FreeGroup.v
 
 theories/Algebra/Groups/FreeGroup/KrausAltenkirch.v
+theories/Algebra/Groups/FreeGroup/LoopSusp.v
 
 #
 #   Tactics
diff --git a/theories/Algebra/Groups/FreeGroup/LoopSusp.v b/theories/Algebra/Groups/FreeGroup/LoopSusp.v
new file mode 100644
index 0000000000..69ed1edd6d
--- /dev/null
+++ b/theories/Algebra/Groups/FreeGroup/LoopSusp.v
@@ -0,0 +1,128 @@
+Require Import Basics Types.
+Require Import Groups.Group.
+Require Import Pointed.
+Require Import WildCat.
+Require Import Truncations.
+Require Import Homotopy.Suspension.
+Require Import Homotopy.ClassifyingSpace.
+Require Import Homotopy.HomotopyGroup.
+
+Local Open Scope pointed_scope.
+Import ClassifyingSpaceNotation.
+
+(** In this file we experiment with defining the free group on [A] to be the fundamental group of the suspension of [A + Unit]. *)
+
+(** Note that this is NOT the definition of a free group that is used in the library. The definition in use will be exported in the file Algebra.Groups.FreeGroup. This file merely exists to serve as a demonstration that the free group *could* be defined this way.
+
+This is not a very practical definition because we cannot even show that it is free at the time of writing, and univalence is used in a crucial way which seems overkill for a definition of freegroup. *)
+
+
+(** TODO: Perhaps move this to the Pointed directory? *)
+(** The free base point added to a type. This is in fact a functor and left adjoint to the forgetful functor pType to Type. *)
+Definition pointify (S : Type) : pType := Build_pType (S + Unit) (inr tt).
+
+(** pointify is left adjoint to forgetting the basepoint in the following sense *)
+Theorem equiv_pointify_map `{Funext} (A : Type) (X : pType)
+  : (pointify A ->* X) <~> (A -> X).
+Proof.
+  snrapply equiv_adjointify.
+  1: exact (fun f => f o inl).
+  { intros f.
+    snrapply Build_pMap.
+    { intros [a|].
+      1: exact (f a).
+      exact (point _). }
+    reflexivity. }
+  1: intro x; reflexivity.
+  intros f.
+  cbv.
+  pointed_reduce.
+  rapply equiv_path_pforall.
+  snrapply Build_pHomotopy.
+  1: by intros [a|[]].
+  reflexivity.
+Defined.
+
+(** We can rephrase the universal property of the free group as a certain precomposition being an equivalence. *)
+Definition isfreegroupon_isequiv_postcomp `{Funext} (F : Group) (A : Type) (i : A -> F)
+  : (forall G, IsEquiv (fun f : F $-> G => f o i)) -> IsFreeGroupOn A F i.
+Proof.
+  intros k G g.
+  specialize (k G).
+  snrapply contr_equiv'.
+  1: exact (hfiber (fun f x => grp_homo_map F G f (i x)) g).
+  { rapply equiv_functor_sigma_id.
+    intro y; symmetry.
+    apply equiv_path_forall. }
+  exact _.
+Defined.
+
+Section AssumeUnivalence.
+
+  Context `{Univalence}.
+
+  (** We define the free group as the 0-truncation of the loop space of the suspension of S + 1. Or in other words the fundamental group of the suspension of S + 1. *)
+  Definition FreeGroup (S : Type) : Group
+    := Pi1 (psusp (pointify S)).
+
+  (** We can directly prove that it satisfies the desired equivalence. *)
+  Theorem equiv_freegroup_rec (S : Type) (G : Group)
+    : (FreeGroup S $-> G) <~> (S -> G).
+  Proof.
+    unfold FreeGroup.
+    (** The first step is to swap the fundemantal group for the fundemantal group of a truncation. This will be important later. *)
+    etransitivity.
+    { srapply equiv_precompose_cat_equiv.
+      1: exact (Pi1 (pTr 1 (psusp (pointify S)))).
+      apply grp_iso_pi1_Tr. }
+    (** Now we use the equivalence of group homomorphisms and pointed maps between their deloopings. *)
+    etransitivity.
+    1: rapply equiv_grp_homo_pmap_bg.
+    (** Now since we have the classifying space of a fundamental group, we can change it into the original type. This lemma only works since the truncation is 1-truncated. *)
+    etransitivity.
+    { rapply equiv_pequiv_precompose.
+      symmetry.
+      nrapply pequiv_pclassifyingspace_pi1.
+      1,3: exact _.
+      apply isconnected_trunc.
+      rapply isconnected_susp.
+      rapply contr_inhabited_hprop.
+      apply tr; exact (point _). }
+    (** We can now get rid of the truncation by the universal property of trucation since BG is 1-truncated. *)
+    etransitivity.
+    1: rapply equiv_ptr_rec.
+    (** Applying the loop-susp adjunction *)
+    etransitivity.
+    1: apply loop_susp_adjoint.
+    (** Now we use the pointed equivalence between a group and the loop space of its delooping *)
+    etransitivity.
+    { rapply equiv_pequiv_postcompose.
+      apply pequiv_loops_bg_g. }
+    (** Finally we use the pointify adjunction. *)
+    apply equiv_pointify_map.
+  Defined.
+
+  (** We can define the inclusion map by using the previous equivalence on the identity group homomorphism. *)
+  Definition freegroup_incl (S : Type) : S -> FreeGroup S.
+  Proof.
+    rapply equiv_freegroup_rec.
+    apply grp_homo_id.
+  Defined.
+
+  (** This in theory would allow us to prove that this definition of a free group is in fact a free group. We however run into trouble. We have to use [isequiv_homotopic'] since we are not using the specific map that the property of being a free group uses. However showing that these two maps are homotopic seems to be nontrivial. Coq struggles a lot working with the extreme amount of data needed to be unfolded here as well. Therefore we leave this instance as aborted. *)
+  Global Instance isfreegroupon_freegroup (S : Type)
+    : IsFreeGroupOn S (FreeGroup S) (freegroup_incl S).
+  Proof.
+    apply isfreegroupon_isequiv_postcomp.
+    intro G.
+    snrapply isequiv_homotopic'.
+    1: apply equiv_freegroup_rec.
+    intro f.
+    unfold equiv_freegroup_rec.
+    unfold transitive_equiv.
+    unfold equiv_compose.
+    unfold equiv_isequiv.
+    (** It's not obvious how this can be finished. *)
+  Abort.
+
+End AssumeUnivalence.
-- 
2.29.1


From 379003927a3925d00c4d27f9c5488d0a387a35e6 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Mon, 13 Jul 2020 10:51:35 +0100
Subject: [PATCH 14/76] added properties of IsFreeGroupOn

---
 theories/Algebra/Groups/FreeGroup.v | 27 +++++++++++++++++++++------
 1 file changed, 21 insertions(+), 6 deletions(-)

diff --git a/theories/Algebra/Groups/FreeGroup.v b/theories/Algebra/Groups/FreeGroup.v
index 1da0981a2a..c79539dc59 100644
--- a/theories/Algebra/Groups/FreeGroup.v
+++ b/theories/Algebra/Groups/FreeGroup.v
@@ -35,11 +35,26 @@ Proof.
   rapply equiv_isfreegroup_rec.
 Defined.
 
-(** TODO: Nielsen-Schreier theorem: Subgroups of free groups are free. Proofs of this statement are non-trivial. We can prove it using covering spaces which haven't yet been considered in this library. In fact, every known proof requires the axiom of choice in some crucical way. *)
-
-(** Here is a sketch of such a proof. If F is a free group on a type X, then it is the fundamental group of the suspension of (X + 1) (This coule be by definition). A subgroup is then the fundamental group of a covering space of Susp (X + 1). This space is a connected 1-type and using choice we can show it has a spanning tree (since it is a topological graph). By shrinking the spanning tree we get that this cover is also the suspension of some non-empty type, hence is a free group. This "proof" is however a sketch and there may be serious problems when allowing groups to be free over arbitrary types. *)
-
-(** TODO: If F(A) $<~> F(B) then the cardinalities of [A] and [B] are the same. *)
+Global Instance ishprop_isfreegroupon `{Funext} (F : Group) (A : Type) (i : A -> F)
+  : IsHProp (IsFreeGroupOn A F i).
+Proof.
+  unfold IsFreeGroupOn.
+  apply trunc_forall.
+Defined.
 
-(** A proof might go like this: If F(A) $<~> F(B) then so are their abelianizations F(A)^ab $<~> F(B)^ab. It can be shown that F(A)^ab = Z^A hence we need only compare ranks of free abelian groups. It is not clear to me at the time of writing that this is now easier to prove however. *)
+(** Both ways of stating the universal property are equivalent. *)
+Definition equiv_isfregroupon_isequiv_precomp `{Funext} (F : Group) (A : Type) (i : A -> F)
+  : IsFreeGroupOn A F i <~> forall G, IsEquiv (fun f : F $-> G => f o i).
+Proof.
+  srapply equiv_iff_hprop.
+  1: intros k G; rapply (equiv_isequiv (equiv_isfreegroup_rec G F A i)).
+  intros k G g.
+  specialize (k G).
+  snrapply contr_equiv'.
+  1: exact (hfiber (fun f x => grp_homo_map F G f (i x)) g).
+  { rapply equiv_functor_sigma_id.
+    intro y; symmetry.
+    apply equiv_path_forall. }
+  exact _.
+Defined.
 
-- 
2.29.1


From af07784e78596b9e85a9bf4d599f7fc17e2e80a3 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Mon, 13 Jul 2020 10:59:40 +0100
Subject: [PATCH 15/76] added FreeGroup to Group indexing file

---
 theories/Algebra/Groups.v | 1 +
 1 file changed, 1 insertion(+)

diff --git a/theories/Algebra/Groups.v b/theories/Algebra/Groups.v
index f35545e4a6..ef0f331823 100644
--- a/theories/Algebra/Groups.v
+++ b/theories/Algebra/Groups.v
@@ -6,6 +6,7 @@ Require Export HoTT.Algebra.Groups.QuotientGroup.
 Require Export HoTT.Algebra.Groups.Image.
 Require Export HoTT.Algebra.Groups.Kernel.
 Require Export HoTT.Algebra.Groups.GrpPullback.
+Require Export HoTT.Algebra.Groups.FreeGroup.
 
 (** Examples *)
 
-- 
2.29.1


From 9916aa932de33d96265c5b233fb4539a62e6c054 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 16 Jul 2020 21:12:37 +0100
Subject: [PATCH 16/76] Fixed whitespace

---
 theories/Algebra/Groups/FreeGroup/KrausAltenkirch.v | 4 ----
 theories/Algebra/Groups/Group.v                     | 2 --
 2 files changed, 6 deletions(-)

diff --git a/theories/Algebra/Groups/FreeGroup/KrausAltenkirch.v b/theories/Algebra/Groups/FreeGroup/KrausAltenkirch.v
index 96779831cb..d9861e6433 100644
--- a/theories/Algebra/Groups/FreeGroup/KrausAltenkirch.v
+++ b/theories/Algebra/Groups/FreeGroup/KrausAltenkirch.v
@@ -355,7 +355,3 @@ Section Reduction.
   Definition isfreegroup_freegrup `{Funext} : IsFreeGroup FreeGroup := _.
 
 End Reduction.
-
-
-
-
diff --git a/theories/Algebra/Groups/Group.v b/theories/Algebra/Groups/Group.v
index 28bbd8505b..48a07db6cf 100644
--- a/theories/Algebra/Groups/Group.v
+++ b/theories/Algebra/Groups/Group.v
@@ -561,5 +561,3 @@ Global Instance isfreegroup_isfreegroupon (S : Type) (F_S : Group) (i : S -> F_S
   {H : IsFreeGroupOn S F_S i}
   : IsFreeGroup F_S
   := (S; i; H).
-
-
-- 
2.29.1


From 351619d3cc11207f42a2433d0ab249fccea750bd Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 16 Jul 2020 21:13:13 +0100
Subject: [PATCH 17/76] Update theories/Algebra/ooGroup.v

---
 theories/Algebra/ooGroup.v | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/theories/Algebra/ooGroup.v b/theories/Algebra/ooGroup.v
index 7beae44263..9b9cc7b0f2 100644
--- a/theories/Algebra/ooGroup.v
+++ b/theories/Algebra/ooGroup.v
@@ -311,8 +311,3 @@ Proof.
   1: exact functor_pclassifyingspace_idmap.
   exact functor_pclassifyingspace_compose.
 Defined.
-
-
-
-
-
-- 
2.29.1


From 53e5405e887904170be88f0a3d860d636564e72a Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 6 Aug 2020 12:15:51 +0100
Subject: [PATCH 18/76] remove Arguments declaration for group_type

---
 theories/Algebra/Groups/Group.v | 1 -
 1 file changed, 1 deletion(-)

diff --git a/theories/Algebra/Groups/Group.v b/theories/Algebra/Groups/Group.v
index 48a07db6cf..0667719abc 100644
--- a/theories/Algebra/Groups/Group.v
+++ b/theories/Algebra/Groups/Group.v
@@ -26,7 +26,6 @@ Record Group := {
   group_isgroup : IsGroup group_type;
 }.
 
-(* Arguments group_type {_}. *)
 Arguments group_sgop {_}.
 Arguments group_unit {_}.
 Arguments group_inverse {_}.
-- 
2.29.1


From 0a1303072f99406a4642b94d12d4894333e8227e Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 6 Aug 2020 12:17:50 +0100
Subject: [PATCH 19/76] changed exists to sigma notation

---
 theories/Algebra/Groups/Group.v | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/theories/Algebra/Groups/Group.v b/theories/Algebra/Groups/Group.v
index 0667719abc..27394893ef 100644
--- a/theories/Algebra/Groups/Group.v
+++ b/theories/Algebra/Groups/Group.v
@@ -554,7 +554,7 @@ Global Existing Instance contr_isfreegroupon.
 
 (** A group is free if there exists a generating type on which it is a free group *)
 Class IsFreeGroup (F_S : Group)
-  := isfreegroup : exists S i, IsFreeGroupOn S F_S i.
+  := isfreegroup : {S : _ & {i : _ & IsFreeGroupOn S F_S i}}.
 
 Global Instance isfreegroup_isfreegroupon (S : Type) (F_S : Group) (i : S -> F_S)
   {H : IsFreeGroupOn S F_S i}
-- 
2.29.1


From d49a2b5a0c11949a3a34036b2e11cf7c9628ef61 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 6 Aug 2020 12:26:29 +0100
Subject: [PATCH 20/76] added wildcat postcomp equiv

---
 theories/WildCat/Equiv.v | 25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/theories/WildCat/Equiv.v b/theories/WildCat/Equiv.v
index ac5e181ff3..7509f1dae2 100644
--- a/theories/WildCat/Equiv.v
+++ b/theories/WildCat/Equiv.v
@@ -349,3 +349,28 @@ Proof.
     apply cate_isretr. }
   apply cat_idr.
 Defined.
+
+(** Postcompositon with a cat_equiv is an equivalence between the homs *)
+Definition equiv_postcompose_cat_equiv {A : Type} `{HasEquivs A} `{!HasMorExt A}
+  {x y z : A} (f : y $<~> z)
+  : (x $-> y) <~> (x $-> z).
+Proof.
+  snrapply equiv_adjointify.
+  1: exact (fun g => f $o g).
+  1: exact (fun h => f^-1$ $o h).
+  { intros h.
+    apply path_hom.
+    refine ((cat_assoc _ _ _)^$ $@ _).
+    refine (_ $@ _).
+    { rapply cat_prewhisker.
+      apply cate_isretr. }
+    apply cat_idl. }
+  intros g.
+  apply path_hom.
+  refine ((cat_assoc _ _ _)^$ $@ _).
+  refine (_ $@ _).
+  { rapply cat_prewhisker.
+    apply cate_issect. }
+  apply cat_idl.
+Defined.
+
-- 
2.29.1


From 4f5420fd6dca45eb371659ba858e9ac751a5a9e1 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 6 Aug 2020 12:26:54 +0100
Subject: [PATCH 21/76] pre/postcomp equivs for pType using wildcat

---
 theories/Pointed/pEquiv.v | 51 +++------------------------------------
 1 file changed, 4 insertions(+), 47 deletions(-)

diff --git a/theories/Pointed/pEquiv.v b/theories/Pointed/pEquiv.v
index c05c0af94a..c5ca9952a3 100644
--- a/theories/Pointed/pEquiv.v
+++ b/theories/Pointed/pEquiv.v
@@ -110,52 +110,9 @@ Proof.
 Defined.
 
 Definition equiv_pequiv_precompose `{Funext} {A B C : pType} (f : A <~>* B)
-  : (B ->* C) <~> (A ->* C).
-Proof.
-  snrapply equiv_adjointify.
-  1: exact (fun g => g o* f).
-  1: exact (fun h => h o* f^-1*).
-  { intros g.
-    rapply equiv_path_pforall.
-    snrapply Build_pHomotopy.
-    { intro x; cbn.
-      apply ap, eissect. }
-    pointed_reduce.
-    unfold moveR_equiv_V.
-    hott_simpl. }
-  intros h.
-  rapply equiv_path_pforall.
-  snrapply Build_pHomotopy.
-  { intro x; cbn.
-    apply ap, eisretr. }
-  pointed_reduce.
-  unfold moveR_equiv_V.
-  hott_simpl.
-  refine (ap _ _ @ (ap_compose _ h _)^).
-  rapply eisadj.
-Defined.
+  : (B ->* C) <~> (A ->* C)
+  := equiv_precompose_cat_equiv f.
 
 Definition equiv_pequiv_postcompose `{Funext} {A B C : pType} (f : B <~>* C)
-  : (A ->* B) <~> (A ->* C).
-Proof.
-  snrapply equiv_adjointify.
-  1: exact (fun g => f o* g).
-  1: exact (fun h => f^-1* o* h).
-  { intros g.
-    rapply equiv_path_pforall.
-    snrapply Build_pHomotopy.
-    { intro x; cbn.
-      apply eisretr. }
-    pointed_reduce.
-    unfold moveR_equiv_V.
-    hott_simpl.
-    apply eisadj. }
-  intros h.
-  rapply equiv_path_pforall.
-  snrapply Build_pHomotopy.
-  { intro x; cbn.
-    apply eissect. }
-  pointed_reduce.
-  unfold moveR_equiv_V.
-  hott_simpl.
-Defined.
+  : (A ->* B) <~> (A ->* C)
+  := equiv_postcompose_cat_equiv f.
-- 
2.29.1


From b82d0260ce15d6ba999028e238d476d3d3a2d598 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 6 Aug 2020 12:29:16 +0100
Subject: [PATCH 22/76] Update theories/Algebra/Groups/FreeGroup.v

Co-authored-by: Mike Shulman <viritrilbia@gmail.com>
---
 theories/Algebra/Groups/FreeGroup.v | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/theories/Algebra/Groups/FreeGroup.v b/theories/Algebra/Groups/FreeGroup.v
index c79539dc59..d7070bab12 100644
--- a/theories/Algebra/Groups/FreeGroup.v
+++ b/theories/Algebra/Groups/FreeGroup.v
@@ -28,7 +28,7 @@ Proof.
   exact _.
 Defined.
 
-(** The above theorem is true regardless of the implementation of free groups. This let's us state the more specific theorem about the free groups themselves. This can be read as [FreeGroup] is left adjoint to the forgetful functor [group_type]. *)
+(** The above theorem is true regardless of the implementation of free groups. This lets us state the more specific theorem about the canonical free groups. This can be read as [FreeGroup] is left adjoint to the forgetful functor [group_type]. *)
 Theorem equiv_freegroup_rec `{Funext} (G : Group) (A : Type)
   : (FreeGroup A $-> G) <~> (A -> G).
 Proof.
@@ -57,4 +57,3 @@ Proof.
     apply equiv_path_forall. }
   exact _.
 Defined.
-
-- 
2.29.1


From 27078eba68d30416b9b3417ec3e4404cdc7d37be Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 6 Aug 2020 12:38:24 +0100
Subject: [PATCH 23/76] rename KrausAltenkirch to ListQuotient

---
 _CoqProject                                                   | 2 +-
 theories/Algebra/Groups/FreeGroup.v                           | 4 ++--
 .../Groups/FreeGroup/{KrausAltenkirch.v => ListQuotient.v}    | 2 +-
 3 files changed, 4 insertions(+), 4 deletions(-)
 rename theories/Algebra/Groups/FreeGroup/{KrausAltenkirch.v => ListQuotient.v} (98%)

diff --git a/_CoqProject b/_CoqProject
index b86b50a664..6b542bc7b6 100644
--- a/_CoqProject
+++ b/_CoqProject
@@ -350,7 +350,7 @@ theories/Algebra/Groups/Kernel.v
 theories/Algebra/Groups/GrpPullback.v
 theories/Algebra/Groups/FreeGroup.v
 
-theories/Algebra/Groups/FreeGroup/KrausAltenkirch.v
+theories/Algebra/Groups/FreeGroup/ListQuotient.v
 theories/Algebra/Groups/FreeGroup/LoopSusp.v
 
 #
diff --git a/theories/Algebra/Groups/FreeGroup.v b/theories/Algebra/Groups/FreeGroup.v
index d7070bab12..9df6c4443d 100644
--- a/theories/Algebra/Groups/FreeGroup.v
+++ b/theories/Algebra/Groups/FreeGroup.v
@@ -2,10 +2,10 @@ Require Import Basics Types.
 Require Import Groups.Group.
 Require Import WildCat.
 
-(** Free groups are defined in Group.v. In this file we prove properties of free groups. There are various constructions of free groups to choose from, all of which can be found in the FreeGroup folder. *)
+(** Free groups are defined in Group.v. In this file we prove properties of free groups. There are various constructions of free groups to choose from, all of which can be found in the FreeGroup folder. Though, this is a bit of a lie since currently there is only one full implmentation. O:-) *)
 
 (** In this file, and in the rest of the library we choose a modified version of the free group which can be found in Kraus-Altenkirch 2018 arXiv:1805.02069. This is a very simple HIT in a similar manner to the abelianization HIT used in Algebra.AbGroup.Abelianization. *)
-Require Export Algebra.Groups.FreeGroup.KrausAltenkirch.
+Require Export Algebra.Groups.FreeGroup.ListQuotient.
 
 (** Properties of free groups *)
 
diff --git a/theories/Algebra/Groups/FreeGroup/KrausAltenkirch.v b/theories/Algebra/Groups/FreeGroup/ListQuotient.v
similarity index 98%
rename from theories/Algebra/Groups/FreeGroup/KrausAltenkirch.v
rename to theories/Algebra/Groups/FreeGroup/ListQuotient.v
index d9861e6433..950e676fad 100644
--- a/theories/Algebra/Groups/FreeGroup/KrausAltenkirch.v
+++ b/theories/Algebra/Groups/FreeGroup/ListQuotient.v
@@ -6,7 +6,7 @@ Require Import HIT.Coeq.
 Local Open Scope mc_scope.
 Local Open Scope mc_mult_scope.
 
-(** In this file we construct the free abelian group on a type [A] as a higher inductive type. This construction is due to Kraus and Altenkirch. Their construction is actually more general, but we set truncate it to suit our needs which is the free group as a set. *)
+(** In this file we construct the free abelian group on a type [A] as a higher inductive type. This construction is due to Kraus-Altenkirch 2018 arXiv:1805.02069. Their construction is actually more general, but we set truncate it to suit our needs which is the free group as a set. *)
 
 Section Reduction.
 
-- 
2.29.1


From 51e5b9ef166f873396802a1f343e6b773fedc973 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 6 Aug 2020 15:25:34 +0100
Subject: [PATCH 24/76] finished unfinished proof of words_rec_coh

---
 .../Algebra/Groups/FreeGroup/ListQuotient.v   | 23 +++++++++++++------
 1 file changed, 16 insertions(+), 7 deletions(-)

diff --git a/theories/Algebra/Groups/FreeGroup/ListQuotient.v b/theories/Algebra/Groups/FreeGroup/ListQuotient.v
index 950e676fad..5a51c054b4 100644
--- a/theories/Algebra/Groups/FreeGroup/ListQuotient.v
+++ b/theories/Algebra/Groups/FreeGroup/ListQuotient.v
@@ -289,13 +289,7 @@ Section Reduction.
     exact (- s x).
   Defined.
 
-  Lemma words_rec_coh (G : Group) (s : A -> G) (a : A + A) (b c : Words)
-    : words_rec G s (map1 (b, a, c)) = words_rec G s (map2 (b, a, c)).
-  Proof.
-    
-  Admitted.
-
-  Lemma words_rec_pp  (G : Group) (s : A -> G)  (x y : Words)
+  Lemma words_rec_pp (G : Group) (s : A -> G)  (x y : Words)
     : words_rec G s (x @ y) = words_rec G s x * words_rec G s y.
   Proof.
     induction x.
@@ -304,6 +298,21 @@ Section Reduction.
     f_ap.
   Defined.
 
+  Lemma words_rec_coh (G : Group) (s : A -> G) (a : A + A) (b c : Words)
+    : words_rec G s (map1 (b, a, c)) = words_rec G s (map2 (b, a, c)).
+  Proof.
+    unfold map1, map2.
+    refine (concat _ (words_rec_pp G s _ _)^).
+    refine (concat (words_rec_pp G s _ _) _); f_ap.
+    refine (concat _ (right_identity _)).
+    refine (concat (ap _ (word_concat_w_ww _ _ _)^) _).
+    refine (concat (words_rec_pp G s _ _) _); f_ap.
+    refine (concat (concat (simple_associativity _ _ _) _) (left_identity mon_unit)).
+    destruct a; simpl; f_ap.
+    + apply right_inverse.
+    + apply left_inverse.
+  Defined.
+
   (** Given a group [G] we can construct a group homomorphism [FreeGroup A -> G] if we have a map [A -> G] *)
   Definition FreeGroup_rec (G : Group) (s : A -> G)
     : GroupHomomorphism FreeGroup G.
-- 
2.29.1


From 5285afda86428f1f76a176a2fe0e6ee4c7b61e9f Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Fri, 7 Aug 2020 12:12:23 +0100
Subject: [PATCH 25/76] update submodules to 8.12

---
 coq-HoTT         | 2 +-
 etc/coq-dpdgraph | 2 +-
 etc/coq-scripts  | 2 +-
 3 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/coq-HoTT b/coq-HoTT
index aea8e0b975..c97b82cda0 160000
--- a/coq-HoTT
+++ b/coq-HoTT
@@ -1 +1 @@
-Subproject commit aea8e0b9754c43f05d4c82f35ce495974cdd3501
+Subproject commit c97b82cda0ba4c0b9ad8199658c3a09461f3a8d7
diff --git a/etc/coq-dpdgraph b/etc/coq-dpdgraph
index 13b19bb86a..42636fc7fd 160000
--- a/etc/coq-dpdgraph
+++ b/etc/coq-dpdgraph
@@ -1 +1 @@
-Subproject commit 13b19bb86a23092f7408d26e7d8e4ca733fa3f28
+Subproject commit 42636fc7fdd0cc918254308d428db594c9d7d81c
diff --git a/etc/coq-scripts b/etc/coq-scripts
index 371f58392c..d0b8e808e0 160000
--- a/etc/coq-scripts
+++ b/etc/coq-scripts
@@ -1 +1 @@
-Subproject commit 371f58392cbabaa51a1e7f9b8dcb132fffd10e6d
+Subproject commit d0b8e808e0382d791eb6c0a2d9d751300a2d2057
-- 
2.29.1


From c118ad94a2e2aa63d0334d46e6ce7816124460fa Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 6 Aug 2020 13:25:56 +0100
Subject: [PATCH 26/76] (amalgamated) free products of groups

---
 _CoqProject                           |   1 +
 theories/Algebra/Groups/FreeProduct.v | 721 ++++++++++++++++++++++++++
 2 files changed, 722 insertions(+)
 create mode 100644 theories/Algebra/Groups/FreeProduct.v

diff --git a/_CoqProject b/_CoqProject
index 6b542bc7b6..3270153e82 100644
--- a/_CoqProject
+++ b/_CoqProject
@@ -348,6 +348,7 @@ theories/Algebra/Groups/QuotientGroup.v
 theories/Algebra/Groups/Image.v
 theories/Algebra/Groups/Kernel.v
 theories/Algebra/Groups/GrpPullback.v
+theories/Algebra/Groups/FreeProduct.v
 theories/Algebra/Groups/FreeGroup.v
 
 theories/Algebra/Groups/FreeGroup/ListQuotient.v
diff --git a/theories/Algebra/Groups/FreeProduct.v b/theories/Algebra/Groups/FreeProduct.v
new file mode 100644
index 0000000000..cd73e3e77e
--- /dev/null
+++ b/theories/Algebra/Groups/FreeProduct.v
@@ -0,0 +1,721 @@
+Require Import Basics Types.
+Require Import Algebra.Groups.Group.
+Require Import Cubical.
+Require Import Colimits.Pushout.
+Require Import HIT.Coeq.
+
+Local Open Scope list_scope.
+Local Open Scope mc_scope.
+Local Open Scope mc_mult_scope.
+
+(** In this file we define the amalgamated free product of a span of group homomorphisms as a HIT. *)
+
+(** We wish to define the amalgamated free product of a span of group homomorphisms f : G -> H, g : G -> K as the following HIT:
+
+  HIT M(f,g)
+   | eta : list (H + K) -> M(f,g)
+   | mu_H : forall (x y : list (H + K)) (h1 h2 : H),
+      eta (x ++ [inl h1, inl h2] ++ y) = eta (x ++ [inl (h1 * h2)] ++ y)
+   | mu_K : forall (x y : list (H + K)) (k1 k2 : K),
+      eta (x ++ [inr k1, inr k2] ++ y) = eta (x ++ [inr (k1 * k2)] ++ y)
+   | tau : forall (x y : list (H + K)) (z : G),
+      eta (x ++ [inl (f z)] ++ y) = eta (x ++ [inr (g z)] ++ y)
+   | omega_H : forall (x y : list (H + K)),
+      eta (x ++ [inl mon_unit] ++ y) = eta (x ++ y)
+   | omega_K : forall (x y : list (H + K)),
+      eta (x ++ [inr mon_unit] ++ y) = eta (x ++ y).
+
+  We will build this HIT up sucessively out of coequalizers. *)
+
+
+(** Here are some operations on lists from the coq stdlib *)
+Section Fold_Left_Recursor.
+  Variables (A : Type) (B : Type).
+  Variable f : A -> B -> A.
+
+  Fixpoint fold_left (l : list B) (a0 : A) : A :=
+    match l with
+      | nil => a0
+      | cons b t => fold_left t (f a0 b)
+    end.
+
+  Lemma fold_left_app : forall (l l' : list B) (i : A),
+    fold_left (l ++ l') i = fold_left l' (fold_left l i).
+  Proof.
+    induction l; simpl; auto.
+  Qed.
+
+End Fold_Left_Recursor.
+
+Section Fold_Right_Recursor.
+  Variables (A : Type) (B : Type).
+  Variable f : B -> A -> A.
+
+  Fixpoint fold_right (a0 : A) (l:list B) : A :=
+    match l with
+      | nil => a0
+      | cons b t => f b (fold_right a0 t)
+    end.
+
+  Lemma fold_right_app : forall l l' i,
+    fold_right i (l++l') = fold_right (fold_right i l') l.
+  Proof.
+    induction l; simpl; auto.
+  Qed.
+
+End Fold_Right_Recursor.
+
+Section FreeProduct.
+
+  Context (G H K : Group)
+    (f : GroupHomomorphism G H) (g : GroupHomomorphism G K).
+
+  Definition Words : Type := list (H + K).
+
+  Notation "[ x ]" := (cons x nil).
+
+  Definition word_concat_w_nil (x : Words) : x ++ nil = x.
+  Proof.
+    induction x; trivial.
+    cbn; f_ap.
+  Defined.
+
+  Definition word_concat_w_ww (x y z : Words) : x ++ (y ++ z) = (x ++ y) ++ z.
+  Proof.
+    revert x z.
+    induction y; intros x z.
+    { f_ap; symmetry.
+      apply word_concat_w_nil. }
+    simpl; revert z y IHy.
+    induction x; trivial.
+    intros z y IHy.
+    simpl; f_ap.
+    apply IHx, IHy.
+  Defined.
+
+  Fixpoint word_inverse (x : Words) : Words.
+  Proof.
+    destruct x as [|x xs].
+    1: exact nil.
+    destruct x as [h|k].
+    + exact ((word_inverse xs) ++ [inl (- h)]).
+    + exact ((word_inverse xs) ++ [inr (- k)]).
+  Defined.
+
+  (** Inversion changes order of concatenation. *)
+  Definition word_inverse_ww (x y : Words)
+    : word_inverse (x ++ y) = word_inverse y ++ word_inverse x.
+  Proof.
+    induction x as [|x xs].
+    { symmetry.
+      apply word_concat_w_nil. }
+    simpl.
+    destruct x; refine (_ @ (word_concat_w_ww _ _ _)^); f_ap.
+  Defined.
+
+
+  (** There are five source types for the path constructors. We will construct this HIT as the colimit of five forks going into [Words]. We can bundle up this colimit as a single coequalizer. *)
+
+  (** Source types of path constructors *)
+  Definition pc1 : Type := Words * H * H * Words.
+  Definition pc2 : Type := Words * K * K * Words.
+  Definition pc3 : Type := Words * G * Words.
+  Definition pc4 : Type := Words * Words.
+  Definition pc5 : Type := Words * Words.
+
+  (** End points of the first path constructor *)
+  Definition m1 : pc1 -> Words.
+  Proof.
+    intros [[[x h1] h2] y].
+    exact (x ++ (inl h1 :: [inl h2]) ++ y).
+  Defined.
+
+  Definition m1' : pc1 -> Words.
+  Proof.
+    intros [[[x h1] h2] y].
+    exact (x ++ [inl (h1 * h2)] ++ y).
+  Defined.
+
+  (** End points of the second path construct *)
+  Definition m2 : pc2 -> Words.
+  Proof.
+    intros [[[x k1] k2] y].
+    exact (x ++ (inr k1 :: [inr k2]) ++ y).
+  Defined.
+
+  Definition m2' : pc2 -> Words.
+  Proof.
+    intros [[[x k1] k2] y].
+    exact (x ++ [inr (k1 * k2)] ++ y).
+  Defined.
+
+  (** End points of the third path constructor *)
+  Definition m3 : pc3 -> Words.
+  Proof.
+    intros [[x z] y].
+    exact (x ++ [inl (f z)] ++ y).
+  Defined.
+
+  Definition m3' : pc3 -> Words.
+  Proof.
+    intros [[x z] y].
+    exact (x ++ [inr (g z)] ++ y).
+  Defined.
+
+  (** End points of the fourth path constructor *)
+  Definition m4 : pc4 -> Words.
+  Proof.
+    intros [x y].
+    exact (x ++ [inl mon_unit] ++ y).
+  Defined.
+
+  Definition m4' : pc4 -> Words.
+  Proof.
+    intros [x y].
+    exact (x ++ y).
+  Defined.
+
+  (** End points of the fifth path constructor *)
+  Definition m5 : pc5 -> Words.
+  Proof.
+    intros [x y].
+    exact (x ++ [inr mon_unit] ++ y).
+  Defined.
+
+  Definition m5' : pc5 -> Words.
+  Proof.
+    intros [x y].
+    exact (x ++ y).
+  Defined.
+
+  (** We can then define maps going into words consisting of the corresponding endpoints of the path constructors. *)
+  Definition map : pc1 + pc2 + pc3 + pc4 + pc5 -> Words.
+  Proof.
+    intros [[[[x|x]|x]|x]|x].
+    + exact (m1 x).
+    + exact (m2 x).
+    + exact (m3 x).
+    + exact (m4 x).
+    + exact (m5 x).
+  Defined.
+
+  Definition map' : pc1 + pc2 + pc3 + pc4 + pc5 -> Words.
+  Proof.
+    intros [[[[x|x]|x]|x]|x].
+    + exact (m1' x).
+    + exact (m2' x).
+    + exact (m3' x).
+    + exact (m4' x).
+    + exact (m5' x).
+  Defined.
+
+  (** Finally we can define our type as the 0-truncation of the coequalizer of these maps *)
+  Definition M : Type := Tr 0 (Coeq map map').
+
+  (** We can define the constructors *)
+
+  Definition eta : Words -> M := tr o coeq.
+
+  Definition mu_H (x y : Words) (h1 h2 : H)
+    : eta (x ++ (cons (inl h1) [inl h2]) ++ y) = eta (x ++ [inl (h1 * h2)] ++ y).
+  Proof.
+    unfold eta.
+    apply path_Tr, tr.
+    exact (cglue (inl (inl (inl (inl (x,h1,h2,y)))))).
+  Defined.
+
+  Definition mu_K (x y : Words) (k1 k2 : K)
+    : eta (x ++ (cons (inr k1) [inr k2]) ++ y) = eta (x ++ [inr (k1 * k2)] ++ y).
+  Proof.
+    unfold eta.
+    apply path_Tr, tr.
+    exact (cglue (inl (inl (inl (inr (x,k1,k2,y)))))).
+  Defined.
+
+  Definition tau (x y : Words) (z : G)
+    : eta (x ++ [inl (f z)] ++ y) = eta (x ++ [inr (g z)] ++ y).
+  Proof.
+    unfold eta.
+    apply path_Tr, tr.
+    exact (cglue (inl (inl (inr (x,z,y))))).
+  Defined.
+
+  Definition omega_H (x y : Words)
+    : eta (x ++ [inl mon_unit] ++ y) = eta (x ++ y).
+  Proof.
+    unfold eta.
+    apply path_Tr, tr.
+    exact (cglue (inl (inr (x,y)))).
+  Defined.
+
+  Definition omega_K (x y : Words)
+    : eta (x ++ [inr mon_unit] ++ y) = eta (x ++ y).
+  Proof.
+    unfold eta.
+    apply path_Tr, tr.
+    exact (cglue (inr (x,y))).
+  Defined.
+
+  (** Now we can derive the dependent eliminator *)
+
+  Definition M_ind (P : M -> Type) `{forall x, IsHSet (P x)}
+    (e : forall w, P (eta w))
+    (mh : forall (x y : Words) (h1 h2 : H),
+      DPath P (mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y)) (e (x ++ [inl (h1 * h2)] ++ y)))
+    (mk : forall (x y : Words) (k1 k2 : K),
+      DPath P (mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y)) (e (x ++ [inr (k1 * k2)] ++ y)))
+    (t : forall (x y : Words) (z : G),
+      DPath P (tau x y z) (e (x ++ [inl (f z)] ++ y)) (e (x ++ [inr (g z)] ++ y)))
+    (oh : forall (x y : Words),
+      DPath P (omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y)))
+    (ok : forall (x y : Words),
+      DPath P (omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y)))
+    : forall x, P x.
+  Proof.
+    snrapply Trunc_ind; [exact _|].
+    snrapply Coeq_ind.
+    1: exact e.
+    intro a.
+    nrapply dp_path_transport^-1%equiv.
+    destruct a as [ [ [ [a | a ] | a] | a ] | a ].
+    + destruct a as [[[x h1] h2] y].
+      apply dp_compose.
+      exact (mh x y h1 h2).
+    + destruct a as [[[x k1] k2] y].
+      apply dp_compose.
+      exact (mk x y k1 k2).
+    + destruct a as [[x z] y].
+      apply dp_compose.
+      exact (t x y z).
+    + destruct a as [x y].
+      apply dp_compose.
+      exact (oh x y).
+    + destruct a as [x y].
+      apply dp_compose.
+      exact (ok x y).
+  Defined.
+
+  Definition M_ind_hprop (P : M -> Type) `{forall x, IsHProp (P x)}
+    (e : forall w, P (eta w))
+    : forall x, P x.
+  Proof.
+    srapply M_ind.
+    1: exact e.
+    all: intros; apply dp_path_transport, path_ishprop.
+  Defined.
+
+  (** From which we can derive the non-dependent eliminator / recursion principle *)
+  Definition M_rec (P : Type) `{IsHSet P} (e : Words -> P)
+    (eh : forall (x y : Words) (h1 h2 : H),
+      e (x ++ (cons (inl h1) [inl h2]) ++ y) = e (x ++ [inl (h1 * h2)] ++ y))
+    (ek : forall (x y : Words) (k1 k2 : K),
+      e (x ++ (cons (inr k1) [inr k2]) ++ y) = e (x ++ [inr (k1 * k2)] ++ y))
+    (t : forall (x y : Words) (z : G),
+      e (x ++ [inl (f z)] ++ y) = e (x ++ [inr (g z)] ++ y))
+    (oh : forall (x y : Words), e (x ++ [inl mon_unit] ++ y) = e (x ++ y))
+    (ok : forall (x y : Words), e (x ++ [inr mon_unit] ++ y) = e (x ++ y))
+    : M -> P.
+  Proof.
+    snrapply M_ind.
+    1: exact _.
+    1: exact e.
+    all: intros; apply dp_const.
+    1: apply eh.
+    1: apply ek.
+    1: apply t.
+    1: apply oh.
+    apply ok.
+  Defined.
+
+  (** Now for the group structure *)
+
+  (** The group operation is concatenation of the underlying list. Most of the work is spent showing that it respects the path constructors. *)
+  Global Instance sgop_m : SgOp M.
+  Proof.
+    intros x y; revert x.
+    srapply M_rec; intros x; revert y.
+    { srapply M_rec; intros y.
+      1: exact (eta (x ++ y)).
+      { intros z h1 h2.
+        refine (ap eta _ @ _ @ ap eta _^).
+        1,3: apply word_concat_w_ww.
+        rapply mu_H. }
+      { intros z k1 k2.
+        refine (ap eta _ @ _ @ ap eta _^).
+        1,3: apply word_concat_w_ww.
+        rapply mu_K. }
+      { intros w z.
+        refine (ap eta _ @ _ @ ap eta _^).
+        1,3: apply word_concat_w_ww.
+        apply tau. }
+      { intros z.
+        refine (ap eta _ @ _ @ ap eta _^).
+        1,3: apply word_concat_w_ww.
+        apply omega_H. }
+      { intros z.
+        refine (ap eta _ @ _ @ ap eta _^).
+        1,3: apply word_concat_w_ww.
+        apply omega_K. } }
+    { intros r y h1 h2; revert r.
+      rapply M_ind_hprop; cbn.
+      intros z;
+      change (eta ((x ++ ((inl h1 :: [inl h2]) ++ y)) ++ z)
+        = eta ((x ++ [inl (h1 * h2)] ++ y) ++ z)).
+      refine (ap eta _^ @ _ @ ap eta _).
+      1,3: apply word_concat_w_ww.
+      refine (ap eta (ap (app x) _)^ @ _ @ ap eta (ap (app x) _)).
+      1,3: apply word_concat_w_ww.
+      apply mu_H. }
+    { intros r y k1 k2; revert r.
+      rapply M_ind_hprop; cbn.
+      intros z;
+      change (eta ((x ++ ((inr k1 :: [inr k2]) ++ y)) ++ z)
+        = eta ((x ++ [inr (k1 * k2)] ++ y) ++ z)).
+      refine (ap eta _^ @ _ @ ap eta _).
+      1,3: apply word_concat_w_ww.
+      refine (ap eta (ap (app x) _)^ @ _ @ ap eta (ap (app x) _)).
+      1,3: apply word_concat_w_ww.
+      apply mu_K. }
+    { intros r y z; revert r.
+      rapply M_ind_hprop; cbn.
+      intros w;
+      change (eta ((x ++ [inl (f z)] ++ y) ++ w)
+        = eta ((x ++ [inr (g z)] ++ y) ++ w)).
+      refine (ap eta _^ @ _ @ ap eta _).
+      1,3: apply word_concat_w_ww.
+      refine (ap eta (ap (app x) _)^ @ _ @ ap eta (ap (app x) _)).
+      1,3: apply word_concat_w_ww.
+      apply tau. }
+    { intros r z; revert r.
+      rapply M_ind_hprop; cbn.
+      intros w;
+      change (eta ((x ++ [inl mon_unit] ++ z) ++ w) = eta ((x ++ z) ++ w)).
+      refine (ap eta _^ @ _ @ ap eta _).
+      1,3: apply word_concat_w_ww.
+      refine (ap eta (ap (app x) _)^ @ _).
+      1: apply word_concat_w_ww.
+      apply omega_H. }
+    { intros r z; revert r.
+      rapply M_ind_hprop; cbn.
+      intros w;
+      change (eta ((x ++ [inr mon_unit] ++ z) ++ w) = eta ((x ++ z) ++ w)).
+      refine (ap eta _^ @ _ @ ap eta _).
+      1,3: apply word_concat_w_ww.
+      refine (ap eta (ap (app x) _)^ @ _).
+      1: apply word_concat_w_ww.
+      apply omega_K. }
+  Defined.
+
+  (** The identity element is the empty list *)
+  Global Instance monunit_m : MonUnit M.
+  Proof.
+    exact (eta nil).
+  Defined.
+
+  Global Instance negate_m : Negate M.
+  Proof.
+    srapply M_rec.
+    { intros w.
+      exact (eta (word_inverse w)). }
+    { hnf; intros x y h1 h2.
+      refine (ap eta _ @ _ @ ap eta _^).
+      1,3: refine (word_inverse_ww _ _ @ ap (fun s => s ++ _) _).
+      1: apply word_inverse_ww.
+      { refine (word_inverse_ww _ _ @ _).
+        apply ap; simpl.
+        rapply (ap (fun s => [s])).
+        apply ap.
+        apply negate_sg_op. }
+      simpl.
+      refine (ap eta _^ @ _ @ ap eta _).
+      1,3: apply word_concat_w_ww.
+      apply mu_H. }
+    { hnf; intros x y k1 k2.
+      refine (ap eta _ @ _ @ ap eta _^).
+      1,3: refine (word_inverse_ww _ _ @ ap (fun s => s ++ _) _).
+      1: apply word_inverse_ww.
+      { refine (word_inverse_ww _ _ @ _).
+        apply ap; simpl.
+        rapply (ap (fun s => [s])).
+        apply ap.
+        apply negate_sg_op. }
+      simpl.
+      refine (ap eta _^ @ _ @ ap eta _).
+      1,3: apply word_concat_w_ww.
+      apply mu_K. }
+    { hnf; intros x y z.
+      refine (ap eta _ @ _ @ ap eta _^).
+      1,3: refine (word_inverse_ww _ _ @ ap (fun s => s ++ _) _).
+      1,2: cbn; refine (ap _ _).
+      1,2: rapply (ap (fun s => [s])).
+      1,2: apply ap.
+      1,2: symmetry; apply grp_homo_inv.
+      refine (ap eta _^ @ _ @ ap eta _).
+      1,3: apply word_concat_w_ww.
+      apply tau. }
+    { hnf; intros x z.
+      refine (ap eta _ @ _ @ ap eta _^).
+      1,3: apply word_inverse_ww.
+      refine (ap eta _ @ _).
+      { refine (ap (fun s => s ++ _) _).
+        apply word_inverse_ww. }
+      refine (ap eta _^ @ _).
+      1: apply word_concat_w_ww.
+      simpl.
+      rewrite negate_mon_unit.
+      apply omega_H. }
+    { hnf; intros x z.
+      refine (ap eta _ @ _ @ ap eta _^).
+      1,3: apply word_inverse_ww.
+      refine (ap eta _ @ _).
+      { refine (ap (fun s => s ++ _) _).
+        apply word_inverse_ww. }
+      refine (ap eta _^ @ _).
+      1: apply word_concat_w_ww.
+      simpl.
+      rewrite negate_mon_unit.
+      apply omega_K. }
+  Defined.
+
+  Global Instance associative_sgop_m : Associative sg_op.
+  Proof.
+    intros x y.
+    rapply M_ind_hprop; intro z; revert y.
+    rapply M_ind_hprop; intro y; revert x.
+    rapply M_ind_hprop; intro x.
+    cbn; nrapply (ap eta).
+    rapply word_concat_w_ww.
+  Defined.
+
+  Global Instance leftidentity_sgop_m : LeftIdentity sg_op mon_unit.
+  Proof.
+    rapply M_ind_hprop; intro x.
+    reflexivity.
+  Defined.
+
+  Global Instance rightidentity_sgop_m : RightIdentity sg_op mon_unit.
+  Proof.
+    rapply M_ind_hprop; intro x.
+    cbn; nrapply (ap eta).
+    apply word_concat_w_nil.
+  Defined.
+
+  Lemma eta_word_concat_Vw (x : Words) : eta (word_inverse x ++ x) = mon_unit.
+  Proof.
+    induction x as [|x xs].
+    1: reflexivity.
+    destruct x as [h|k].
+    + change (eta (word_inverse ([inl h] ++ xs) ++ [inl h] ++ xs) = mon_unit).
+      rewrite word_inverse_ww.
+      rewrite <- word_concat_w_ww.
+      refine (mu_H _ _ _ _ @ _).
+      rewrite left_inverse.
+      rewrite omega_H.
+      apply IHxs.
+    + change (eta (word_inverse ([inr k] ++ xs) ++ [inr k] ++ xs) = mon_unit).
+      rewrite word_inverse_ww.
+      rewrite <- word_concat_w_ww.
+      refine (mu_K _ _ _ _ @ _).
+      rewrite left_inverse.
+      rewrite omega_K.
+      apply IHxs.
+  Defined.
+
+  Lemma eta_word_concat_wV (x : Words) : eta (x ++ word_inverse x) = mon_unit.
+  Proof.
+    induction x as [|x xs].
+    1: reflexivity.
+    destruct x as [h|k].
+    + cbn.
+      rewrite word_concat_w_ww.
+      change (eta ([inl h]) * eta ((xs ++ word_inverse xs)) * eta ([inl (- h)]) = mon_unit).
+      rewrite IHxs.
+      rewrite rightidentity_sgop_m.
+      cbn.
+      rewrite <- (word_concat_w_nil (cons _ _)).
+      change (eta (([inl h] ++ [inl (- h)]) ++ nil) = mon_unit).
+      rewrite <- word_concat_w_ww.
+      change (eta (nil ++ [inl h] ++ [inl (- h)] ++ nil) = mon_unit).
+      refine (mu_H _ _ _ _ @ _).
+      refine (_ @ _).
+      { apply ap, ap.
+        rapply (ap (fun x => x ++ _)).
+        rapply (ap (fun x => [x])).
+        apply ap.
+        apply right_inverse. }
+      apply omega_H.
+    +  cbn.
+      rewrite word_concat_w_ww.
+      change (eta ([inr k]) * eta ((xs ++ word_inverse xs)) * eta ([inr (-k)]) = mon_unit).
+      rewrite IHxs.
+      rewrite rightidentity_sgop_m.
+      cbn.
+      rewrite <- (word_concat_w_nil (cons _ _)).
+      change (eta (([inr k] ++ [inr (- k)]) ++ nil) = mon_unit).
+      rewrite <- word_concat_w_ww.
+      change (eta (nil ++ [inr k] ++ [inr (- k)] ++ nil) = mon_unit).
+      refine (mu_K _ _ _ _ @ _).
+      refine (_ @ _).
+      { apply ap, ap.
+        rapply (ap (fun x => x ++ _)).
+        rapply (ap (fun x => [x])).
+        apply ap.
+        apply right_inverse. }
+      apply omega_K.
+  Defined.
+
+  Global Instance leftinverse_sgop_m : LeftInverse sg_op negate mon_unit.
+  Proof.
+    rapply M_ind_hprop; intro x.
+    apply eta_word_concat_Vw.
+  Defined.
+
+  Global Instance rightinverse_sgop_m : RightInverse sg_op negate mon_unit.
+  Proof.
+    rapply M_ind_hprop; intro x.
+    apply eta_word_concat_wV.
+  Defined.
+
+  Definition AmalgamatedFreeProduct : Group.
+  Proof.
+    snrapply (Build_Group M); repeat split; exact _.
+  Defined.
+
+  (** Using foldr. It's important that we use foldr as foldl is near impossible to reason about. *)
+  Definition AmalgamatedFreeProduct_rec' (X : Group)
+    (h : GroupHomomorphism H X) (k : GroupHomomorphism K X)
+    (p : h o f == k o g)
+    : AmalgamatedFreeProduct -> X.
+  Proof.
+    srapply M_rec.
+    { intro w.
+      refine (fold_right _ _ _ _ w).
+      { intros [l|r] x.
+        + exact (h l * x).
+        + exact (k r * x). }
+      exact mon_unit. }
+    { intros x y h1 h2; hnf.
+      rewrite ?fold_right_app.
+      f_ap.
+      simpl.
+      rewrite simple_associativity.
+      f_ap.
+      symmetry.
+      exact (grp_homo_op h h1 h2). }
+    { intros x y k1 k2; hnf.
+      rewrite ?fold_right_app.
+      f_ap.
+      simpl.
+      rewrite simple_associativity.
+      f_ap.
+      symmetry.
+      exact (grp_homo_op k k1 k2). }
+    { intros x y z; hnf.
+      rewrite ?fold_right_app.
+      f_ap; simpl; f_ap. }
+    { intros x y; hnf.
+      rewrite ?fold_right_app.
+      f_ap. simpl. rewrite grp_homo_unit.
+      rapply left_identity. }
+    { intros x y; hnf.
+      rewrite ?fold_right_app.
+      f_ap. simpl. rewrite grp_homo_unit.
+      rapply left_identity. }
+  Defined.
+
+  Global Instance issemigrouppreserving_AmalgamatedFreeProduct_rec'
+    (X : Group) (h : GroupHomomorphism H X) (k : GroupHomomorphism K X)
+    (p : h o f == k o g)
+    : IsSemiGroupPreserving (AmalgamatedFreeProduct_rec' X h k p).
+  Proof.
+    intros x; srapply M_ind_hprop; intro y; revert x;
+    srapply M_ind_hprop; intro x; simpl.
+    rewrite fold_right_app.
+    set (s := (fold_right X (H + K)
+     (fun X0 : H + K => match X0 with
+                        | inl l => fun x0 : X => h l * x0
+                        | inr r => fun x0 : X => k r * x0
+                        end) mon_unit y)).
+    induction x as [|a x].
+    1: symmetry; apply left_identity.
+    simpl.
+    rewrite IHx.
+    destruct a; apply simple_associativity.
+  Qed.
+
+  Definition AmalgamatedFreeProduct_rec (X : Group)
+    (h : GroupHomomorphism H X) (k : GroupHomomorphism K X)
+    (p : h o f == k o g)
+    : GroupHomomorphism AmalgamatedFreeProduct X.
+  Proof.
+    snrapply Build_GroupHomomorphism.
+    1: srapply (AmalgamatedFreeProduct_rec' X h k p).
+    exact _.
+  Defined.
+
+  Definition amal_inl : GroupHomomorphism H AmalgamatedFreeProduct.
+  Proof.
+    snrapply Build_GroupHomomorphism.
+    { intro x.
+      exact (eta [inl x]). }
+    intros x y.
+    rewrite <- (word_concat_w_nil [inl (x * y)]).
+    rewrite <- (mu_H nil nil x y).
+    rewrite word_concat_w_nil.
+    reflexivity.
+  Defined.
+
+  Definition amal_inr : GroupHomomorphism K AmalgamatedFreeProduct.
+  Proof.
+    snrapply Build_GroupHomomorphism.
+    { intro x.
+      exact (eta [inr x]). }
+    intros x y.
+    rewrite <- (word_concat_w_nil [inr (x * y)]).
+    rewrite <- (mu_K nil nil x y).
+    rewrite word_concat_w_nil.
+    reflexivity.
+  Defined.
+
+  Theorem equiv_amalgamatedfreeproduct_rec `{Funext} (X : Group)
+    : {h : GroupHomomorphism H X & {k : GroupHomomorphism K X & h o f == k o g }}
+      <~> GroupHomomorphism AmalgamatedFreeProduct X.
+  Proof.
+    snrapply equiv_adjointify.
+    1: intros [h [k p]]; exact (AmalgamatedFreeProduct_rec X h k p).
+    { intros r.
+      exists (grp_homo_compose r amal_inl).
+      exists (grp_homo_compose r amal_inr).
+      intro x.
+      apply (ap r).
+      simpl.
+      rewrite <- (word_concat_w_nil [inl (f x)]).
+      rewrite <- (word_concat_w_nil [inr (g x)]).
+      apply (tau nil nil x). }
+    { intros r.
+      apply equiv_path_grouphomomorphism.
+      srapply M_ind_hprop.
+      intro x.
+      induction x as [|a x].
+      1: symmetry; apply (grp_homo_unit r).
+      simpl in *.
+      rewrite IHx.
+      destruct a; symmetry;
+      rapply (grp_homo_op r (eta [_]) (eta x)). }
+    intro hkp.
+    simpl.
+    rapply (equiv_ap' (equiv_sigma_prod
+      (fun hk : GroupHomomorphism H X * GroupHomomorphism K X
+        => fst hk o f == snd hk o g)) _ _)^-1%equiv.
+    rapply path_sigma_hprop.
+    destruct hkp as [h [k p]].
+    apply path_prod; cbn;
+    apply equiv_path_grouphomomorphism;
+    intro; cbn; apply right_identity.
+  Defined.
+
+End FreeProduct.
+
+
+
+
-- 
2.29.1


From 30818c201b78e4cbbd5e4777e4602b21ee45f2c1 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 6 Aug 2020 13:26:12 +0100
Subject: [PATCH 27/76] group coequalizers

---
 _CoqProject                         |  1 +
 theories/Algebra/Groups/GroupCoeq.v | 15 +++++++++++++++
 2 files changed, 16 insertions(+)
 create mode 100644 theories/Algebra/Groups/GroupCoeq.v

diff --git a/_CoqProject b/_CoqProject
index 3270153e82..a1c77c1b20 100644
--- a/_CoqProject
+++ b/_CoqProject
@@ -349,6 +349,7 @@ theories/Algebra/Groups/Image.v
 theories/Algebra/Groups/Kernel.v
 theories/Algebra/Groups/GrpPullback.v
 theories/Algebra/Groups/FreeProduct.v
+theories/Algebra/Groups/GroupCoeq.v
 theories/Algebra/Groups/FreeGroup.v
 
 theories/Algebra/Groups/FreeGroup/ListQuotient.v
diff --git a/theories/Algebra/Groups/GroupCoeq.v b/theories/Algebra/Groups/GroupCoeq.v
new file mode 100644
index 0000000000..aa84b807c9
--- /dev/null
+++ b/theories/Algebra/Groups/GroupCoeq.v
@@ -0,0 +1,15 @@
+Require Import Basics Types.
+Require Import Algebra.Groups.Group.
+Require Import HIT.Coeq.
+Require Import Algebra.Groups.FreeProduct.
+
+Local Open Scope mc_scope.
+Local Open Scope mc_mult_scope.
+
+(** Coequalizers of group homomorphisms *)
+
+
+Definition GroupCoeq {A B : Group} (f g : GroupHomomorphism A B) : Group
+  := AmalgamatedFreeProduct A B B f g.
+
+
-- 
2.29.1


From f4a8ca75b320dbbf020070eaade5c32ece949515 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 6 Aug 2020 13:26:26 +0100
Subject: [PATCH 28/76] presentations of groups

---
 _CoqProject                            |  2 +
 theories/Algebra/Groups/Presentation.v | 72 ++++++++++++++++++++++++++
 2 files changed, 74 insertions(+)
 create mode 100644 theories/Algebra/Groups/Presentation.v

diff --git a/_CoqProject b/_CoqProject
index a1c77c1b20..c0392fdb64 100644
--- a/_CoqProject
+++ b/_CoqProject
@@ -350,6 +350,8 @@ theories/Algebra/Groups/Kernel.v
 theories/Algebra/Groups/GrpPullback.v
 theories/Algebra/Groups/FreeProduct.v
 theories/Algebra/Groups/GroupCoeq.v
+theories/Algebra/Groups/Presentation.v
+
 theories/Algebra/Groups/FreeGroup.v
 
 theories/Algebra/Groups/FreeGroup/ListQuotient.v
diff --git a/theories/Algebra/Groups/Presentation.v b/theories/Algebra/Groups/Presentation.v
new file mode 100644
index 0000000000..3cfb9d55e5
--- /dev/null
+++ b/theories/Algebra/Groups/Presentation.v
@@ -0,0 +1,72 @@
+Require Import Basics Types.
+Require Import Algebra.Groups.Group.
+Require Import Algebra.Groups.FreeGroup.
+Require Import Algebra.Groups.GroupCoeq.
+Require Import Spaces.Finite.
+
+(** In this file we develop presentations of groups. *)
+
+(** The data of a group presentation *)
+Record GroupPresentation := {
+  (** We have a type of generators *)
+  gp_generators : Type ;
+  (** An indexing type for relators *)
+  gp_rel_index : Type ;
+  (** The relators are picked out amongst elements of the free group on the generators. *)
+  gp_relators : gp_rel_index -> FreeGroup gp_generators;
+}.
+
+(** Note: A relator is a relation in the form of "f(x) = 1", any relation "f(x) = g(x)" can become a relator "f(x)g(x)^-1 = 1". *)
+
+(** Given the data of a group presentation we can construct the group. This is sometimes called the presented group. *)
+Definition group_gp : GroupPresentation -> Group.
+Proof.
+  intros [X I R].
+  exact (GroupCoeq
+    (FreeGroup_rec I (FreeGroup X) R)
+    (FreeGroup_rec I (FreeGroup X) (fun x => mon_unit))).
+Defined.
+
+(** A group [G] has a presentation if there exists a group presentation whose presented group is isomorphic to [G]. *)
+Class HasPresentation (G : Group) := {
+  presentation : GroupPresentation;
+  grp_iso_presentation : GroupIsomorphism (group_gp presentation) G;
+}.
+
+Coercion presentation : HasPresentation >-> GroupPresentation.
+
+(** Here are a few finiteness properties of group presentations. *)
+
+(** A group presentation is finitely generated if its generating set is finite. *)
+Class FinitelyGeneratedPresentation (P : GroupPresentation)
+  := finite_gp_generators : Finite (gp_generators P).
+
+(** A group presentation is finitely related if its relators indexing set is finite. *)
+Class FinitelyRelatedPresentation (P : GroupPresentation)
+  := finite_gp_relators : Finite (gp_rel_index P).
+
+(** A group presentation is a finite presentation if it is finitely generated and related. *)
+Class FinitePresentation (P : GroupPresentation) := {
+  fp_generators : FinitelyGeneratedPresentation P;
+  fp_relators : FinitelyRelatedPresentation P;
+}.
+
+(** These directly translate into properties of groups. *)
+
+(** A group is finitely generated if it has a finitely generated presentation. *)
+Class IsFinitelyGenerated (G : Group) := {
+  fg_presentation : HasPresentation G;
+  fg_presentation_fg : FinitelyGeneratedPresentation fg_presentation;
+}.
+
+(** A group is finitely related if it has a finitely related presentation. *)
+Class IsFinitelyRelated (G : Group) := {
+  fr_presentation : HasPresentation G;
+  fr_presentation_fr : FinitelyRelatedPresentation fr_presentation;
+}.
+
+Class IsFinitelyPresented (G : Group) := {
+  fp_presentation : HasPresentation G;
+  fp_presentation_fp : FinitePresentation fp_presentation;
+}.
+
-- 
2.29.1


From 226cfd725cf41fad94e9813c5c4922ebae5bf249 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Sat, 8 Aug 2020 18:44:03 +0100
Subject: [PATCH 29/76] free product of groups (coproduct in Grp)

---
 theories/Algebra/Groups/FreeProduct.v | 33 ++++++++++++++++++++++++---
 1 file changed, 30 insertions(+), 3 deletions(-)

diff --git a/theories/Algebra/Groups/FreeProduct.v b/theories/Algebra/Groups/FreeProduct.v
index cd73e3e77e..6b83c9ee01 100644
--- a/theories/Algebra/Groups/FreeProduct.v
+++ b/theories/Algebra/Groups/FreeProduct.v
@@ -716,6 +716,33 @@ Section FreeProduct.
 
 End FreeProduct.
 
-
-
-
+Definition FreeProduct (G H : Group) : Group
+  := AmalgamatedFreeProduct grp_trivial G H (grp_trivial_rec _) (grp_trivial_rec _).
+
+Definition freeproduct_inl {G H : Group} : GroupHomomorphism G (FreeProduct G H)
+  := amal_inl _ _ _ _ _.
+
+Definition freeproduct_inr {G H : Group} : GroupHomomorphism H (FreeProduct G H)
+  := amal_inr _ _ _ _ _.
+
+Definition FreeProduct_rec (G H K : Group)
+  (f : GroupHomomorphism G K) (g : GroupHomomorphism H K)
+  : GroupHomomorphism (FreeProduct G H) K.
+Proof.
+  snrapply (AmalgamatedFreeProduct_rec _ _ _ _ _ _ f g).
+  intros [].
+  refine (grp_homo_unit _ @ (grp_homo_unit _)^).
+Defined.
+
+Definition equiv_freeproduct_rec `{funext : Funext} (G H K : Group)
+  : (GroupHomomorphism G K) * (GroupHomomorphism H K)
+  <~> GroupHomomorphism (FreeProduct G H) K.
+Proof.
+  refine (equiv_amalgamatedfreeproduct_rec _ _ _ _ _  K oE _^-1).
+  refine (equiv_sigma_prod0 _ _ oE equiv_functor_sigma_id (fun _ => equiv_sigma_contr _)).
+  intros f.
+  rapply contr_forall.
+  intros []; apply contr_inhab_prop.
+  apply tr.
+  refine (grp_homo_unit _ @ (grp_homo_unit _)^).
+Defined.
-- 
2.29.1


From 8ad836a9aa9965b59cdc65c30a4750a5be7c202b Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Sat, 8 Aug 2020 18:44:16 +0100
Subject: [PATCH 30/76] universal property of coequalizer in Grp

---
 theories/Algebra/Groups/GroupCoeq.v | 55 ++++++++++++++++++++++++++---
 1 file changed, 51 insertions(+), 4 deletions(-)

diff --git a/theories/Algebra/Groups/GroupCoeq.v b/theories/Algebra/Groups/GroupCoeq.v
index aa84b807c9..5fee273869 100644
--- a/theories/Algebra/Groups/GroupCoeq.v
+++ b/theories/Algebra/Groups/GroupCoeq.v
@@ -8,8 +8,55 @@ Local Open Scope mc_mult_scope.
 
 (** Coequalizers of group homomorphisms *)
 
+Definition GroupCoeq {A B : Group} (f g : GroupHomomorphism A B) : Group.
+Proof.
+  rapply (AmalgamatedFreeProduct (FreeProduct A A) A B).
+  1,2: apply FreeProduct_rec.
+  + exact grp_homo_id.
+  + exact grp_homo_id.
+  + exact f.
+  + exact g.
+Defined.
 
-Definition GroupCoeq {A B : Group} (f g : GroupHomomorphism A B) : Group
-  := AmalgamatedFreeProduct A B B f g.
-
-
+Definition equiv_groupcoeq_rec `{Funext} {A B C : Group} (f g : GroupHomomorphism A B)
+  : {h : GroupHomomorphism B C & h o f == h o g} <~> GroupHomomorphism (GroupCoeq f g) C.
+Proof.
+  refine (equiv_amalgamatedfreeproduct_rec _ _ _ _ _ _ oE _).
+  refine (equiv_sigma_symm _ oE _).
+  apply equiv_functor_sigma_id.
+  intros h.
+  snrapply equiv_adjointify.
+  { intros p.
+    exists (grp_homo_compose h f).
+    hnf; intro x.
+    refine (p _ @ _).
+    revert x.
+    rapply Trunc_ind.
+    srapply Coeq_ind.
+    2: intros; apply path_ishprop.
+    intros w. hnf.
+    induction w.
+    1: apply ap, grp_homo_unit.
+    simpl.
+    destruct a as [a|a].
+    1,2: refine (ap _ (grp_homo_op _ _ _) @ _).
+    1,2: refine (grp_homo_op _ _ _ @ _ @ (grp_homo_op _ _ _)^); f_ap.
+    symmetry.
+    apply p. }
+  { intros [k p] x.
+    pose proof (q1 := p (freeproduct_inl x)).
+    pose proof (q2 := p (freeproduct_inr x)).
+    simpl in q1, q2.
+    rewrite 2 right_identity in q1, q2.
+    refine (q1^ @ q2). }
+  { hnf. intros [k p].
+    apply path_sigma_hprop.
+    simpl.
+    apply equiv_path_grouphomomorphism.
+    intro y.
+    pose (q1 := p (freeproduct_inl y)).
+    simpl in q1.
+    rewrite 2 right_identity in q1.
+    exact q1^. }
+  hnf; intros; apply path_ishprop.
+Defined.
-- 
2.29.1


From 258461ffe18dd47820c4068b460e92883bd328ee Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Sat, 8 Aug 2020 18:44:32 +0100
Subject: [PATCH 31/76] maps in and out of trivial groups

---
 theories/Algebra/Groups/Group.v | 28 +++++++++++++++++++---------
 1 file changed, 19 insertions(+), 9 deletions(-)

diff --git a/theories/Algebra/Groups/Group.v b/theories/Algebra/Groups/Group.v
index 27394893ef..d6b4cec293 100644
--- a/theories/Algebra/Groups/Group.v
+++ b/theories/Algebra/Groups/Group.v
@@ -357,6 +357,22 @@ Proof.
   repeat split; try exact _; by intros [].
 Defined.
 
+(** Map out of trivial group *)
+Definition grp_trivial_rec (G : Group) : GroupHomomorphism grp_trivial G.
+Proof.
+  snrapply Build_GroupHomomorphism.
+  1: exact (fun _ => group_unit).
+  intros ??; symmetry; apply left_identity.
+Defined.
+
+(** Map into trivial group *)
+Definition grp_trivial_corec (G : Group) : GroupHomomorphism G grp_trivial.
+Proof.
+  snrapply Build_GroupHomomorphism.
+  1: exact (fun _ => tt).
+  intros ??; symmetry; apply left_identity.
+Defined.
+
 (** * Direct product of group *)
 
 Definition grp_prod : Group -> Group -> Group.
@@ -498,10 +514,7 @@ Defined.
 Global Instance isinitial_grp_trivial : IsInitial grp_trivial.
 Proof.
   intro G.
-  snrefine (_;_).
-  { snrapply Build_GroupHomomorphism.
-    1: exact (fun _ => group_unit).
-    intros ??; symmetry; apply left_identity. }
+  exists (grp_trivial_rec _).
   intros g [].
   apply (grp_homo_unit g).
 Defined.
@@ -510,7 +523,7 @@ Global Instance contr_grp_homo_trivial_source `{Funext} G
   : Contr (GroupHomomorphism grp_trivial G).
 Proof.
   snrapply Build_Contr.
-  1: exact (pr1 (isinitial_grp_trivial _)).
+  1: exact (grp_trivial_rec _).
   intros g.
   rapply equiv_path_grouphomomorphism.
   intros [].
@@ -521,10 +534,7 @@ Defined.
 Global Instance isterminal_grp_trivial : IsTerminal grp_trivial.
 Proof.
   intro G.
-  snrefine (_;_).
-  { snrapply Build_GroupHomomorphism.
-    1: exact (fun _ => tt).
-    intros ??; symmetry; apply left_identity. }
+  exists (grp_trivial_corec _).
   intros g x.
   apply path_contr.
 Defined.
-- 
2.29.1


From 6f09133bcdd0e7dd71b3ede920bbfbd967333074 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Sat, 8 Aug 2020 18:44:40 +0100
Subject: [PATCH 32/76] fundamental theorem of group presentations

---
 theories/Algebra/Groups/Presentation.v | 44 ++++++++++++++++++++++++++
 1 file changed, 44 insertions(+)

diff --git a/theories/Algebra/Groups/Presentation.v b/theories/Algebra/Groups/Presentation.v
index 3cfb9d55e5..b9a004ece5 100644
--- a/theories/Algebra/Groups/Presentation.v
+++ b/theories/Algebra/Groups/Presentation.v
@@ -3,6 +3,7 @@ Require Import Algebra.Groups.Group.
 Require Import Algebra.Groups.FreeGroup.
 Require Import Algebra.Groups.GroupCoeq.
 Require Import Spaces.Finite.
+Require Import WildCat.
 
 (** In this file we develop presentations of groups. *)
 
@@ -70,3 +71,46 @@ Class IsFinitelyPresented (G : Group) := {
   fp_presentation_fp : FinitePresentation fp_presentation;
 }.
 
+(** ** Fundamental theorem of presentations of groups *)
+
+(** A group homomorphism from a presented group is determined with how the underlying map acts on generators subject to the condition that relators are sent to the unit. *)
+Theorem grp_pres_rec {funext : Funext} (G : Group) (P : HasPresentation G) (H : Group)
+  : {f : gp_generators P -> H & forall r,
+      FreeGroup_rec _ _ f (gp_relators P r) = group_unit}
+    <~> GroupHomomorphism G H.
+Proof.
+  refine ((equiv_precompose_cat_equiv grp_iso_presentation)^-1 oE _).
+  refine (equiv_groupcoeq_rec _ _ oE _).
+  srefine (equiv_functor_sigma_pb _^-1 oE _).
+  2: apply equiv_freegroup_rec.
+  apply equiv_functor_sigma_id.
+  intros f.
+  srapply equiv_iff_hprop.
+  { intros p.
+    hnf.
+    rapply Trunc_ind.
+    srapply Coeq.Coeq.Coeq_ind.
+    2: intros; apply path_ishprop.
+    intros w; hnf.
+    induction w.
+    1: reflexivity.
+    simpl.
+    refine (_ @ _ @ _^).
+    1,3: exact (grp_homo_op (FreeGroup_rec _ _ _) _ _).
+    f_ap.
+    destruct a.
+    1: refine (p _ @ (grp_homo_unit _)^).
+    refine (grp_homo_inv _ _ @ ap _ _ @ (grp_homo_inv _ _)^).
+    refine (p _ @ (grp_homo_unit _)^). }
+  intros p r.
+  hnf in p.
+  pose (p' := p o freegroup_eta _).
+  clearbody p'; clear p.
+  specialize (p' (word_sing _ (inl r))).
+  refine (_ @ p').
+  clear p'.
+  symmetry.
+  refine (grp_homo_op _ _ _ @ _).
+  refine (_ @ right_identity _).
+  f_ap.
+Defined.
-- 
2.29.1


From a40e62109066995534459888e8cbb142f7aa9234 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Sat, 8 Aug 2020 21:57:35 +0100
Subject: [PATCH 33/76] changed pose proof to assert due to 8.11 incompat

---
 theories/Algebra/Groups/GroupCoeq.v | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/theories/Algebra/Groups/GroupCoeq.v b/theories/Algebra/Groups/GroupCoeq.v
index 5fee273869..85ab5f8c8a 100644
--- a/theories/Algebra/Groups/GroupCoeq.v
+++ b/theories/Algebra/Groups/GroupCoeq.v
@@ -44,8 +44,8 @@ Proof.
     symmetry.
     apply p. }
   { intros [k p] x.
-    pose proof (q1 := p (freeproduct_inl x)).
-    pose proof (q2 := p (freeproduct_inr x)).
+    assert (q1 := p (freeproduct_inl x)).
+    assert (q2 := p (freeproduct_inr x)).
     simpl in q1, q2.
     rewrite 2 right_identity in q1, q2.
     refine (q1^ @ q2). }
-- 
2.29.1


From 702cfcfdeef8ff02c8e31cc133d14b0fb979d8d2 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Mon, 10 Aug 2020 17:20:09 +0100
Subject: [PATCH 34/76] added Zulip badge to README.md

---
 README.md | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/README.md b/README.md
index 134ff767ec..5bc62bfaca 100644
--- a/README.md
+++ b/README.md
@@ -1,4 +1,4 @@
-![Github Actions CI](https://github.com/HoTT/HoTT/workflows/CI/badge.svg)
+![Github Actions CI](https://github.com/HoTT/HoTT/workflows/CI/badge.svg) [![HoTT Zulip chat](https://img.shields.io/badge/zulip-join_chat-brightgreen.svg)](https://hott.zulipchat.com/)
 
 [Homotopy Type Theory](http://homotopytypetheory.org/) is an interpretation of
 Martin-Löf’s intensional type theory into abstract homotopy theory. Propositional equality
-- 
2.29.1


From 00d6c935395731b9277c112d29039370b9e77e53 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Fri, 14 Aug 2020 17:42:02 +0100
Subject: [PATCH 35/76] name cleanup in FreeProduct.v

---
 theories/Algebra/Groups/FreeProduct.v | 297 +++++++++++++-------------
 1 file changed, 149 insertions(+), 148 deletions(-)

diff --git a/theories/Algebra/Groups/FreeProduct.v b/theories/Algebra/Groups/FreeProduct.v
index 6b83c9ee01..78dccdec01 100644
--- a/theories/Algebra/Groups/FreeProduct.v
+++ b/theories/Algebra/Groups/FreeProduct.v
@@ -13,20 +13,21 @@ Local Open Scope mc_mult_scope.
 (** We wish to define the amalgamated free product of a span of group homomorphisms f : G -> H, g : G -> K as the following HIT:
 
   HIT M(f,g)
-   | eta : list (H + K) -> M(f,g)
+   | amal_eta : list (H + K) -> M(f,g)
    | mu_H : forall (x y : list (H + K)) (h1 h2 : H),
-      eta (x ++ [inl h1, inl h2] ++ y) = eta (x ++ [inl (h1 * h2)] ++ y)
+      amal_eta (x ++ [inl h1, inl h2] ++ y) = amal_eta (x ++ [inl (h1 * h2)] ++ y)
    | mu_K : forall (x y : list (H + K)) (k1 k2 : K),
-      eta (x ++ [inr k1, inr k2] ++ y) = eta (x ++ [inr (k1 * k2)] ++ y)
+      amal_eta (x ++ [inr k1, inr k2] ++ y) = amal_eta (x ++ [inr (k1 * k2)] ++ y)
    | tau : forall (x y : list (H + K)) (z : G),
-      eta (x ++ [inl (f z)] ++ y) = eta (x ++ [inr (g z)] ++ y)
+      amal_eta (x ++ [inl (f z)] ++ y) = amal_eta (x ++ [inr (g z)] ++ y)
    | omega_H : forall (x y : list (H + K)),
-      eta (x ++ [inl mon_unit] ++ y) = eta (x ++ y)
+      amal_eta (x ++ [inl mon_unit] ++ y) = amal_eta (x ++ y)
    | omega_K : forall (x y : list (H + K)),
-      eta (x ++ [inr mon_unit] ++ y) = eta (x ++ y).
+      amal_eta (x ++ [inr mon_unit] ++ y) = amal_eta (x ++ y).
 
   We will build this HIT up sucessively out of coequalizers. *)
 
+(** We will call M [amal_type] and prefix all the constructors with [amal_] (for amalgmated free product). *)
 
 (** Here are some operations on lists from the coq stdlib *)
 Section Fold_Left_Recursor.
@@ -189,7 +190,7 @@ Section FreeProduct.
   Defined.
 
   (** We can then define maps going into words consisting of the corresponding endpoints of the path constructors. *)
-  Definition map : pc1 + pc2 + pc3 + pc4 + pc5 -> Words.
+  Definition map1 : pc1 + pc2 + pc3 + pc4 + pc5 -> Words.
   Proof.
     intros [[[[x|x]|x]|x]|x].
     + exact (m1 x).
@@ -199,7 +200,7 @@ Section FreeProduct.
     + exact (m5 x).
   Defined.
 
-  Definition map' : pc1 + pc2 + pc3 + pc4 + pc5 -> Words.
+  Definition map2 : pc1 + pc2 + pc3 + pc4 + pc5 -> Words.
   Proof.
     intros [[[[x|x]|x]|x]|x].
     + exact (m1' x).
@@ -210,66 +211,66 @@ Section FreeProduct.
   Defined.
 
   (** Finally we can define our type as the 0-truncation of the coequalizer of these maps *)
-  Definition M : Type := Tr 0 (Coeq map map').
+  Definition amal_type : Type := Tr 0 (Coeq map1 map2).
 
   (** We can define the constructors *)
 
-  Definition eta : Words -> M := tr o coeq.
+  Definition amal_eta : Words -> amal_type := tr o coeq.
 
-  Definition mu_H (x y : Words) (h1 h2 : H)
-    : eta (x ++ (cons (inl h1) [inl h2]) ++ y) = eta (x ++ [inl (h1 * h2)] ++ y).
+  Definition amal_mu_H (x y : Words) (h1 h2 : H)
+    : amal_eta (x ++ (cons (inl h1) [inl h2]) ++ y) = amal_eta (x ++ [inl (h1 * h2)] ++ y).
   Proof.
-    unfold eta.
+    unfold amal_eta.
     apply path_Tr, tr.
     exact (cglue (inl (inl (inl (inl (x,h1,h2,y)))))).
   Defined.
 
-  Definition mu_K (x y : Words) (k1 k2 : K)
-    : eta (x ++ (cons (inr k1) [inr k2]) ++ y) = eta (x ++ [inr (k1 * k2)] ++ y).
+  Definition amal_mu_K (x y : Words) (k1 k2 : K)
+    : amal_eta (x ++ (cons (inr k1) [inr k2]) ++ y) = amal_eta (x ++ [inr (k1 * k2)] ++ y).
   Proof.
-    unfold eta.
+    unfold amal_eta.
     apply path_Tr, tr.
     exact (cglue (inl (inl (inl (inr (x,k1,k2,y)))))).
   Defined.
 
-  Definition tau (x y : Words) (z : G)
-    : eta (x ++ [inl (f z)] ++ y) = eta (x ++ [inr (g z)] ++ y).
+  Definition amal_tau (x y : Words) (z : G)
+    : amal_eta (x ++ [inl (f z)] ++ y) = amal_eta (x ++ [inr (g z)] ++ y).
   Proof.
-    unfold eta.
+    unfold amal_eta.
     apply path_Tr, tr.
     exact (cglue (inl (inl (inr (x,z,y))))).
   Defined.
 
-  Definition omega_H (x y : Words)
-    : eta (x ++ [inl mon_unit] ++ y) = eta (x ++ y).
+  Definition amal_omega_H (x y : Words)
+    : amal_eta (x ++ [inl mon_unit] ++ y) = amal_eta (x ++ y).
   Proof.
-    unfold eta.
+    unfold amal_eta.
     apply path_Tr, tr.
     exact (cglue (inl (inr (x,y)))).
   Defined.
 
-  Definition omega_K (x y : Words)
-    : eta (x ++ [inr mon_unit] ++ y) = eta (x ++ y).
+  Definition amal_omega_K (x y : Words)
+    : amal_eta (x ++ [inr mon_unit] ++ y) = amal_eta (x ++ y).
   Proof.
-    unfold eta.
+    unfold amal_eta.
     apply path_Tr, tr.
     exact (cglue (inr (x,y))).
   Defined.
 
   (** Now we can derive the dependent eliminator *)
 
-  Definition M_ind (P : M -> Type) `{forall x, IsHSet (P x)}
-    (e : forall w, P (eta w))
+  Definition amal_type_ind (P : amal_type -> Type) `{forall x, IsHSet (P x)}
+    (e : forall w, P (amal_eta w))
     (mh : forall (x y : Words) (h1 h2 : H),
-      DPath P (mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y)) (e (x ++ [inl (h1 * h2)] ++ y)))
+      DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y)) (e (x ++ [inl (h1 * h2)] ++ y)))
     (mk : forall (x y : Words) (k1 k2 : K),
-      DPath P (mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y)) (e (x ++ [inr (k1 * k2)] ++ y)))
+      DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y)) (e (x ++ [inr (k1 * k2)] ++ y)))
     (t : forall (x y : Words) (z : G),
-      DPath P (tau x y z) (e (x ++ [inl (f z)] ++ y)) (e (x ++ [inr (g z)] ++ y)))
+      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y)) (e (x ++ [inr (g z)] ++ y)))
     (oh : forall (x y : Words),
-      DPath P (omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y)))
+      DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y)))
     (ok : forall (x y : Words),
-      DPath P (omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y)))
+      DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y)))
     : forall x, P x.
   Proof.
     snrapply Trunc_ind; [exact _|].
@@ -295,17 +296,17 @@ Section FreeProduct.
       exact (ok x y).
   Defined.
 
-  Definition M_ind_hprop (P : M -> Type) `{forall x, IsHProp (P x)}
-    (e : forall w, P (eta w))
+  Definition amal_type_ind_hprop (P : amal_type -> Type) `{forall x, IsHProp (P x)}
+    (e : forall w, P (amal_eta w))
     : forall x, P x.
   Proof.
-    srapply M_ind.
+    srapply amal_type_ind.
     1: exact e.
     all: intros; apply dp_path_transport, path_ishprop.
   Defined.
 
   (** From which we can derive the non-dependent eliminator / recursion principle *)
-  Definition M_rec (P : Type) `{IsHSet P} (e : Words -> P)
+  Definition amal_type_rec (P : Type) `{IsHSet P} (e : Words -> P)
     (eh : forall (x y : Words) (h1 h2 : H),
       e (x ++ (cons (inl h1) [inl h2]) ++ y) = e (x ++ [inl (h1 * h2)] ++ y))
     (ek : forall (x y : Words) (k1 k2 : K),
@@ -314,9 +315,9 @@ Section FreeProduct.
       e (x ++ [inl (f z)] ++ y) = e (x ++ [inr (g z)] ++ y))
     (oh : forall (x y : Words), e (x ++ [inl mon_unit] ++ y) = e (x ++ y))
     (ok : forall (x y : Words), e (x ++ [inr mon_unit] ++ y) = e (x ++ y))
-    : M -> P.
+    : amal_type -> P.
   Proof.
-    snrapply M_ind.
+    snrapply amal_type_ind.
     1: exact _.
     1: exact e.
     all: intros; apply dp_const.
@@ -330,95 +331,95 @@ Section FreeProduct.
   (** Now for the group structure *)
 
   (** The group operation is concatenation of the underlying list. Most of the work is spent showing that it respects the path constructors. *)
-  Global Instance sgop_m : SgOp M.
+  Global Instance sgop_amal_type : SgOp amal_type.
   Proof.
     intros x y; revert x.
-    srapply M_rec; intros x; revert y.
-    { srapply M_rec; intros y.
-      1: exact (eta (x ++ y)).
+    srapply amal_type_rec; intros x; revert y.
+    { srapply amal_type_rec; intros y.
+      1: exact (amal_eta (x ++ y)).
       { intros z h1 h2.
-        refine (ap eta _ @ _ @ ap eta _^).
+        refine (ap amal_eta _ @ _ @ ap amal_eta _^).
         1,3: apply word_concat_w_ww.
-        rapply mu_H. }
+        rapply amal_mu_H. }
       { intros z k1 k2.
-        refine (ap eta _ @ _ @ ap eta _^).
+        refine (ap amal_eta _ @ _ @ ap amal_eta _^).
         1,3: apply word_concat_w_ww.
-        rapply mu_K. }
+        rapply amal_mu_K. }
       { intros w z.
-        refine (ap eta _ @ _ @ ap eta _^).
+        refine (ap amal_eta _ @ _ @ ap amal_eta _^).
         1,3: apply word_concat_w_ww.
-        apply tau. }
+        apply amal_tau. }
       { intros z.
-        refine (ap eta _ @ _ @ ap eta _^).
+        refine (ap amal_eta _ @ _ @ ap amal_eta _^).
         1,3: apply word_concat_w_ww.
-        apply omega_H. }
+        apply amal_omega_H. }
       { intros z.
-        refine (ap eta _ @ _ @ ap eta _^).
+        refine (ap amal_eta _ @ _ @ ap amal_eta _^).
         1,3: apply word_concat_w_ww.
-        apply omega_K. } }
+        apply amal_omega_K. } }
     { intros r y h1 h2; revert r.
-      rapply M_ind_hprop; cbn.
+      rapply amal_type_ind_hprop; cbn.
       intros z;
-      change (eta ((x ++ ((inl h1 :: [inl h2]) ++ y)) ++ z)
-        = eta ((x ++ [inl (h1 * h2)] ++ y) ++ z)).
-      refine (ap eta _^ @ _ @ ap eta _).
+      change (amal_eta ((x ++ ((inl h1 :: [inl h2]) ++ y)) ++ z)
+        = amal_eta ((x ++ [inl (h1 * h2)] ++ y) ++ z)).
+      refine (ap amal_eta _^ @ _ @ ap amal_eta _).
       1,3: apply word_concat_w_ww.
-      refine (ap eta (ap (app x) _)^ @ _ @ ap eta (ap (app x) _)).
+      refine (ap amal_eta (ap (app x) _)^ @ _ @ ap amal_eta (ap (app x) _)).
       1,3: apply word_concat_w_ww.
-      apply mu_H. }
+      apply amal_mu_H. }
     { intros r y k1 k2; revert r.
-      rapply M_ind_hprop; cbn.
+      rapply amal_type_ind_hprop; cbn.
       intros z;
-      change (eta ((x ++ ((inr k1 :: [inr k2]) ++ y)) ++ z)
-        = eta ((x ++ [inr (k1 * k2)] ++ y) ++ z)).
-      refine (ap eta _^ @ _ @ ap eta _).
+      change (amal_eta ((x ++ ((inr k1 :: [inr k2]) ++ y)) ++ z)
+        = amal_eta ((x ++ [inr (k1 * k2)] ++ y) ++ z)).
+      refine (ap amal_eta _^ @ _ @ ap amal_eta _).
       1,3: apply word_concat_w_ww.
-      refine (ap eta (ap (app x) _)^ @ _ @ ap eta (ap (app x) _)).
+      refine (ap amal_eta (ap (app x) _)^ @ _ @ ap amal_eta (ap (app x) _)).
       1,3: apply word_concat_w_ww.
-      apply mu_K. }
+      apply amal_mu_K. }
     { intros r y z; revert r.
-      rapply M_ind_hprop; cbn.
+      rapply amal_type_ind_hprop; cbn.
       intros w;
-      change (eta ((x ++ [inl (f z)] ++ y) ++ w)
-        = eta ((x ++ [inr (g z)] ++ y) ++ w)).
-      refine (ap eta _^ @ _ @ ap eta _).
+      change (amal_eta ((x ++ [inl (f z)] ++ y) ++ w)
+        = amal_eta ((x ++ [inr (g z)] ++ y) ++ w)).
+      refine (ap amal_eta _^ @ _ @ ap amal_eta _).
       1,3: apply word_concat_w_ww.
-      refine (ap eta (ap (app x) _)^ @ _ @ ap eta (ap (app x) _)).
+      refine (ap amal_eta (ap (app x) _)^ @ _ @ ap amal_eta (ap (app x) _)).
       1,3: apply word_concat_w_ww.
-      apply tau. }
+      apply amal_tau. }
     { intros r z; revert r.
-      rapply M_ind_hprop; cbn.
+      rapply amal_type_ind_hprop; cbn.
       intros w;
-      change (eta ((x ++ [inl mon_unit] ++ z) ++ w) = eta ((x ++ z) ++ w)).
-      refine (ap eta _^ @ _ @ ap eta _).
+      change (amal_eta ((x ++ [inl mon_unit] ++ z) ++ w) = amal_eta ((x ++ z) ++ w)).
+      refine (ap amal_eta _^ @ _ @ ap amal_eta _).
       1,3: apply word_concat_w_ww.
-      refine (ap eta (ap (app x) _)^ @ _).
+      refine (ap amal_eta (ap (app x) _)^ @ _).
       1: apply word_concat_w_ww.
-      apply omega_H. }
+      apply amal_omega_H. }
     { intros r z; revert r.
-      rapply M_ind_hprop; cbn.
+      rapply amal_type_ind_hprop; cbn.
       intros w;
-      change (eta ((x ++ [inr mon_unit] ++ z) ++ w) = eta ((x ++ z) ++ w)).
-      refine (ap eta _^ @ _ @ ap eta _).
+      change (amal_eta ((x ++ [inr mon_unit] ++ z) ++ w) = amal_eta ((x ++ z) ++ w)).
+      refine (ap amal_eta _^ @ _ @ ap amal_eta _).
       1,3: apply word_concat_w_ww.
-      refine (ap eta (ap (app x) _)^ @ _).
+      refine (ap amal_eta (ap (app x) _)^ @ _).
       1: apply word_concat_w_ww.
-      apply omega_K. }
+      apply amal_omega_K. }
   Defined.
 
   (** The identity element is the empty list *)
-  Global Instance monunit_m : MonUnit M.
+  Global Instance monunit_amal_type : MonUnit amal_type.
   Proof.
-    exact (eta nil).
+    exact (amal_eta nil).
   Defined.
 
-  Global Instance negate_m : Negate M.
+  Global Instance negate_amal_type : Negate amal_type.
   Proof.
-    srapply M_rec.
+    srapply amal_type_rec.
     { intros w.
-      exact (eta (word_inverse w)). }
+      exact (amal_eta (word_inverse w)). }
     { hnf; intros x y h1 h2.
-      refine (ap eta _ @ _ @ ap eta _^).
+      refine (ap amal_eta _ @ _ @ ap amal_eta _^).
       1,3: refine (word_inverse_ww _ _ @ ap (fun s => s ++ _) _).
       1: apply word_inverse_ww.
       { refine (word_inverse_ww _ _ @ _).
@@ -427,11 +428,11 @@ Section FreeProduct.
         apply ap.
         apply negate_sg_op. }
       simpl.
-      refine (ap eta _^ @ _ @ ap eta _).
+      refine (ap amal_eta _^ @ _ @ ap amal_eta _).
       1,3: apply word_concat_w_ww.
-      apply mu_H. }
+      apply amal_mu_H. }
     { hnf; intros x y k1 k2.
-      refine (ap eta _ @ _ @ ap eta _^).
+      refine (ap amal_eta _ @ _ @ ap amal_eta _^).
       1,3: refine (word_inverse_ww _ _ @ ap (fun s => s ++ _) _).
       1: apply word_inverse_ww.
       { refine (word_inverse_ww _ _ @ _).
@@ -440,145 +441,145 @@ Section FreeProduct.
         apply ap.
         apply negate_sg_op. }
       simpl.
-      refine (ap eta _^ @ _ @ ap eta _).
+      refine (ap amal_eta _^ @ _ @ ap amal_eta _).
       1,3: apply word_concat_w_ww.
-      apply mu_K. }
+      apply amal_mu_K. }
     { hnf; intros x y z.
-      refine (ap eta _ @ _ @ ap eta _^).
+      refine (ap amal_eta _ @ _ @ ap amal_eta _^).
       1,3: refine (word_inverse_ww _ _ @ ap (fun s => s ++ _) _).
       1,2: cbn; refine (ap _ _).
       1,2: rapply (ap (fun s => [s])).
       1,2: apply ap.
       1,2: symmetry; apply grp_homo_inv.
-      refine (ap eta _^ @ _ @ ap eta _).
+      refine (ap amal_eta _^ @ _ @ ap amal_eta _).
       1,3: apply word_concat_w_ww.
-      apply tau. }
+      apply amal_tau. }
     { hnf; intros x z.
-      refine (ap eta _ @ _ @ ap eta _^).
+      refine (ap amal_eta _ @ _ @ ap amal_eta _^).
       1,3: apply word_inverse_ww.
-      refine (ap eta _ @ _).
+      refine (ap amal_eta _ @ _).
       { refine (ap (fun s => s ++ _) _).
         apply word_inverse_ww. }
-      refine (ap eta _^ @ _).
+      refine (ap amal_eta _^ @ _).
       1: apply word_concat_w_ww.
       simpl.
       rewrite negate_mon_unit.
-      apply omega_H. }
+      apply amal_omega_H. }
     { hnf; intros x z.
-      refine (ap eta _ @ _ @ ap eta _^).
+      refine (ap amal_eta _ @ _ @ ap amal_eta _^).
       1,3: apply word_inverse_ww.
-      refine (ap eta _ @ _).
+      refine (ap amal_eta _ @ _).
       { refine (ap (fun s => s ++ _) _).
         apply word_inverse_ww. }
-      refine (ap eta _^ @ _).
+      refine (ap amal_eta _^ @ _).
       1: apply word_concat_w_ww.
       simpl.
       rewrite negate_mon_unit.
-      apply omega_K. }
+      apply amal_omega_K. }
   Defined.
 
   Global Instance associative_sgop_m : Associative sg_op.
   Proof.
     intros x y.
-    rapply M_ind_hprop; intro z; revert y.
-    rapply M_ind_hprop; intro y; revert x.
-    rapply M_ind_hprop; intro x.
-    cbn; nrapply (ap eta).
+    rapply amal_type_ind_hprop; intro z; revert y.
+    rapply amal_type_ind_hprop; intro y; revert x.
+    rapply amal_type_ind_hprop; intro x.
+    cbn; nrapply (ap amal_eta).
     rapply word_concat_w_ww.
   Defined.
 
-  Global Instance leftidentity_sgop_m : LeftIdentity sg_op mon_unit.
+  Global Instance leftidentity_sgop_amal_type : LeftIdentity sg_op mon_unit.
   Proof.
-    rapply M_ind_hprop; intro x.
+    rapply amal_type_ind_hprop; intro x.
     reflexivity.
   Defined.
 
-  Global Instance rightidentity_sgop_m : RightIdentity sg_op mon_unit.
+  Global Instance rightidentity_sgop_amal_type : RightIdentity sg_op mon_unit.
   Proof.
-    rapply M_ind_hprop; intro x.
-    cbn; nrapply (ap eta).
+    rapply amal_type_ind_hprop; intro x.
+    cbn; nrapply (ap amal_eta).
     apply word_concat_w_nil.
   Defined.
 
-  Lemma eta_word_concat_Vw (x : Words) : eta (word_inverse x ++ x) = mon_unit.
+  Lemma amal_eta_word_concat_Vw (x : Words) : amal_eta (word_inverse x ++ x) = mon_unit.
   Proof.
     induction x as [|x xs].
     1: reflexivity.
     destruct x as [h|k].
-    + change (eta (word_inverse ([inl h] ++ xs) ++ [inl h] ++ xs) = mon_unit).
+    + change (amal_eta (word_inverse ([inl h] ++ xs) ++ [inl h] ++ xs) = mon_unit).
       rewrite word_inverse_ww.
       rewrite <- word_concat_w_ww.
-      refine (mu_H _ _ _ _ @ _).
+      refine (amal_mu_H _ _ _ _ @ _).
       rewrite left_inverse.
-      rewrite omega_H.
+      rewrite amal_omega_H.
       apply IHxs.
-    + change (eta (word_inverse ([inr k] ++ xs) ++ [inr k] ++ xs) = mon_unit).
+    + change (amal_eta (word_inverse ([inr k] ++ xs) ++ [inr k] ++ xs) = mon_unit).
       rewrite word_inverse_ww.
       rewrite <- word_concat_w_ww.
-      refine (mu_K _ _ _ _ @ _).
+      refine (amal_mu_K _ _ _ _ @ _).
       rewrite left_inverse.
-      rewrite omega_K.
+      rewrite amal_omega_K.
       apply IHxs.
   Defined.
 
-  Lemma eta_word_concat_wV (x : Words) : eta (x ++ word_inverse x) = mon_unit.
+  Lemma amal_eta_word_concat_wV (x : Words) : amal_eta (x ++ word_inverse x) = mon_unit.
   Proof.
     induction x as [|x xs].
     1: reflexivity.
     destruct x as [h|k].
     + cbn.
       rewrite word_concat_w_ww.
-      change (eta ([inl h]) * eta ((xs ++ word_inverse xs)) * eta ([inl (- h)]) = mon_unit).
+      change (amal_eta ([inl h]) * amal_eta ((xs ++ word_inverse xs)) * amal_eta ([inl (- h)]) = mon_unit).
       rewrite IHxs.
-      rewrite rightidentity_sgop_m.
+      rewrite rightidentity_sgop_amal_type.
       cbn.
       rewrite <- (word_concat_w_nil (cons _ _)).
-      change (eta (([inl h] ++ [inl (- h)]) ++ nil) = mon_unit).
+      change (amal_eta (([inl h] ++ [inl (- h)]) ++ nil) = mon_unit).
       rewrite <- word_concat_w_ww.
-      change (eta (nil ++ [inl h] ++ [inl (- h)] ++ nil) = mon_unit).
-      refine (mu_H _ _ _ _ @ _).
+      change (amal_eta (nil ++ [inl h] ++ [inl (- h)] ++ nil) = mon_unit).
+      refine (amal_mu_H _ _ _ _ @ _).
       refine (_ @ _).
       { apply ap, ap.
         rapply (ap (fun x => x ++ _)).
         rapply (ap (fun x => [x])).
         apply ap.
         apply right_inverse. }
-      apply omega_H.
+      apply amal_omega_H.
     +  cbn.
       rewrite word_concat_w_ww.
-      change (eta ([inr k]) * eta ((xs ++ word_inverse xs)) * eta ([inr (-k)]) = mon_unit).
+      change (amal_eta ([inr k]) * amal_eta ((xs ++ word_inverse xs)) * amal_eta ([inr (-k)]) = mon_unit).
       rewrite IHxs.
-      rewrite rightidentity_sgop_m.
+      rewrite rightidentity_sgop_amal_type.
       cbn.
       rewrite <- (word_concat_w_nil (cons _ _)).
-      change (eta (([inr k] ++ [inr (- k)]) ++ nil) = mon_unit).
+      change (amal_eta (([inr k] ++ [inr (- k)]) ++ nil) = mon_unit).
       rewrite <- word_concat_w_ww.
-      change (eta (nil ++ [inr k] ++ [inr (- k)] ++ nil) = mon_unit).
-      refine (mu_K _ _ _ _ @ _).
+      change (amal_eta (nil ++ [inr k] ++ [inr (- k)] ++ nil) = mon_unit).
+      refine (amal_mu_K _ _ _ _ @ _).
       refine (_ @ _).
       { apply ap, ap.
         rapply (ap (fun x => x ++ _)).
         rapply (ap (fun x => [x])).
         apply ap.
         apply right_inverse. }
-      apply omega_K.
+      apply amal_omega_K.
   Defined.
 
-  Global Instance leftinverse_sgop_m : LeftInverse sg_op negate mon_unit.
+  Global Instance leftinverse_sgop_amal_type : LeftInverse sg_op negate mon_unit.
   Proof.
-    rapply M_ind_hprop; intro x.
-    apply eta_word_concat_Vw.
+    rapply amal_type_ind_hprop; intro x.
+    apply amal_eta_word_concat_Vw.
   Defined.
 
-  Global Instance rightinverse_sgop_m : RightInverse sg_op negate mon_unit.
+  Global Instance rightinverse_sgop_amal_type : RightInverse sg_op negate mon_unit.
   Proof.
-    rapply M_ind_hprop; intro x.
-    apply eta_word_concat_wV.
+    rapply amal_type_ind_hprop; intro x.
+    apply amal_eta_word_concat_wV.
   Defined.
 
   Definition AmalgamatedFreeProduct : Group.
   Proof.
-    snrapply (Build_Group M); repeat split; exact _.
+    snrapply (Build_Group amal_type); repeat split; exact _.
   Defined.
 
   (** Using foldr. It's important that we use foldr as foldl is near impossible to reason about. *)
@@ -587,7 +588,7 @@ Section FreeProduct.
     (p : h o f == k o g)
     : AmalgamatedFreeProduct -> X.
   Proof.
-    srapply M_rec.
+    srapply amal_type_rec.
     { intro w.
       refine (fold_right _ _ _ _ w).
       { intros [l|r] x.
@@ -628,8 +629,8 @@ Section FreeProduct.
     (p : h o f == k o g)
     : IsSemiGroupPreserving (AmalgamatedFreeProduct_rec' X h k p).
   Proof.
-    intros x; srapply M_ind_hprop; intro y; revert x;
-    srapply M_ind_hprop; intro x; simpl.
+    intros x; srapply amal_type_ind_hprop; intro y; revert x;
+    srapply amal_type_ind_hprop; intro x; simpl.
     rewrite fold_right_app.
     set (s := (fold_right X (H + K)
      (fun X0 : H + K => match X0 with
@@ -657,10 +658,10 @@ Section FreeProduct.
   Proof.
     snrapply Build_GroupHomomorphism.
     { intro x.
-      exact (eta [inl x]). }
+      exact (amal_eta [inl x]). }
     intros x y.
     rewrite <- (word_concat_w_nil [inl (x * y)]).
-    rewrite <- (mu_H nil nil x y).
+    rewrite <- (amal_mu_H nil nil x y).
     rewrite word_concat_w_nil.
     reflexivity.
   Defined.
@@ -669,10 +670,10 @@ Section FreeProduct.
   Proof.
     snrapply Build_GroupHomomorphism.
     { intro x.
-      exact (eta [inr x]). }
+      exact (amal_eta [inr x]). }
     intros x y.
     rewrite <- (word_concat_w_nil [inr (x * y)]).
-    rewrite <- (mu_K nil nil x y).
+    rewrite <- (amal_mu_K nil nil x y).
     rewrite word_concat_w_nil.
     reflexivity.
   Defined.
@@ -691,17 +692,17 @@ Section FreeProduct.
       simpl.
       rewrite <- (word_concat_w_nil [inl (f x)]).
       rewrite <- (word_concat_w_nil [inr (g x)]).
-      apply (tau nil nil x). }
+      apply (amal_tau nil nil x). }
     { intros r.
       apply equiv_path_grouphomomorphism.
-      srapply M_ind_hprop.
+      srapply amal_type_ind_hprop.
       intro x.
       induction x as [|a x].
       1: symmetry; apply (grp_homo_unit r).
       simpl in *.
       rewrite IHx.
       destruct a; symmetry;
-      rapply (grp_homo_op r (eta [_]) (eta x)). }
+      rapply (grp_homo_op r (amal_eta [_]) (amal_eta x)). }
     intro hkp.
     simpl.
     rapply (equiv_ap' (equiv_sigma_prod
-- 
2.29.1


From 23a10726f83c47a551ec9aee82528cbe3d09d53f Mon Sep 17 00:00:00 2001
From: Ramkumar Ramachandra <artagnon@gmail.com>
Date: Fri, 14 Aug 2020 09:44:16 +0200
Subject: [PATCH 36/76] [Overture] Get discriminate working

Register a few things so that the discriminate tactic starts working.

Co-authored-by: Hugo Herbelin <Hugo.Herbelin@inria.fr>
---
 theories/Basics/Overture.v | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/theories/Basics/Overture.v b/theories/Basics/Overture.v
index 18aafe1e3b..96db2b8c49 100644
--- a/theories/Basics/Overture.v
+++ b/theories/Basics/Overture.v
@@ -266,7 +266,7 @@ Proof.
   intros y p.
   destruct p.
   exact u.
-Defined.                                  
+Defined.
 
 (** We declare a scope in which we shall place path notations. This way they can be turned on and off by the user. *)
 
@@ -671,6 +671,7 @@ Ltac path_via mid :=
 
 (** We put [Empty] here, instead of in [Empty.v], because [Ltac done] uses it. *)
 Inductive Empty : Type0 := .
+Register Empty as core.False.type.
 
 Scheme Empty_ind := Induction for Empty Sort Type.
 Scheme Empty_rec := Minimality for Empty Sort Type.
@@ -708,7 +709,9 @@ Definition Unit_rect := Unit_ind.
 Hint Resolve tt : core.
 
 Register Unit as core.IDProp.type.
+Register Unit as core.True.type.
 Register tt as core.IDProp.idProp.
+Register tt as core.True.I.
 
 (** *** Pointed types *)
 
-- 
2.29.1


From 4bb7b58cba0543e800f615e36b9944826c43facd Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Tue, 18 Aug 2020 15:44:00 +0100
Subject: [PATCH 37/76] add test  for discriminate tactic

---
 theories/Tests.v | 40 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 40 insertions(+)

diff --git a/theories/Tests.v b/theories/Tests.v
index 207eb5ef11..d80960e774 100644
--- a/theories/Tests.v
+++ b/theories/Tests.v
@@ -88,3 +88,43 @@ Module Issue_973.
   end.
 
 End Issue_973.
+
+
+Module PR_1382.
+  (* Tests for discriminate tactic *)
+
+  Goal O = S O -> Empty.
+   discriminate 1.
+  Qed.
+
+  Goal forall H : O = S O, H = H.
+   discriminate H.
+  Qed.
+
+  Goal O = S O -> Unit.
+  intros H. discriminate H. Qed.
+  Goal O = S O -> Unit.
+  intros H. Ltac g x := discriminate x. g H. Qed.
+
+  Goal (forall x y : nat, x = y -> x = S y) -> Unit.
+  intros.
+  try discriminate (H O) || exact tt.
+  Qed.
+
+  Goal (forall x y : nat, x = y -> x = S y) -> Unit.
+  intros H. ediscriminate (H O). instantiate (1:=O). Abort.
+
+  (* Check discriminate on types with local definitions *)
+
+  Inductive A := B (T := Unit) (x y : Bool) (z := x).
+  Goal forall x y, B x true = B y false -> Empty.
+  discriminate.
+  Qed.
+
+End PR_1382.
+
+
+
+
+
+
-- 
2.29.1


From abad043e75eadbb8bc388e7e5b06f4ebc1f3ef9d Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 20 Aug 2020 13:23:49 +0100
Subject: [PATCH 38/76] Update theories/Algebra/Groups/Presentation.v

Co-authored-by: Mike Shulman <viritrilbia@gmail.com>
---
 theories/Algebra/Groups/Presentation.v | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/theories/Algebra/Groups/Presentation.v b/theories/Algebra/Groups/Presentation.v
index b9a004ece5..14759a93e6 100644
--- a/theories/Algebra/Groups/Presentation.v
+++ b/theories/Algebra/Groups/Presentation.v
@@ -25,7 +25,7 @@ Proof.
   intros [X I R].
   exact (GroupCoeq
     (FreeGroup_rec I (FreeGroup X) R)
-    (FreeGroup_rec I (FreeGroup X) (fun x => mon_unit))).
+    (FreeGroup_rec I (FreeGroup X) (fun x => group_unit))).
 Defined.
 
 (** A group [G] has a presentation if there exists a group presentation whose presented group is isomorphic to [G]. *)
-- 
2.29.1


From cfe9e1340bbadd50a8f96fa92a13014b32ef7234 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 20 Aug 2020 14:01:25 +0100
Subject: [PATCH 39/76] fixed group_unit in Presentation.v

---
 theories/Algebra/Groups/Presentation.v | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/theories/Algebra/Groups/Presentation.v b/theories/Algebra/Groups/Presentation.v
index 14759a93e6..f8f6203e50 100644
--- a/theories/Algebra/Groups/Presentation.v
+++ b/theories/Algebra/Groups/Presentation.v
@@ -25,7 +25,7 @@ Proof.
   intros [X I R].
   exact (GroupCoeq
     (FreeGroup_rec I (FreeGroup X) R)
-    (FreeGroup_rec I (FreeGroup X) (fun x => group_unit))).
+    (FreeGroup_rec I (FreeGroup X) (fun x => @group_unit (FreeGroup X)))).
 Defined.
 
 (** A group [G] has a presentation if there exists a group presentation whose presented group is isomorphic to [G]. *)
-- 
2.29.1


From 8b6282fc8d9a2fafc1bc1074efb65ac188bb7ef8 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 20 Aug 2020 17:31:31 +0100
Subject: [PATCH 40/76] seperated out list lemmas into Spaces/List.v

---
 _CoqProject                           |  1 +
 theories/Algebra/Groups/FreeProduct.v | 42 ++-----------------------
 theories/Spaces/List.v                | 45 +++++++++++++++++++++++++++
 3 files changed, 49 insertions(+), 39 deletions(-)
 create mode 100644 theories/Spaces/List.v

diff --git a/_CoqProject b/_CoqProject
index c0392fdb64..559ce0d18e 100644
--- a/_CoqProject
+++ b/_CoqProject
@@ -103,6 +103,7 @@ theories/Cubical/DPathCube.v
 #
 
 theories/Spaces/Nat.v
+theories/Spaces/List.v
 theories/Spaces/Cantor.v
 theories/Spaces/Finite.v
 theories/Spaces/Universe.v
diff --git a/theories/Algebra/Groups/FreeProduct.v b/theories/Algebra/Groups/FreeProduct.v
index 78dccdec01..ad3ae6ad0d 100644
--- a/theories/Algebra/Groups/FreeProduct.v
+++ b/theories/Algebra/Groups/FreeProduct.v
@@ -1,8 +1,9 @@
 Require Import Basics Types.
-Require Import Algebra.Groups.Group.
 Require Import Cubical.
-Require Import Colimits.Pushout.
 Require Import HIT.Coeq.
+Require Import Spaces.List.
+Require Import Colimits.Pushout.
+Require Import Algebra.Groups.Group.
 
 Local Open Scope list_scope.
 Local Open Scope mc_scope.
@@ -29,43 +30,6 @@ Local Open Scope mc_mult_scope.
 
 (** We will call M [amal_type] and prefix all the constructors with [amal_] (for amalgmated free product). *)
 
-(** Here are some operations on lists from the coq stdlib *)
-Section Fold_Left_Recursor.
-  Variables (A : Type) (B : Type).
-  Variable f : A -> B -> A.
-
-  Fixpoint fold_left (l : list B) (a0 : A) : A :=
-    match l with
-      | nil => a0
-      | cons b t => fold_left t (f a0 b)
-    end.
-
-  Lemma fold_left_app : forall (l l' : list B) (i : A),
-    fold_left (l ++ l') i = fold_left l' (fold_left l i).
-  Proof.
-    induction l; simpl; auto.
-  Qed.
-
-End Fold_Left_Recursor.
-
-Section Fold_Right_Recursor.
-  Variables (A : Type) (B : Type).
-  Variable f : B -> A -> A.
-
-  Fixpoint fold_right (a0 : A) (l:list B) : A :=
-    match l with
-      | nil => a0
-      | cons b t => f b (fold_right a0 t)
-    end.
-
-  Lemma fold_right_app : forall l l' i,
-    fold_right i (l++l') = fold_right (fold_right i l') l.
-  Proof.
-    induction l; simpl; auto.
-  Qed.
-
-End Fold_Right_Recursor.
-
 Section FreeProduct.
 
   Context (G H K : Group)
diff --git a/theories/Spaces/List.v b/theories/Spaces/List.v
new file mode 100644
index 0000000000..46e0321338
--- /dev/null
+++ b/theories/Spaces/List.v
@@ -0,0 +1,45 @@
+Require Import Basics Types.
+
+Local Open Scope list_scope.
+
+(** ** Lemmas about lists *)
+
+(** Note that [list] is currently defined in the coq stdlib. *)
+
+Section Fold_Left_Recursor.
+  Variables (A : Type) (B : Type).
+  Variable f : A -> B -> A.
+
+  Fixpoint fold_left (l : list B) (a0 : A) : A :=
+    match l with
+      | nil => a0
+      | cons b t => fold_left t (f a0 b)
+    end.
+
+  Lemma fold_left_app : forall (l l' : list B) (i : A),
+    fold_left (l ++ l') i = fold_left l' (fold_left l i).
+  Proof.
+    induction l; simpl; auto.
+  Qed.
+
+End Fold_Left_Recursor.
+
+Section Fold_Right_Recursor.
+  Variables (A : Type) (B : Type).
+  Variable f : B -> A -> A.
+
+  Fixpoint fold_right (a0 : A) (l : list B) : A :=
+    match l with
+      | nil => a0
+      | cons b t => f b (fold_right a0 t)
+    end.
+
+  Lemma fold_right_app : forall l l' i,
+    fold_right i (l ++ l') = fold_right (fold_right i l') l.
+  Proof.
+    induction l; simpl; auto.
+    intros; f_ap.
+  Qed.
+
+End Fold_Right_Recursor.
+
-- 
2.29.1


From 6f23f267101c7256ce9be281d4ad22ba8a46b14a Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 20 Aug 2020 17:37:55 +0100
Subject: [PATCH 41/76] private contents of ListQuotient and FreeProduct made
 into Local defs

---
 .../Algebra/Groups/FreeGroup/ListQuotient.v   | 24 +++++-----
 theories/Algebra/Groups/FreeProduct.v         | 46 +++++++++----------
 theories/Algebra/Groups/Presentation.v        |  2 +-
 3 files changed, 36 insertions(+), 36 deletions(-)

diff --git a/theories/Algebra/Groups/FreeGroup/ListQuotient.v b/theories/Algebra/Groups/FreeGroup/ListQuotient.v
index 5a51c054b4..96cfaca768 100644
--- a/theories/Algebra/Groups/FreeGroup/ListQuotient.v
+++ b/theories/Algebra/Groups/FreeGroup/ListQuotient.v
@@ -13,37 +13,37 @@ Section Reduction.
   Context (A : Type).
 
   (** We define words (with inverses) on A to be lists of marked elements of A *)
-  Definition Words : Type := list (A + A).
+  Local Definition Words : Type := list (A + A).
 
   (** Given a marked element of A we can change its mark *)
-  Definition change_sign : A + A -> A + A
+  Local Definition change_sign : A + A -> A + A
     := fun x => match x with
                 | inl a => inr a
                 | inr a => inl a
                 end.
 
   (** We introduce a local notation for [change_sign]. It is only defined in this section however. *)
-  Notation "x ^" := (change_sign x).
+  Local Notation "x ^" := (change_sign x).
 
   (** Changing sign is an involution *)
-  Definition change_sign_inv a : a^^ = a.
+  Local Definition change_sign_inv a : a^^ = a.
   Proof.
     by destruct a.
   Defined.
 
   (** We can concatenate words using list concatenation *)
-  Definition word_concat : Words -> Words -> Words := @app _.
+  Local Definition word_concat : Words -> Words -> Words := @app _.
 
   (** We introduce a local notation for word_concat. *)
-  Infix "@" := word_concat.
+  Local Infix "@" := word_concat.
 
-  Definition word_concat_w_nil x : x @ nil = x.
+  Local Definition word_concat_w_nil x : x @ nil = x.
   Proof.
     induction x; trivial.
     cbn; f_ap.
   Defined.
 
-  Definition word_concat_w_ww x y z : x @ (y @ z) = (x @ y) @ z.
+  Local Definition word_concat_w_ww x y z : x @ (y @ z) = (x @ y) @ z.
   Proof.
     revert x z.
     induction y; intros x z.
@@ -57,9 +57,9 @@ Section Reduction.
   Defined.
 
   (** Singleton word *)
-  Definition word_sing (x : A + A) : Words := (cons x nil).
+  Local Definition word_sing (x : A + A) : Words := (cons x nil).
 
-  Notation "[ x ]" := (word_sing x).
+  Local Notation "[ x ]" := (word_sing x).
 
   (** We define an inductive family [Red] on [Words] which expresses whether a given word can be reduced to the empty list *)
   Inductive Red : Words -> Type :=
@@ -76,13 +76,13 @@ Section Reduction.
 
     Since we cannot write our HITs directly like this (without resorting to private inductive types), we will construct this HIT out of HITs we know. In fact, we can define N(A) as a coequalizer. *)
 
-  Definition map1 : Words * (A + A) * Words -> Words.
+  Local Definition map1 : Words * (A + A) * Words -> Words.
   Proof.
     intros [[x a] y].
     exact (x @ [a] @ [a^] @ y).
   Defined.
 
-  Definition map2 : Words * (A + A) * Words -> Words.
+  Local Definition map2 : Words * (A + A) * Words -> Words.
   Proof.
     intros [[x a] y].
     exact (x @ y).
diff --git a/theories/Algebra/Groups/FreeProduct.v b/theories/Algebra/Groups/FreeProduct.v
index ad3ae6ad0d..091bdda94a 100644
--- a/theories/Algebra/Groups/FreeProduct.v
+++ b/theories/Algebra/Groups/FreeProduct.v
@@ -35,17 +35,17 @@ Section FreeProduct.
   Context (G H K : Group)
     (f : GroupHomomorphism G H) (g : GroupHomomorphism G K).
 
-  Definition Words : Type := list (H + K).
+  Local Definition Words : Type := list (H + K).
 
-  Notation "[ x ]" := (cons x nil).
+  Local Notation "[ x ]" := (cons x nil).
 
-  Definition word_concat_w_nil (x : Words) : x ++ nil = x.
+  Local Definition word_concat_w_nil (x : Words) : x ++ nil = x.
   Proof.
     induction x; trivial.
     cbn; f_ap.
   Defined.
 
-  Definition word_concat_w_ww (x y z : Words) : x ++ (y ++ z) = (x ++ y) ++ z.
+  Local Definition word_concat_w_ww (x y z : Words) : x ++ (y ++ z) = (x ++ y) ++ z.
   Proof.
     revert x z.
     induction y; intros x z.
@@ -58,7 +58,7 @@ Section FreeProduct.
     apply IHx, IHy.
   Defined.
 
-  Fixpoint word_inverse (x : Words) : Words.
+  Local Fixpoint word_inverse (x : Words) : Words.
   Proof.
     destruct x as [|x xs].
     1: exact nil.
@@ -68,7 +68,7 @@ Section FreeProduct.
   Defined.
 
   (** Inversion changes order of concatenation. *)
-  Definition word_inverse_ww (x y : Words)
+  Local Definition word_inverse_ww (x y : Words)
     : word_inverse (x ++ y) = word_inverse y ++ word_inverse x.
   Proof.
     induction x as [|x xs].
@@ -82,79 +82,79 @@ Section FreeProduct.
   (** There are five source types for the path constructors. We will construct this HIT as the colimit of five forks going into [Words]. We can bundle up this colimit as a single coequalizer. *)
 
   (** Source types of path constructors *)
-  Definition pc1 : Type := Words * H * H * Words.
-  Definition pc2 : Type := Words * K * K * Words.
-  Definition pc3 : Type := Words * G * Words.
-  Definition pc4 : Type := Words * Words.
-  Definition pc5 : Type := Words * Words.
+  Local Definition pc1 : Type := Words * H * H * Words.
+  Local Definition pc2 : Type := Words * K * K * Words.
+  Local Definition pc3 : Type := Words * G * Words.
+  Local Definition pc4 : Type := Words * Words.
+  Local Definition pc5 : Type := Words * Words.
 
   (** End points of the first path constructor *)
-  Definition m1 : pc1 -> Words.
+  Local Definition m1 : pc1 -> Words.
   Proof.
     intros [[[x h1] h2] y].
     exact (x ++ (inl h1 :: [inl h2]) ++ y).
   Defined.
 
-  Definition m1' : pc1 -> Words.
+  Local Definition m1' : pc1 -> Words.
   Proof.
     intros [[[x h1] h2] y].
     exact (x ++ [inl (h1 * h2)] ++ y).
   Defined.
 
   (** End points of the second path construct *)
-  Definition m2 : pc2 -> Words.
+  Local Definition m2 : pc2 -> Words.
   Proof.
     intros [[[x k1] k2] y].
     exact (x ++ (inr k1 :: [inr k2]) ++ y).
   Defined.
 
-  Definition m2' : pc2 -> Words.
+  Local Definition m2' : pc2 -> Words.
   Proof.
     intros [[[x k1] k2] y].
     exact (x ++ [inr (k1 * k2)] ++ y).
   Defined.
 
   (** End points of the third path constructor *)
-  Definition m3 : pc3 -> Words.
+  Local Definition m3 : pc3 -> Words.
   Proof.
     intros [[x z] y].
     exact (x ++ [inl (f z)] ++ y).
   Defined.
 
-  Definition m3' : pc3 -> Words.
+  Local Definition m3' : pc3 -> Words.
   Proof.
     intros [[x z] y].
     exact (x ++ [inr (g z)] ++ y).
   Defined.
 
   (** End points of the fourth path constructor *)
-  Definition m4 : pc4 -> Words.
+  Local Definition m4 : pc4 -> Words.
   Proof.
     intros [x y].
     exact (x ++ [inl mon_unit] ++ y).
   Defined.
 
-  Definition m4' : pc4 -> Words.
+  Local Definition m4' : pc4 -> Words.
   Proof.
     intros [x y].
     exact (x ++ y).
   Defined.
 
   (** End points of the fifth path constructor *)
-  Definition m5 : pc5 -> Words.
+  Local Definition m5 : pc5 -> Words.
   Proof.
     intros [x y].
     exact (x ++ [inr mon_unit] ++ y).
   Defined.
 
-  Definition m5' : pc5 -> Words.
+  Local Definition m5' : pc5 -> Words.
   Proof.
     intros [x y].
     exact (x ++ y).
   Defined.
 
   (** We can then define maps going into words consisting of the corresponding endpoints of the path constructors. *)
-  Definition map1 : pc1 + pc2 + pc3 + pc4 + pc5 -> Words.
+  Local Definition map1 : pc1 + pc2 + pc3 + pc4 + pc5 -> Words.
   Proof.
     intros [[[[x|x]|x]|x]|x].
     + exact (m1 x).
@@ -164,7 +164,7 @@ Section FreeProduct.
     + exact (m5 x).
   Defined.
 
-  Definition map2 : pc1 + pc2 + pc3 + pc4 + pc5 -> Words.
+  Local Definition map2 : pc1 + pc2 + pc3 + pc4 + pc5 -> Words.
   Proof.
     intros [[[[x|x]|x]|x]|x].
     + exact (m1' x).
diff --git a/theories/Algebra/Groups/Presentation.v b/theories/Algebra/Groups/Presentation.v
index f8f6203e50..89ebd10699 100644
--- a/theories/Algebra/Groups/Presentation.v
+++ b/theories/Algebra/Groups/Presentation.v
@@ -106,7 +106,7 @@ Proof.
   hnf in p.
   pose (p' := p o freegroup_eta _).
   clearbody p'; clear p.
-  specialize (p' (word_sing _ (inl r))).
+  specialize (p' (ListQuotient.word_sing _ (inl r))).
   refine (_ @ p').
   clear p'.
   symmetry.
-- 
2.29.1


From 235e30a36c94bc85fb7997535a1bb8697471803f Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 20 Aug 2020 17:39:28 +0100
Subject: [PATCH 42/76] improve comment on relator/relation distinction

---
 theories/Algebra/Groups/Presentation.v | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/theories/Algebra/Groups/Presentation.v b/theories/Algebra/Groups/Presentation.v
index 89ebd10699..cdb8f7a333 100644
--- a/theories/Algebra/Groups/Presentation.v
+++ b/theories/Algebra/Groups/Presentation.v
@@ -17,7 +17,7 @@ Record GroupPresentation := {
   gp_relators : gp_rel_index -> FreeGroup gp_generators;
 }.
 
-(** Note: A relator is a relation in the form of "f(x) = 1", any relation "f(x) = g(x)" can become a relator "f(x)g(x)^-1 = 1". *)
+(** Note: A relator is a relation in the form of "w = 1", any relation "w = v" can become a relator "wv^-1 = 1" for words v and w. *)
 
 (** Given the data of a group presentation we can construct the group. This is sometimes called the presented group. *)
 Definition group_gp : GroupPresentation -> Group.
-- 
2.29.1


From e58b8440942ae12c17e034ad536c051ea9a8bc15 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 20 Aug 2020 19:22:49 +0100
Subject: [PATCH 43/76] removed "oo" notation for purely

---
 theories/Homotopy/ExactSequence.v | 59 +++++++++++++++----------------
 theories/Truncations/Core.v       |  3 --
 2 files changed, 29 insertions(+), 33 deletions(-)

diff --git a/theories/Homotopy/ExactSequence.v b/theories/Homotopy/ExactSequence.v
index 371ddcb14d..27a5d66d75 100644
--- a/theories/Homotopy/ExactSequence.v
+++ b/theories/Homotopy/ExactSequence.v
@@ -193,7 +193,7 @@ Proof.
   rewrite (concat_A1p (eisretr k)), concat_V_pp. reflexivity.
 Defined.
 
-(** When [n] is the identity modality [oo], so that [cxfib] is an equivalence, we get simply a fiber sequence.  In particular, the fiber of a given map yields an oo-exact sequence. *)
+(** When [n] is the identity modality [oo], so that [cxfib] is an equivalence, we get simply a fiber sequence.  In particular, the fiber of a given map yields an purely-exact sequence. *)
 
 Definition iscomplex_pfib {X Y} (f : X ->* Y)
   : IsComplex (pfib f) f.
@@ -204,7 +204,7 @@ Proof.
 Defined.
 
 Global Instance isexact_pfib {X Y} (f : X ->* Y)
-  : IsExact oo (pfib f) f.
+  : IsExact purely (pfib f) f.
 Proof.
   exists (iscomplex_pfib f).
   exact _.
@@ -217,8 +217,8 @@ Definition i_fiberseq {F X Y} (fs : FiberSeq F X Y)
   : F ->* X
   := pfib fs.1 o* fs.2.
 
-Global Instance isexact_oo_fiberseq {F X Y : pType} (fs : FiberSeq F X Y)
-  : IsExact oo (i_fiberseq fs) fs.1.
+Global Instance isexact_purely_fiberseq {F X Y : pType} (fs : FiberSeq F X Y)
+  : IsExact purely (i_fiberseq fs) fs.1.
 Proof.
   srapply Build_IsExact; [ srapply Build_pHomotopy | ].
   - intros u; cbn. 
@@ -235,7 +235,7 @@ Proof.
 Defined.
 
 Definition pequiv_cxfib {F X Y : pType} {i : F ->* X} {f : X ->* Y}
-           `{IsExact oo F X Y i f}
+           `{IsExact purely F X Y i f}
   : F <~>* pfiber f.
 Proof.
   refine (Build_pEquiv _ _ (cxfib cx_isexact) _).
@@ -243,12 +243,12 @@ Proof.
   rapply conn_map_isexact.
 Defined.
 
-Definition fiberseq_isexact_oo {F X Y : pType} (i : F ->* X) (f : X ->* Y)
-           `{IsExact oo F X Y i f}
+Definition fiberseq_isexact_purely {F X Y : pType} (i : F ->* X) (f : X ->* Y)
+           `{IsExact purely F X Y i f}
   : FiberSeq F X Y
   := (f ; pequiv_cxfib).
 
-(** It's easier to show that loops preserve fiber sequences than that they preserve oo-exact sequences. *)
+(** It's easier to show that loops preserve fiber sequences than that they preserve purely-exact sequences. *)
 Definition fiberseq_loops {F X Y} (fs : FiberSeq F X Y)
   : FiberSeq (loops F) (loops X) (loops Y).
 Proof.
@@ -257,14 +257,13 @@ Proof.
   exact ((pfiber_loops_functor fs.1)^-1* ).
 Defined.
 
-(** Now we can deduce that they preserve oo-exact sequences.  The hardest part is modifying the first map back to [loops_functor i]. *)
+(** Now we can deduce that they preserve purely-exact sequences.  The hardest part is modifying the first map back to [loops_functor i]. *)
 Global Instance isexact_loops {F X Y} (i : F ->* X) (f : X ->* Y)
-           `{IsExact oo F X Y i f}
-  : IsExact oo (loops_functor i) (loops_functor f).
+           `{IsExact purely F X Y i f}
+  : IsExact purely (loops_functor i) (loops_functor f).
 Proof.
-  refine (@isexact_homotopic_i
-            oo _ _ _ _ (loops_functor i) _ (loops_functor f)
-            (isexact_oo_fiberseq (fiberseq_loops (fiberseq_isexact_oo i f)))).
+  refine (@isexact_homotopic_i purely _ _ _ _ (loops_functor i) _ (loops_functor f)
+    (isexact_purely_fiberseq (fiberseq_loops (fiberseq_isexact_purely i f)))).
   transitivity (loops_functor (pfib f) o* loops_functor (cxfib cx_isexact)).
   - refine (_ @* loops_functor_compose _ _).
     apply loops_2functor.
@@ -276,8 +275,8 @@ Proof.
 Defined.
 
 Global Instance isexact_iterated_loops {F X Y} (i : F ->* X) (f : X ->* Y)
-           `{IsExact oo F X Y i f} (n : nat)
-  : IsExact oo (iterated_loops_functor n i) (iterated_loops_functor n f).
+           `{IsExact purely F X Y i f} (n : nat)
+  : IsExact purely (iterated_loops_functor n i) (iterated_loops_functor n f).
 Proof.
   induction n as [|n IHn]; [ assumption | apply isexact_loops; assumption ].
 Defined.
@@ -305,8 +304,8 @@ Proof.
 Defined.
 
 (** In particular, (n.+1)-truncation takes fiber sequences to n-exact ones. *)
-Global Instance isexact_ptr_oo `{Univalence} (n : trunc_index)
-           {F X Y : pType} (i : F ->* X) (f : X ->* Y) `{IsExact oo F X Y i f}
+Global Instance isexact_ptr_purely `{Univalence} (n : trunc_index)
+           {F X Y : pType} (i : F ->* X) (f : X ->* Y) `{IsExact purely F X Y i f}
   : IsExact (Tr n) (ptr_functor n.+1 i) (ptr_functor n.+1 f).
 Proof.
   rapply isexact_ptr.
@@ -320,7 +319,7 @@ Defined.
 (** It's useful to see [pfib_cxfib] as a degenerate square. *)
 Definition square_pfib_pequiv_cxfib
            {F X Y : pType} (i : F ->* X) (f : X ->* Y)
-           `{IsExact oo F X Y i f}
+           `{IsExact purely F X Y i f}
   : Square (pequiv_cxfib) (pequiv_pmap_idmap) i (pfib f).
 Proof.
   unfold Square.
@@ -330,7 +329,7 @@ Defined.
 
 (** The connecting maps for the long exact sequence of loop spaces, defined as an extension to a fiber sequence. *)
 Definition connect_fiberseq {F X Y} (i : F ->* X) (f : X ->* Y)
-           `{IsExact oo F X Y i f}
+           `{IsExact purely F X Y i f}
   : FiberSeq (loops Y) F X.
 Proof.
   exists i.
@@ -338,15 +337,15 @@ Proof.
 Defined.
 
 Definition connecting_map {F X Y} (i : F ->* X) (f : X ->* Y)
-           `{IsExact oo F X Y i f}
+           `{IsExact purely F X Y i f}
   : loops Y ->* F
   := i_fiberseq (connect_fiberseq i f).
 
 Global Instance isexact_connect_R {F X Y} (i : F ->* X) (f : X ->* Y)
-       `{IsExact oo F X Y i f}
-  : IsExact oo (loops_functor f) (connecting_map i f).
+       `{IsExact purely F X Y i f}
+  : IsExact purely (loops_functor f) (connecting_map i f).
 Proof.
-  refine (isexact_equiv_i (Y := F) oo
+  refine (isexact_equiv_i (Y := F) purely
           (pfib (pfib i)) (loops_functor f)
           (((loops_inv X) o*E
             (pfiber2_loops (pfib f)) o*E
@@ -382,7 +381,7 @@ Global Existing Instance les_isexact.
 
 (** Long exact sequences are preserved by truncation. *)
 Definition trunc_les `{Univalence} (k : trunc_index) {N : SuccStr}
-           (S : LongExactSequence oo N)
+           (S : LongExactSequence purely N)
   : LongExactSequence (Tr k) N
   := Build_LongExactSequence
        (Tr k) N (fun n => pTr k.+1 (S n))
@@ -399,12 +398,12 @@ Definition loops_carrier (F X Y : pType) (n : N3) : pType :=
   | (n, inr tt) => iterated_loops n F
   end.
 
-(** Starting from a fiber sequence, we can obtain a long oo-exact sequence of loop spaces. *)
+(** Starting from a fiber sequence, we can obtain a long purely-exact sequence of loop spaces. *)
 Definition loops_les {F X Y : pType} (i : F ->* X) (f : X ->* Y)
-           `{IsExact oo F X Y i f}
-  : LongExactSequence oo (N3).
+           `{IsExact purely F X Y i f}
+  : LongExactSequence purely (N3).
 Proof.
-  srefine (Build_LongExactSequence oo (N3) (loops_carrier F X Y) _ _).
+  srefine (Build_LongExactSequence purely (N3) (loops_carrier F X Y) _ _).
   all:intros [n [[[[]|[]]|[]]|[]]]; cbn.
   { exact (iterated_loops_functor n f). }
   { exact (iterated_loops_functor n i). }
@@ -415,6 +414,6 @@ Defined.
 
 (** And from that, a long exact sequence of homotopy groups (though for now it is just a sequence of pointed sets). *)
 Definition Pi_les `{Univalence} {F X Y : pType} (i : F ->* X) (f : X ->* Y)
-           `{IsExact oo F X Y i f}
+           `{IsExact purely F X Y i f}
   : LongExactSequence (Tr (-1)) (N3)
   := trunc_les (-1) (loops_les i f).
diff --git a/theories/Truncations/Core.v b/theories/Truncations/Core.v
index 9209bb9c4d..ba4414475e 100644
--- a/theories/Truncations/Core.v
+++ b/theories/Truncations/Core.v
@@ -159,9 +159,6 @@ Defined.
 
 Hint Immediate istruncmap_mapinO_tr : typeclass_instances.
 
-(** It's sometimes convenient to use "infinity" to refer to the identity modality in a similar way.  This clashes with some uses in higher topos theory, where "oo-truncated" means instead "hypercomplete", but this has not yet been a big problem. *)
-Notation oo := purely.
-
 (** ** A few special things about the (-1)-truncation. *)
 
 Local Open Scope trunc_scope.
-- 
2.29.1


From c9e05a2bec33332498c4ba5110a9f6ef66f8e625 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 20 Aug 2020 19:26:44 +0100
Subject: [PATCH 44/76] remove extra exports in wildcat library

---
 theories/WildCat/Paths.v  |  4 ++--
 theories/WildCat/Type.v   |  6 +++---
 theories/WildCat/Yoneda.v | 16 ++++++++--------
 3 files changed, 13 insertions(+), 13 deletions(-)

diff --git a/theories/WildCat/Paths.v b/theories/WildCat/Paths.v
index f366c8229d..3baf91b92f 100644
--- a/theories/WildCat/Paths.v
+++ b/theories/WildCat/Paths.v
@@ -1,5 +1,5 @@
-Require Export Basics.
-Require Export WildCat.Core.
+Require Import Basics.
+Require Import WildCat.Core.
 
 (** * Path groupoids as wild categories *)
 
diff --git a/theories/WildCat/Type.v b/theories/WildCat/Type.v
index 7cd5ea0d92..fc57c46120 100644
--- a/theories/WildCat/Type.v
+++ b/theories/WildCat/Type.v
@@ -1,6 +1,6 @@
-Require Export Basics.
-Require Export WildCat.Core.
-Require Export WildCat.Equiv.
+Require Import Basics.
+Require Import WildCat.Core.
+Require Import WildCat.Equiv.
 
 (** ** The category of types *)
 
diff --git a/theories/WildCat/Yoneda.v b/theories/WildCat/Yoneda.v
index e27a010f89..10784c31cf 100644
--- a/theories/WildCat/Yoneda.v
+++ b/theories/WildCat/Yoneda.v
@@ -1,13 +1,13 @@
 (* -*- mode: coq; mode: visual-line -*-  *)
 
-Require Export Basics.
-Require Export WildCat.Core.
-Require Export WildCat.Equiv.
-Require Export WildCat.Type.
-Require Export WildCat.Opposite.
-Require Export WildCat.FunctorCat.
-Require Export WildCat.NatTrans.
-Require Export WildCat.Prod.
+Require Import Basics.
+Require Import WildCat.Core.
+Require Import WildCat.Equiv.
+Require Import WildCat.Type.
+Require Import WildCat.Opposite.
+Require Import WildCat.FunctorCat.
+Require Import WildCat.NatTrans.
+Require Import WildCat.Prod.
 
 (** ** Two-variable hom-functors *)
 
-- 
2.29.1


From ff3d9b981670d6b1f82f1c69e1c2fc85035bd0bb Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 20 Aug 2020 19:35:58 +0100
Subject: [PATCH 45/76] open trunc_scope in ooGroup.v

---
 theories/Algebra/ooGroup.v | 1 +
 1 file changed, 1 insertion(+)

diff --git a/theories/Algebra/ooGroup.v b/theories/Algebra/ooGroup.v
index 9b9cc7b0f2..0401b1f3cb 100644
--- a/theories/Algebra/ooGroup.v
+++ b/theories/Algebra/ooGroup.v
@@ -7,6 +7,7 @@ Require Import Homotopy.ClassifyingSpace.
 Require Import Algebra.Groups.
 Require Import WildCat.
 
+Local Open Scope trunc_scope.
 Local Open Scope path_scope.
 Local Open Scope pointed_scope.
 
-- 
2.29.1


From 8c58d64bc0f35333e80e0fac496b2b962fcea964 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Fri, 21 Aug 2020 01:56:42 +0100
Subject: [PATCH 46/76] Update theories/Homotopy/ExactSequence.v

Co-authored-by: Mike Shulman <viritrilbia@gmail.com>
---
 theories/Homotopy/ExactSequence.v | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/theories/Homotopy/ExactSequence.v b/theories/Homotopy/ExactSequence.v
index 27a5d66d75..50bbb0c335 100644
--- a/theories/Homotopy/ExactSequence.v
+++ b/theories/Homotopy/ExactSequence.v
@@ -193,7 +193,7 @@ Proof.
   rewrite (concat_A1p (eisretr k)), concat_V_pp. reflexivity.
 Defined.
 
-(** When [n] is the identity modality [oo], so that [cxfib] is an equivalence, we get simply a fiber sequence.  In particular, the fiber of a given map yields an purely-exact sequence. *)
+(** When [n] is the identity modality [purely], so that [cxfib] is an equivalence, we get simply a fiber sequence.  In particular, the fiber of a given map yields an purely-exact sequence. *)
 
 Definition iscomplex_pfib {X Y} (f : X ->* Y)
   : IsComplex (pfib f) f.
-- 
2.29.1


From 444e2359910790b9296082459e14f7b8fc721fa5 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Fri, 3 Jul 2020 18:35:10 +0100
Subject: [PATCH 47/76] commutative rings

---
 theories/Algebra/Rings/CRing.v | 246 +++++++++++++++++++++++++++++++++
 1 file changed, 246 insertions(+)
 create mode 100644 theories/Algebra/Rings/CRing.v

diff --git a/theories/Algebra/Rings/CRing.v b/theories/Algebra/Rings/CRing.v
new file mode 100644
index 0000000000..e5912be472
--- /dev/null
+++ b/theories/Algebra/Rings/CRing.v
@@ -0,0 +1,246 @@
+Require Import Basics Types WildCat.
+Require Export Classes.interfaces.abstract_algebra.
+Require Import Algebra.AbGroups.
+Require Export Classes.theory.rings.
+
+(** Theory of commutative rings *)
+
+(** TODO: in reality we should really develop the theory of non-commutative rings seperately, and have commutative rings as a special case of that theory. Similar to how we have Group and AbGroup.
+
+But since we are only interested in commutative rings for the time being, it makes sense to only consider them.
+*)
+
+(** A commutative ring consists of the following data *)
+Record CRing := {
+  (** A type *)
+  cring_type : Type;
+  (** A plus operation *)
+  cring_plus : Plus cring_type;
+  (** A mult operation *)
+  cring_mult : Mult cring_type;
+  (** A zero *)
+  cring_zero : Zero cring_type;
+  (** A one *)
+  cring_one  : One  cring_type;
+  (** A negation *)
+  cring_negate : Negate cring_type;
+  (** Such that this data satisfies the axioms of a commmutative ring. *)
+  cring_isring : IsRing cring_type;
+}.
+
+Arguments cring_type {_}.
+Arguments cring_plus {_}.
+Arguments cring_mult {_}.
+Arguments cring_zero {_}.
+Arguments cring_one {_}.
+Arguments cring_negate {_}.
+Arguments cring_isring {_}.
+
+Definition issig_CRing : _ <~> CRing := ltac:(issig).
+
+(** We coerce rings to their underlying type. *)
+Coercion cring_type : CRing >-> Sortclass.
+(** All fields which are typeclasses are global instances *)
+Global Existing Instances cring_plus cring_mult cring_zero cring_one cring_negate cring_isring.
+
+(** A ring homomorphism between commutative rings is a map of the underlying type and a proof that this map is a ring homomorphism. *)
+Record CRingHomomorphism (A B : CRing) := {
+  rng_homo_map : A -> B;
+  rng_homo_ishomo : IsSemiRingPreserving rng_homo_map;
+}.
+
+Arguments Build_CRingHomomorphism {_ _} _ _.
+
+Definition issig_CRingHomomorphism (A B : CRing)
+  : _ <~> CRingHomomorphism A B
+  := ltac:(issig).
+
+(** We coerce ring homomorphisms to their underlyig maps *)
+Coercion rng_homo_map : CRingHomomorphism >-> Funclass.
+(** And we make rng_homo_ishomo a global instance. *)
+Global Existing Instance rng_homo_ishomo.
+
+Definition equiv_path_cringhomomorphism `{Funext} {A B : CRing}
+  {f g : CRingHomomorphism A B} : f == g <~> f = g.
+Proof.
+  refine ((equiv_ap (issig_CRingHomomorphism A B)^-1 _ _)^-1 oE _).
+  refine (equiv_path_sigma_hprop _ _ oE _).
+  apply equiv_path_forall.
+Defined.
+
+Definition rng_homo_id (A : CRing) : CRingHomomorphism A A
+  := Build_CRingHomomorphism idmap _.
+
+Definition rng_homo_compose {A B C : CRing}
+  (f : CRingHomomorphism B C) (g : CRingHomomorphism A B)
+  : CRingHomomorphism A C.
+Proof.
+  snrapply Build_CRingHomomorphism.
+  1: exact (f o g).
+  rapply compose_sr_morphism.
+Defined.
+
+(** Ring laws *)
+
+Section RingLaws.
+
+  (** Many of these ring laws have already been prove. But we give them names here so that they are easy to find and use. *)
+
+  Context {A B : CRing} (f : CRingHomomorphism A B) (x y z : A).
+
+  Definition rng_dist_l : x * (y + z) = x * y + x * z := simple_distribute_l _ _ _.
+  Definition rng_dist_r : (x + y) * z = x * z + y * z := simple_distribute_r _ _ _.
+
+  Definition rng_mult_one_l : 1 * x = x := left_identity _.
+  Definition rng_mult_one_r : x * 1 = x := right_identity _.
+  Definition rng_mult_zero_l : 0 * x = 0 := left_absorb _.
+  Definition rng_mult_zero_r : x * 0 = 0 := right_absorb _.
+  Definition rng_mult_negate_negate : -x * -y = x * y := negate_mult_negate _ _.
+  Definition rng_mult_negate_l : -x * y = -(x * y) := inverse (negate_mult_distr_l _ _).
+  Definition rng_mult_negate_r : x * -y = -(x * y) := inverse (negate_mult_distr_r _ _).
+
+  Definition rng_homo_plus : f (x + y) = f x + f y := preserves_plus x y.
+  Definition rng_homo_mult : f (x * y) = f x * f y := preserves_mult x y.
+  Definition rng_homo_zero : f 0 = 0 := preserves_0.
+  Definition rng_homo_one  : f 1 = 1 := preserves_1.
+  Definition rng_homo_negate : f (-x) = -(f x) := preserves_negate x.
+
+  Definition rng_homo_minus_one : f (-1) = -1
+    := preserves_negate 1%mc @ ap negate preserves_1.
+
+End RingLaws.
+
+(** Isomorphisms of commutative rings *)
+Record CRingIsomorphism (A B : CRing) := {
+  rng_iso_homo : CRingHomomorphism A B ;
+  isequiv_rng_iso_homo : IsEquiv rng_iso_homo ;
+}.
+
+Arguments rng_iso_homo {_ _ }.
+Coercion rng_iso_homo : CRingIsomorphism >-> CRingHomomorphism.
+Global Existing Instance isequiv_rng_iso_homo.
+
+Definition issig_CRingIsomorphism {A B : CRing}
+  : _ <~> CRingIsomorphism A B := ltac:(issig).
+
+(** We can construct a ring isomorphism from an equivalence that preserves addition and multiplication. *)
+Definition Build_CRingIsomorphism' (A B : CRing) (e : A <~> B)
+  `{!IsSemiRingPreserving e}
+  : CRingIsomorphism A B
+  := Build_CRingIsomorphism A B (Build_CRingHomomorphism e _) _.
+
+(** The inverse of a CRing isomorphism *)
+Definition rng_iso_inverse {A B : CRing}
+  : CRingIsomorphism A B -> CRingIsomorphism B A.
+Proof.
+  intros [f e].
+  snrapply Build_CRingIsomorphism.
+  { snrapply Build_CRingHomomorphism.
+    1: exact f^-1.
+    exact _. }
+  exact _.
+Defined.
+
+(** CRing isomorphisms are a reflexive relation *)
+Global Instance reflexive_cringisomorphism : Reflexive CRingIsomorphism
+  := fun x => Build_CRingIsomorphism _ _ (rng_homo_id x) _.
+
+(** CRing isomorphisms are a symmetric relation *)
+Global Instance symmetry_cringisomorphism : Symmetric CRingIsomorphism
+  := fun x y => rng_iso_inverse.
+
+(** CRing isomorphisms are a transitive relation *)
+Global Instance transitive_cringisomorphism : Transitive CRingIsomorphism
+  := fun x y z f g => Build_CRingIsomorphism _ _ (rng_homo_compose g f) _.
+
+(** Underlying abelian groups of rings *)
+Definition abgroup_cring : CRing -> AbGroup
+  := fun A => Build_AbGroup A _ _ _ _.
+
+Coercion abgroup_cring : CRing >-> AbGroup.
+
+(** Underlying group homomorphism of a ring homomorphism *)
+Definition grp_homo_rng_homo {R S : CRing}
+  : CRingHomomorphism R S -> GroupHomomorphism R S
+  := fun f => @Build_GroupHomomorphism R S f _.
+
+Coercion grp_homo_rng_homo : CRingHomomorphism >-> GroupHomomorphism.
+
+(** We can construct a ring homomorphism a group homomorphism that preserves multiplication *)
+Definition Build_CRingHomomorphism' (A B : CRing) (map : GroupHomomorphism A B)
+  {H : IsMonoidPreserving (Aop:=cring_mult) (Bop:=cring_mult)
+    (Aunit:=one) (Bunit:=one) map}
+  : CRingHomomorphism A B
+  := Build_CRingHomomorphism map
+      (Build_IsSemiRingPreserving _ (grp_homo_ishomo _ _ map) H).
+
+(** We can construct a ring isomorphism from a group isomorphism that preserves multiplication *)
+Definition Build_CRingIsomorphism'' (A B : CRing) (e : GroupIsomorphism A B)
+  {H : IsMonoidPreserving (Aop:=cring_mult) (Bop:=cring_mult) (Aunit:=one) (Bunit:=one) e}
+  : CRingIsomorphism A B
+  := @Build_CRingIsomorphism' A B e (Build_IsSemiRingPreserving e _ H).
+
+(** Wild category of commutative rings *)
+
+Global Instance isgraph_cring : IsGraph CRing
+  := Build_IsGraph _ CRingHomomorphism.
+
+Global Instance is01cat_cring : Is01Cat CRing
+  := Build_Is01Cat _ _ rng_homo_id (@rng_homo_compose).
+
+Global Instance isgraph_cringhomomorphism {A B : CRing} : IsGraph (A $-> B)
+  := induced_graph (@rng_homo_map A B).
+
+Global Instance is01cat_cringhomomorphism {A B : CRing} : Is01Cat (A $-> B)
+  := induced_01cat (@rng_homo_map A B).
+
+Global Instance is0gpd_cringhomomorphism {A B : CRing}: Is0Gpd (A $-> B)
+  := induced_0gpd (@rng_homo_map A B).
+
+Global Instance is0functor_postcomp_cringhomomorphism {A B C : CRing} (h : B $-> C)
+  : Is0Functor (@cat_postcomp CRing _ _ A B C h).
+Proof.
+  apply Build_Is0Functor.
+  intros [f ?] [g ?] p a ; exact (ap h (p a)).
+Defined.
+
+Global Instance is0functor_precomp_cringhomomorphism
+       {A B C : CRing} (h : A $-> B)
+  : Is0Functor (@cat_precomp CRing _ _ A B C h).
+Proof.
+  apply Build_Is0Functor.
+  intros [f ?] [g ?] p a ; exact (p (h a)).
+Defined.
+
+(** CRing forms a 1Cat *)
+Global Instance is1cat_cring : Is1Cat CRing.
+Proof.
+  by rapply Build_Is1Cat.
+Defined.
+
+Global Instance hasmorext_cring `{Funext} : HasMorExt CRing.
+Proof.
+  srapply Build_HasMorExt.
+  intros A B f g; cbn in *.
+  snrapply @isequiv_homotopic.
+  1: exact (equiv_path_cringhomomorphism^-1%equiv).
+  1: exact _.
+  intros []; reflexivity. 
+Defined.
+
+Global Instance hasequivs_cring : HasEquivs CRing.
+Proof.
+  unshelve econstructor.
+  + exact CRingIsomorphism.
+  + exact (fun G H f => IsEquiv f).
+  + intros G H f; exact f.
+  + exact Build_CRingIsomorphism.
+  + intros G H; exact rng_iso_inverse.
+  + cbn; exact _.
+  + reflexivity.
+  + intros ????; apply eissect.
+  + intros ????; apply eisretr.
+  + intros G H f g p q.
+    exact (isequiv_adjointify f g p q).
+Defined.
+
-- 
2.29.1


From ed3e765ab582a6f553cf015930d8cd59efffefe4 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Fri, 3 Jul 2020 18:35:17 +0100
Subject: [PATCH 48/76] ideals

---
 theories/Algebra/Rings/Ideal.v | 114 +++++++++++++++++++++++++++++++++
 1 file changed, 114 insertions(+)
 create mode 100644 theories/Algebra/Rings/Ideal.v

diff --git a/theories/Algebra/Rings/Ideal.v b/theories/Algebra/Rings/Ideal.v
new file mode 100644
index 0000000000..c41002e078
--- /dev/null
+++ b/theories/Algebra/Rings/Ideal.v
@@ -0,0 +1,114 @@
+Require Import Basics Types.
+Require Import Algebra.Rings.CRing.
+Require Import Algebra.AbGroups.
+
+Local Open Scope mc_scope.
+
+(** In this file we define Ideals *)
+
+(** TODO: In the future it might be useful to define ideals as submodules *)
+
+(** An additive subgroup I of a ring R is an ideal when: *)
+Class IsIdeal {R : CRing} (I : Subgroup R) := {
+  (** Forall r : R and x : I, there exists an a : I, such that a = r * x inside R *)
+  isideal (r : R) (x : I)
+    : exists (a : I), issubgroup_incl a = r * issubgroup_incl x;
+}.
+
+Record Ideal (R : CRing) := {
+  ideal_subgroup : Subgroup R;
+  ideal_isideal : IsIdeal ideal_subgroup;
+}.
+
+Coercion ideal_subgroup : Ideal >-> Subgroup.
+Global Existing Instances ideal_isideal.
+
+
+Global Instance issubgroup_trivial {G : Group} : IsSubgroup TrivialAbGroup G.
+Proof.
+  snrapply Build_IsSubgroup.
+  { snrapply (Build_GroupHomomorphism (fun _ => group_unit)).
+    intros ??; symmetry; apply left_identity. }
+  cbn; intros ???.
+  apply path_unit.
+Defined.
+
+Global Instance isinj_idmap A : @IsInjective A A idmap
+  := fun x y => idmap.
+
+Global Instance issubgroup_group {G : Group} : IsSubgroup G G
+  := Build_IsSubgroup _ _ grp_homo_id _.
+
+Definition trivial_subgroup {G} : Subgroup G
+  := Build_Subgroup G TrivialAbGroup _.
+
+Definition trivial_subgroup' {G} : Subgroup G
+  := Build_Subgroup G G _.
+
+Section Examples.
+
+  Context (R : CRing).
+
+  (** The zero ideal is an ideal *)
+  Global Instance isideal_trivial_subgroup
+    : IsIdeal (R:=R) trivial_subgroup.
+  Proof.
+    split.
+    intros r [].
+    exists tt.
+    refine (_ @ _^ @ ap _ _^).
+    1,3: rapply grp_homo_unit.
+    apply rng_mult_zero_r.
+  Defined.
+
+  (** Zero ideal *)
+  Definition ideal_zero : Ideal R
+    := Build_Ideal R _ isideal_trivial_subgroup.
+
+  (** The unit ideal is an ideal *)
+  Global Instance isideal_trivial_subgroup'
+    : IsIdeal (R:=R) trivial_subgroup'.
+  Proof.
+    split.
+    cbn; intros r r'.
+    exists (r * r').
+    reflexivity.
+  Defined.
+
+  (** Unit ideal *)
+  Definition ideal_unit : Ideal R
+    := Build_Ideal R _ isideal_trivial_subgroup'.
+
+(** TODO: Intersection of ideals *)
+
+(** TODO: Sum of ideals *)
+
+(** TODO: Product of ideals *)
+
+End Examples.
+
+Definition ideal_kernel {R S : CRing} (f : CRingHomomorphism R S) : Ideal R.
+Proof.
+  snrapply Build_Ideal.
+  1: exact (grp_kernel f).
+  snrapply Build_IsIdeal.
+  intros r x.
+  simpl in x.
+  unfold hfiber in x.
+  srefine (_;_).
+  { exists (r * x.1).
+    refine (rng_homo_mult f _ _ @ _).
+    refine (ap _ _ @ rng_mult_zero_r (f r)).
+    exact x.2. }
+  reflexivity.
+Defined.
+
+(** Properties of ideals *)
+
+(** TODO: Maximal ideals *)
+(** TODO: Principal ideal *)
+(** TODO: Prime ideals *)
+(** TODO: Radical ideals *)
+(** TODO: Minimal ideals *)
+(** TODO: Primary ideals *)
+
-- 
2.29.1


From 3c0e80ad48e7df69d4a2303acbced97ad6da3e8a Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Fri, 3 Jul 2020 18:35:24 +0100
Subject: [PATCH 49/76] quotient ring

---
 theories/Algebra/Rings/QuotientRing.v | 163 ++++++++++++++++++++++++++
 1 file changed, 163 insertions(+)
 create mode 100644 theories/Algebra/Rings/QuotientRing.v

diff --git a/theories/Algebra/Rings/QuotientRing.v b/theories/Algebra/Rings/QuotientRing.v
new file mode 100644
index 0000000000..eebfc19729
--- /dev/null
+++ b/theories/Algebra/Rings/QuotientRing.v
@@ -0,0 +1,163 @@
+Require Import Basics Types WildCat.
+Require Import Algebra.Congruence.
+Require Import Algebra.AbGroups.
+Require Import Algebra.Rings.CRing.
+Require Import Algebra.Rings.Ideal.
+
+(** In this file we define the quotient of a commuative ring by an ideal *)
+
+Section QuotientRing.
+
+  Context (R : CRing) (I : Ideal R).
+
+  Instance plus_quotient_group : Plus (QuotientGroup R I) := group_sgop.
+
+  Instance iscong_mult_incosetL
+    : @IsCongruence R cring_mult (@in_cosetL R I _).
+  Proof.
+    snrapply Build_IsCongruence.
+    intros x x' y y' [i p] [j q].
+    change (issubgroup_incl (H:=R) i = (- x) + x') in p.
+    change (issubgroup_incl (H:=R) j = (- y) + y') in q.
+    unfold in_cosetL, hfiber.
+    change {m : I & issubgroup_incl (H:=R) m = - (x * y) + (x' * y')}.
+    rewrite <- (left_identity (op:=(+)) (x' * y') : 0 + (x' * y') = x' * y').
+    rewrite <- (right_inverse (op:=(+)) (x' * y) : (x' * y) - (x' * y) = 0).
+    rewrite 2 simple_associativity.
+    rewrite negate_mult_distr_l.
+    rewrite <- simple_distribute_r.
+    rewrite <- simple_associativity.
+    rewrite negate_mult_distr_r.
+    rewrite <- simple_distribute_l.
+    rewrite <- p, <- q.
+    pose (isideal x' j) as s; destruct s as [s s'].
+    pose (isideal y i) as t; destruct t as [t t'].
+    rewrite (commutativity _ y).
+    rewrite <- s', <- t'.
+    exists (sg_op t s).
+    rapply grp_homo_op.
+  Defined.
+
+  Instance mult_quotient_group : Mult (QuotientGroup R I).
+  Proof.
+    intro x.
+    srapply Quotient_rec.
+    { intro y; revert x.
+      srapply Quotient_rec.
+      { intro x.
+        apply class_of.
+        exact (x * y). }
+      intros x x' p.
+      apply qglue.
+      by rapply iscong. }
+    intros y y' q.
+    revert x.
+    srapply Quotient_ind_hprop.
+    intro x.
+    simpl.
+    apply qglue.
+    by rapply iscong.
+  Defined.
+
+  Instance zero_quotient_abgroup : Zero (QuotientGroup R I) := class_of _ zero.
+  Instance one_quotient_abgroup : One (QuotientGroup R I) := class_of _ one.
+
+  Instance isring_quotient_abgroup : IsRing (QuotientGroup R I).
+  Proof.
+    split.
+    1: exact _.
+    1: repeat split.
+    1: exact _.
+    (** Associativity follows from the underlying operation *)
+    { intros x y.
+      snrapply Quotient_ind_hprop; [exact _ | intro z; revert y].
+      snrapply Quotient_ind_hprop; [exact _ | intro y; revert x].
+      snrapply Quotient_ind_hprop; [exact _ | intro x ].
+      unfold sg_op, mult_is_sg_op, mult_quotient_group; simpl.
+      apply ap.
+      apply associativity. }
+    (* Left and right identity follow from the underlying structure *)
+    1,2: snrapply Quotient_ind_hprop; [exact _ | intro x].
+    1-2: unfold sg_op, mult_is_sg_op, mult_quotient_group; simpl.
+    1-2: apply ap.
+    1: apply left_identity.
+    1: apply right_identity.
+    (** Commutativity also follows *)
+    { intros x.
+      snrapply Quotient_ind_hprop; [exact _ | intro y; revert x].
+      snrapply Quotient_ind_hprop; [exact _ | intro x].
+      unfold sg_op, mult_is_sg_op, mult_quotient_group; simpl.
+      apply ap.
+      apply commutativity. }
+    (** Finally distributivity also follows *)
+    { intros x y.
+      snrapply Quotient_ind_hprop; [exact _ | intro z; revert y].
+      snrapply Quotient_ind_hprop; [exact _ | intro y; revert x].
+      snrapply Quotient_ind_hprop; [exact _ | intro x ].
+      unfold sg_op, mult_is_sg_op, mult_quotient_group,
+        plus, mult, plus_quotient_group; simpl.
+      apply ap.
+      apply simple_distribute_l. }
+  Defined.
+
+  Definition QuotientRing : CRing 
+    := Build_CRing (QuotientGroup R I) _ _ _ _ _ _.
+
+End QuotientRing.
+
+(** Here is an alternative way to build a commutative ring using the underlying abelian group. *)
+Definition Build_CRing' (R : AbGroup)
+  `(Mult R, One R, LeftDistribute R mult (abgroup_sgop R))
+  (iscomm : @IsCommutativeMonoid R mult one)
+  : CRing
+  := Build_CRing R (abgroup_sgop R) _ (abgroup_unit R) _
+       (abgroup_inverse R) (Build_IsRing _ _ _ _).
+
+(** The image of a ring homomorphism *)
+Definition rng_image {R S : CRing} (f : CRingHomomorphism R S) : CRing.
+Proof.
+  snrapply (Build_CRing' (abgroup_image f)).
+  { simpl.
+    intros [x p] [y q].
+    exists (x * y).
+    strip_truncations; apply tr.
+    destruct p as [p p'], q as [q q'].
+    exists (p * q).
+    refine (rng_homo_mult _ _ _ @ _).
+    f_ap. }
+  { exists 1.
+    apply tr.
+    exists 1.
+    exact (rng_homo_one f). }
+  (** Much of this proof is doing the same thing over, so we use some compact tactics. *)
+  2: repeat split.
+  2: exact _.
+  all: intros [].
+  1,2,5: intros [].
+  1,2: intros [].
+  all: apply path_sigma_hprop; cbn.
+  1: apply distribute_l.
+  1: apply associativity.
+  1: apply commutativity.
+  1: apply left_identity.
+  apply right_identity.
+Defined.
+
+(** TODO: why is this taking so long? *)
+(** First isomorphism theorem for commutative rings *)
+Definition rng_first_iso `{Funext} {A B : CRing} (phi : A $-> B)
+  : CRingIsomorphism (QuotientRing A (ideal_kernel phi)) (rng_image phi).
+ Proof.
+  snrapply Build_CRingIsomorphism''.
+  { etransitivity.
+    2: exact (grp_first_iso phi).
+    apply grp_iso_quotient_normal. }
+  split.
+  { intros x.
+    srapply Quotient_ind_hprop; intro y; revert x.
+    srapply Quotient_ind_hprop; intro x.
+    srapply path_sigma_hprop.
+    exact (rng_homo_mult _ _ _). }
+  srapply path_sigma_hprop.
+  exact (rng_homo_one _).
+Defined.
-- 
2.29.1


From 79b5cbe952181cb9681abdcd3953dd16e0513f70 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Fri, 3 Jul 2020 18:50:50 +0100
Subject: [PATCH 50/76] the integers form a commutative ring

---
 theories/Algebra/Rings/Z.v | 235 +++++++++++++++++++++++++++++++++++++
 theories/Spaces/Int/Spec.v |  88 ++++++++++++++
 theories/Spaces/Pos/Core.v |   9 ++
 theories/Spaces/Pos/Spec.v |  69 ++++++++++-
 4 files changed, 400 insertions(+), 1 deletion(-)
 create mode 100644 theories/Algebra/Rings/Z.v

diff --git a/theories/Algebra/Rings/Z.v b/theories/Algebra/Rings/Z.v
new file mode 100644
index 0000000000..bfc7317de2
--- /dev/null
+++ b/theories/Algebra/Rings/Z.v
@@ -0,0 +1,235 @@
+Require Import Basics Types.
+Require Import Algebra.AbGroups.
+Require Import Algebra.Rings.CRing.
+Require Import Spaces.Int Spaces.Pos.
+Require Import WildCat.
+
+(** The ring of integers *)
+Definition cring_Z : CRing.
+Proof.
+  snrapply (Build_CRing abgroup_Z).
+  6: split; [exact _ | repeat split | ].
+  + (** Multiplication *)
+    exact int_mul.
+  + (** Multiplicative unit *)
+    exact 1%int.
+  + (** IsHSet *)
+    exact _.
+  + (** Associativity of multiplication *)
+    exact int_mul_assoc.
+  + (** Left identity *)
+    exact int_mul_1_l.
+  + (** Right identity *)
+    exact int_mul_1_r.
+  + (** Commutativity of integer multiplication *)
+    exact int_mul_comm.
+  + (** Left distributivity *)
+    exact int_mul_add_distr_l.
+Defined.
+
+Local Open Scope mc_scope.
+
+(** Standard integer operations on commutative rings *)
+Definition cring_int_mul (R : CRing) (z : cring_Z) : R
+  := match z with
+     | neg z => pos_peano_rec R (-1) (fun n nr => -1 + nr) z
+     | 0%int => 0
+     | pos z => pos_peano_rec R 1 (fun n nr => 1 + nr) z
+     end.
+
+(** TODO: clean up *)
+(** Preservation of + *)
+Global Instance issemigrouppreserving_cring_int_mul_plus (R : CRing)
+  : IsSemiGroupPreserving (Aop:=cring_plus) (Bop:=cring_plus)
+      (cring_int_mul R : cring_Z -> R).
+Proof.
+  (** Unfortunately, due to how we have defined things we need to seperate this out into 9 cases. *)
+  hnf. intros [x| |x] [y| |y].
+  (** Some of these cases are easy however *)
+  2,5,8: cbn; by rewrite right_identity.
+  3,4: symmetry; apply left_identity.
+  (** This leaves us with four cases to consider *)
+  (** x < 0 , y < 0 *)
+  { change (cring_int_mul R ((neg x) + (neg y))%int
+      = (cring_int_mul R (neg x)) + (cring_int_mul R (neg y))).
+    induction y as [|y IHy] using pos_peano_ind.
+    { simpl.
+      rewrite pos_add_1_r.
+      rewrite pos_peano_rec_beta_pos_succ.
+      apply commutativity. }
+    simpl.
+    rewrite pos_add_succ_r.
+    rewrite 2 pos_peano_rec_beta_pos_succ.
+    rewrite simple_associativity.
+    rewrite (commutativity _ (-1)).
+    rewrite <- simple_associativity.
+    f_ap. }
+  (** x < 0 , y > 0 *)
+  { cbn.
+    revert x.
+    induction y as [|y IHy] using pos_peano_ind; intro x.
+    { cbn.
+      induction x as [|x] using pos_peano_ind.
+      1: symmetry; cbn; apply left_inverse.
+      rewrite pos_peano_rec_beta_pos_succ.
+      rewrite int_pos_sub_succ_r.
+      cbn; rewrite <- simple_associativity.
+      apply moveL_equiv_M.
+      cbn; rewrite involutive.
+      apply commutativity. }
+    induction x as [|x IHx] using pos_peano_ind.
+    { rewrite int_pos_sub_succ_l.
+      cbn; apply moveL_equiv_M.
+      cbn; rewrite involutive.
+      by rewrite pos_peano_rec_beta_pos_succ. }
+    rewrite int_pos_sub_succ_succ.
+    rewrite IHy.
+    rewrite 2 pos_peano_rec_beta_pos_succ.
+    rewrite (commutativity (-1)).
+    rewrite simple_associativity.
+    rewrite <- (simple_associativity _ _ 1).
+    rewrite left_inverse.
+    f_ap.
+    symmetry.
+    apply right_identity. }
+  - cbn.
+    revert x.
+    induction y as [|y IHy] using pos_peano_ind; intro x.
+    { induction x as [|x] using pos_peano_ind.
+      1: symmetry; cbn; apply right_inverse.
+      rewrite pos_peano_rec_beta_pos_succ.
+      rewrite (commutativity 1).
+      rewrite <- simple_associativity.
+      rewrite int_pos_sub_succ_l.
+      cbn; by rewrite right_inverse, right_identity. }
+    induction x as [|x IHx] using pos_peano_ind.
+    { rewrite int_pos_sub_succ_r.
+      rewrite pos_peano_rec_beta_pos_succ.
+      rewrite simple_associativity.
+      cbn.
+      rewrite (right_inverse 1).
+      symmetry.
+      apply left_identity. }
+    rewrite int_pos_sub_succ_succ.
+    rewrite IHy.
+    rewrite 2 pos_peano_rec_beta_pos_succ.
+    rewrite (commutativity 1).
+    rewrite simple_associativity.
+    rewrite <- (simple_associativity _ _ (-1)).
+    rewrite (right_inverse 1).
+    f_ap; symmetry.
+    apply right_identity.
+  - cbn.
+    induction y as [|y IHy] using pos_peano_ind.
+    { cbn.
+      rewrite pos_add_1_r.
+      rewrite pos_peano_rec_beta_pos_succ.
+      apply commutativity. }
+    rewrite pos_add_succ_r.
+    rewrite 2 pos_peano_rec_beta_pos_succ.
+    rewrite simple_associativity.
+    rewrite IHy.
+    rewrite simple_associativity.
+    rewrite (commutativity 1).
+    reflexivity.
+Qed.
+
+Lemma cring_int_mul_negate {R} x
+  : cring_int_mul R (- x) = - cring_int_mul R x.
+Proof.
+  snrapply (groups.preserves_negate _).
+  1-6: exact _.
+  snrapply Build_IsMonoidPreserving.
+  1: exact _.
+  split.
+Defined.
+
+Lemma cring_int_mul_pos_mult {R} x y
+  : cring_int_mul R (pos x * pos y)%int
+    = cring_int_mul R (pos x) * cring_int_mul R (pos y).
+Proof.
+  revert y.
+  induction x as [|x IHx] using pos_peano_ind; intro y.
+  { symmetry.
+    apply left_identity. }
+  change (cring_int_mul R (pos (pos_succ x * y)%pos)
+    = cring_int_mul R (pos (pos_succ x)) * cring_int_mul R (pos y)).
+  rewrite pos_mul_succ_l.
+  change (cring_int_mul R ((pos (x * y)%pos : cring_Z) + pos y)
+    = cring_int_mul R (pos (pos_succ x)) * cring_int_mul R (pos y)).
+  refine (issemigrouppreserving_cring_int_mul_plus
+    R (pos (x * y)%pos) (pos y) @ _).
+  change (cring_int_mul R (pos (x * y)%pos) + cring_int_mul R (pos y)
+    = cring_int_mul R (pos (pos_succ x)) * cring_int_mul R (pos y)).
+  rewrite IHx.
+  transitivity ((1 + cring_int_mul R (pos x)) * cring_int_mul R (pos y)).
+  2: simpl; by rewrite pos_peano_rec_beta_pos_succ.
+  rewrite rng_dist_r.
+  rewrite rng_mult_one_l.
+  apply commutativity.
+Qed.
+
+(** Preservation of * *)
+Global Instance issemigrouppreserving_cring_int_mul_mult (R : CRing)
+  : IsSemiGroupPreserving (Aop:=cring_mult) (Bop:=cring_mult)
+      (cring_int_mul R : cring_Z -> R).
+Proof.
+  hnf. intros [x| |x] [y| |y].
+  2,5,8: symmetry; apply rng_mult_zero_r.
+  3,4: cbn; symmetry; rewrite (commutativity 0); apply rng_mult_zero_r.
+  { change (cring_int_mul R (pos (x * y)%pos)
+      = cring_int_mul R (- (pos x : cring_Z))
+        * cring_int_mul R (- (pos y : cring_Z))).
+    by rewrite 2 cring_int_mul_negate, cring_int_mul_pos_mult,
+      rng_mult_negate_negate. }
+  { change (cring_int_mul R (- (pos (x * y)%pos : cring_Z))
+      = cring_int_mul R (- (pos x : cring_Z))
+        * cring_int_mul R (pos y)).
+    by rewrite 2 cring_int_mul_negate, cring_int_mul_pos_mult, rng_mult_negate_l. }
+  { change (cring_int_mul R (- (pos (x * y)%pos : cring_Z))
+      = cring_int_mul R (pos x)
+        * cring_int_mul R (- (pos y : cring_Z))).
+    by rewrite 2 cring_int_mul_negate, cring_int_mul_pos_mult, rng_mult_negate_r. }
+  apply cring_int_mul_pos_mult.
+Qed.
+
+(** This is a ring homomorphism *)
+Definition rng_homo_int (R : CRing) : cring_Z $-> R.
+Proof.
+  snrapply Build_CRingHomomorphism.
+  1: exact (cring_int_mul R).
+  repeat split; exact _.
+Defined.
+
+(** The integers are the initial commutative ring *)
+Global Instance isinitial_cring_Z : IsInitial cring_Z.
+Proof.
+  unfold IsInitial.
+  intro R.
+  exists (rng_homo_int R).
+  intros g x.
+  destruct x as [n| |p].
+  + induction n using pos_peano_ind.
+    { cbn. rapply rng_homo_minus_one. }
+    simpl.
+    rewrite pos_peano_rec_beta_pos_succ.
+    rewrite int_neg_pos_succ.
+    unfold int_pred.
+    rewrite int_add_comm.
+    rewrite rng_homo_plus.
+    rewrite rng_homo_minus_one.
+    apply ap.
+    exact IHn.
+  + by rewrite 2 rng_homo_zero.
+  + induction p using pos_peano_ind.
+    { cbn. rapply rng_homo_one. }
+    simpl.
+    rewrite pos_peano_rec_beta_pos_succ.
+    rewrite int_pos_pos_succ.
+    unfold int_succ.
+    rewrite int_add_comm.
+    rewrite rng_homo_plus.
+    rewrite rng_homo_one.
+    apply ap.
+    exact IHp.
+Defined.
diff --git a/theories/Spaces/Int/Spec.v b/theories/Spaces/Int/Spec.v
index f12ad1f63e..b7e07f6237 100644
--- a/theories/Spaces/Int/Spec.v
+++ b/theories/Spaces/Int/Spec.v
@@ -70,6 +70,12 @@ Proof.
   by destruct p.
 Qed.
 
+(** ** Permutation of pos and pos_succ *)
+Lemma int_pos_pos_succ p : pos (pos_succ p) = int_succ (pos p).
+Proof.
+  by destruct p.
+Qed.
+
 (** ** Negation of a doubled positive integer *)
 Lemma int_negation_double a
   : - (int_double a) = int_double (- a).
@@ -347,3 +353,85 @@ Global Instance isequiv_int_succ : IsEquiv int_succ | 0
 
 Definition equiv_int_succ : Int <~> Int
   := Build_Equiv _ _ _ isequiv_int_succ.
+
+(** ** Commutativity of multplication *)
+Lemma int_mul_comm n m : n * m = m * n.
+Proof.
+  destruct n, m; cbn; try reflexivity;
+  apply ap; apply pos_mul_comm.
+Qed.
+
+(** Distributivity of multiplication over addition *)
+
+Lemma int_pos_sub_mul_pos n m p
+  : int_pos_sub n m * pos p = int_pos_sub (n * p)%pos (m * p)%pos.
+Proof.
+  rewrite int_mul_comm.
+  rewrite 2 (pos_mul_comm _ p).
+  induction p.
+  { rewrite 2 pos_mul_1_l.
+    apply int_mul_1_l. }
+  { cbn.
+    rewrite <- IHp.
+    set (int_pos_sub n m) as k.
+    by destruct k. }
+  cbn.
+  rewrite int_pos_sub_add.
+  rewrite <- (int_pos_sub_negation _ (x0 _)).
+  rewrite int_pos_sub_add.
+  rewrite int_negation_add_distr.
+  rewrite int_pos_sub_negation.
+  rewrite int_add_assoc.
+  cbn.
+  rewrite <- IHp.
+  set (int_pos_sub n m) as k.
+  by destruct k.
+Qed.
+
+Lemma int_pos_sub_mul_neg n m p
+  : int_pos_sub m n  * neg p = int_pos_sub (n * p)%pos (m * p)%pos.
+Proof.
+  rewrite int_mul_comm.
+  rewrite 2 (pos_mul_comm _ p).
+  induction p.
+  { rewrite 2 pos_mul_1_l.
+    rewrite <- int_pos_sub_negation.
+    by destruct (int_pos_sub n m). }
+  { cbn.
+    rewrite <- IHp.
+    rewrite <- int_pos_sub_negation.
+    set (int_pos_sub n m) as k.
+    by destruct k. }
+  cbn.
+  rewrite int_pos_sub_add.
+  rewrite <- (int_pos_sub_negation _ (x0 _)).
+  rewrite int_pos_sub_add.
+  rewrite int_negation_add_distr.
+  rewrite int_pos_sub_negation.
+  rewrite int_add_assoc.
+  cbn.
+  rewrite <- IHp.
+  rewrite <- (int_pos_sub_negation m).
+  set (int_pos_sub m n) as k.
+  by destruct k.
+Qed.
+
+Lemma int_mul_add_distr_r n m p : (n + m) * p = n * p + m * p.
+Proof.
+  induction p; destruct n, m; cbn; trivial; try f_ap;
+  try apply pos_mul_add_distr_r;
+  try apply int_pos_sub_mul_neg;
+  try apply int_pos_sub_mul_pos;
+  apply int_mul_0_r.
+Qed.
+
+Lemma int_mul_add_distr_l n m p : n * (m + p) = n * m + n * p.
+Proof.
+  rewrite 3 (int_mul_comm n); apply int_mul_add_distr_r.
+Qed.
+
+Lemma int_mul_assoc n m p : n * (m * p) = n * m * p.
+Proof.
+  destruct n, m, p; cbn; trivial; f_ap; apply pos_mul_assoc.
+Qed.
+
diff --git a/theories/Spaces/Pos/Core.v b/theories/Spaces/Pos/Core.v
index 71e783f2c4..87650572b0 100644
--- a/theories/Spaces/Pos/Core.v
+++ b/theories/Spaces/Pos/Core.v
@@ -56,6 +56,15 @@ Proof.
   srapply IHp.
 Qed.
 
+Definition pos_peano_rec (P : Type)
+  : P -> (Pos -> P -> P) -> Pos -> P
+  := pos_peano_ind (fun _ => P).
+
+Definition pos_peano_rec_beta_pos_succ (P : Type)
+  (a : P) (f : Pos -> P -> P) (p : Pos)
+  : pos_peano_rec P a f (pos_succ p) = f p (pos_peano_rec P a f p)
+  := pos_peano_ind_beta_pos_succ (fun _ => P) a f p.
+
 (** ** Properties of constructors *)
 
 Definition x0_inj {z w : Pos} (p : x0 z = x0 w) : z = w
diff --git a/theories/Spaces/Pos/Spec.v b/theories/Spaces/Pos/Spec.v
index e31ac1e415..e55c1c4576 100644
--- a/theories/Spaces/Pos/Spec.v
+++ b/theories/Spaces/Pos/Spec.v
@@ -23,7 +23,7 @@ Proof.
   induction p; destruct q; simpl; by apply ap.
 Qed.
 
-(** ** Commutativity *)
+(** ** Commutativity of [add] *)
 
 Theorem pos_add_comm p q : p + q = q + p.
 Proof.
@@ -204,3 +204,70 @@ Proof.
   apply q.
 Qed.
 
+(** ** Right reduction properties for multiplication *)
+Lemma mul_xO_r p q : p * q~0 = (p * q)~0.
+Proof.
+  induction p; simpl; f_ap; f_ap; trivial.
+Qed.
+
+Lemma mul_xI_r p q : p * q~1 = p + (p * q)~0.
+Proof.
+  induction p; simpl; trivial; f_ap.
+  rewrite IHp.
+  rewrite pos_add_assoc.
+  rewrite (pos_add_comm q p).
+  symmetry.
+  apply pos_add_assoc.
+Qed.
+
+(** ** Commutativity of multiplication *)
+Lemma pos_mul_comm p q : p * q = q * p.
+Proof.
+  induction q; simpl.
+  1: apply pos_mul_1_r.
+  + rewrite mul_xO_r.
+    f_ap.
+  + rewrite mul_xI_r.
+    f_ap; f_ap.
+Qed.
+
+(** ** Distributivity of addition over multiplication *)
+Theorem pos_mul_add_distr_l p q r :
+  p * (q + r) = p * q + p * r.
+Proof.
+  induction p; cbn; [reflexivity | f_ap | ].
+  rewrite IHp.
+  set (m:=(p*q)~0).
+  set (n:=(p*r)~0).
+  change ((p*q+p*r)~0) with (m+n).
+  rewrite 2 pos_add_assoc; f_ap.
+  rewrite <- 2 pos_add_assoc; f_ap.
+  apply pos_add_comm.
+Qed.
+
+Theorem pos_mul_add_distr_r p q r :
+  (p + q) * r = p * r + q * r.
+Proof.
+  rewrite 3 (pos_mul_comm _ r); apply pos_mul_add_distr_l.
+Qed.
+
+(** ** Associativity of multiplication *)
+Theorem pos_mul_assoc p q r : p * (q * r) = p * q * r.
+Proof.
+  induction p; simpl; rewrite ?IHp; trivial.
+  by rewrite pos_mul_add_distr_r.
+Qed.
+
+(** ** pos_succ and pos_mul *)
+
+Lemma pos_mul_succ_l p q
+  : (pos_succ p) * q = p * q + q.
+Proof.
+  by rewrite <- pos_add_1_r, pos_mul_add_distr_r, pos_mul_1_l.
+Qed.
+
+Lemma pos_mul_succ_r p q
+  : p * (pos_succ q) = p + p * q.
+Proof.
+  by rewrite <- pos_add_1_l, pos_mul_add_distr_l, pos_mul_1_r.
+Qed.
-- 
2.29.1


From 6bfbdfeaeacc175759827fa847a7f3e91fa2ffec Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Fri, 3 Jul 2020 18:51:20 +0100
Subject: [PATCH 51/76] indexing files and compatibility for rings library

---
 _CoqProject                                    |  6 ++++++
 theories/Algebra/Rings.v                       |  8 ++++++++
 theories/Classes/interfaces/abstract_algebra.v | 13 +++++++++++++
 theories/HoTT.v                                |  1 +
 4 files changed, 28 insertions(+)
 create mode 100644 theories/Algebra/Rings.v

diff --git a/_CoqProject b/_CoqProject
index 559ce0d18e..836ef1a466 100644
--- a/_CoqProject
+++ b/_CoqProject
@@ -335,6 +335,12 @@ theories/Algebra/ooAction.v
 
 theories/Algebra/Congruence.v
 
+theories/Algebra/Rings.v
+theories/Algebra/Rings/CRing.v
+theories/Algebra/Rings/Ideal.v
+theories/Algebra/Rings/QuotientRing.v
+theories/Algebra/Rings/Z.v
+
 theories/Algebra/AbGroups.v
 theories/Algebra/AbGroups/AbelianGroup.v
 theories/Algebra/AbGroups/Abelianization.v
diff --git a/theories/Algebra/Rings.v b/theories/Algebra/Rings.v
new file mode 100644
index 0000000000..91605a6370
--- /dev/null
+++ b/theories/Algebra/Rings.v
@@ -0,0 +1,8 @@
+(** Basic theory *)
+
+Require Export HoTT.Algebra.Rings.CRing.
+Require Export HoTT.Algebra.Rings.Ideal.
+
+(** Examples *)
+
+Require Export HoTT.Algebra.Rings.Z.
\ No newline at end of file
diff --git a/theories/Classes/interfaces/abstract_algebra.v b/theories/Classes/interfaces/abstract_algebra.v
index f72a289ce4..6dd9851750 100644
--- a/theories/Classes/interfaces/abstract_algebra.v
+++ b/theories/Classes/interfaces/abstract_algebra.v
@@ -298,6 +298,10 @@ Proof.
   unfold IsSemiGroupPreserving; exact _.
 Defined.
 
+Definition issig_IsSemiRingPreserving {A B : Type}
+  `{Plus A, Plus B, Mult A, Mult B, Zero A, Zero B, One A, One B} {f : A -> B}
+  : _ <~> IsSemiRingPreserving f := ltac:(issig).
+
 Definition issig_IsMonoidPreserving {A B : Type} `{SgOp A} `{SgOp B}
   `{MonUnit A} `{MonUnit B} {f : A -> B} : _ <~> IsMonoidPreserving f
   := ltac:(issig).
@@ -313,6 +317,15 @@ Proof.
   exact _.
 Defined.
 
+Global Instance ishprop_issemiringpreserving `{Funext} {A B : Type} `{IsHSet B}
+  `{Plus A, Plus B, Mult A, Mult B, Zero A, Zero B, One A, One B}
+  (f : A -> B)
+  : IsHProp (IsSemiRingPreserving f).
+Proof.
+  snrapply (trunc_equiv' _ issig_IsSemiRingPreserving).
+  exact _.
+Defined.
+
 Definition issig_issemigroup x y : _ <~> @IsSemiGroup x y := ltac:(issig).
 
 Global Instance ishprop_issemigroup `{Funext}
diff --git a/theories/HoTT.v b/theories/HoTT.v
index 643e56908a..77366fe720 100644
--- a/theories/HoTT.v
+++ b/theories/HoTT.v
@@ -123,6 +123,7 @@ Require Export HoTT.Algebra.Aut.
 Require Export HoTT.Algebra.ooAction.
 Require Export HoTT.Algebra.AbGroups.
 Require Export HoTT.Algebra.Groups.
+Require Export HoTT.Algebra.Rings.
 
 Require Export HoTT.Homotopy.HomotopyGroup.
 Require Export HoTT.Homotopy.Pi1S1.
-- 
2.29.1


From 2acaa79ab7db3e13212b60e80185caa5976f6f28 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Mon, 13 Jul 2020 10:12:01 +0100
Subject: [PATCH 52/76] changed TrivialAbGroup to abgroup_trivial in Ideal.v

---
 theories/Algebra/Rings/Ideal.v | 13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)

diff --git a/theories/Algebra/Rings/Ideal.v b/theories/Algebra/Rings/Ideal.v
index c41002e078..4d0f91879d 100644
--- a/theories/Algebra/Rings/Ideal.v
+++ b/theories/Algebra/Rings/Ideal.v
@@ -6,7 +6,7 @@ Local Open Scope mc_scope.
 
 (** In this file we define Ideals *)
 
-(** TODO: In the future it might be useful to define ideals as submodules *)
+(** TODO: In the future it might be useful to define ideals as submodules when we go about defining R-modules. *)
 
 (** An additive subgroup I of a ring R is an ideal when: *)
 Class IsIdeal {R : CRing} (I : Subgroup R) := {
@@ -23,8 +23,8 @@ Record Ideal (R : CRing) := {
 Coercion ideal_subgroup : Ideal >-> Subgroup.
 Global Existing Instances ideal_isideal.
 
-
-Global Instance issubgroup_trivial {G : Group} : IsSubgroup TrivialAbGroup G.
+(** TODO: Move to Group.v *)
+Global Instance issubgroup_trivial {G : Group} : IsSubgroup abgroup_trivial G.
 Proof.
   snrapply Build_IsSubgroup.
   { snrapply (Build_GroupHomomorphism (fun _ => group_unit)).
@@ -33,15 +33,20 @@ Proof.
   apply path_unit.
 Defined.
 
+(** TODO: Move somewhere more useful *)
 Global Instance isinj_idmap A : @IsInjective A A idmap
   := fun x y => idmap.
 
+(** TODO: Move to Subgroup.v *)
 Global Instance issubgroup_group {G : Group} : IsSubgroup G G
   := Build_IsSubgroup _ _ grp_homo_id _.
 
+(** TODO: Move to Subgroup.v *)
 Definition trivial_subgroup {G} : Subgroup G
-  := Build_Subgroup G TrivialAbGroup _.
+  := Build_Subgroup G abgroup_trivial _.
 
+(** TODO: Move to Subgroup.v *)
+(** TODO: Rename? *)
 Definition trivial_subgroup' {G} : Subgroup G
   := Build_Subgroup G G _.
 
-- 
2.29.1


From 81c77e969a9a66d16a44b3051217d7c1bd9645a8 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Fri, 21 Aug 2020 15:25:50 +0100
Subject: [PATCH 53/76] small cleanup in Rings

---
 theories/Algebra/Rings.v       | 2 +-
 theories/Algebra/Rings/CRing.v | 5 +----
 2 files changed, 2 insertions(+), 5 deletions(-)

diff --git a/theories/Algebra/Rings.v b/theories/Algebra/Rings.v
index 91605a6370..728a2358ac 100644
--- a/theories/Algebra/Rings.v
+++ b/theories/Algebra/Rings.v
@@ -5,4 +5,4 @@ Require Export HoTT.Algebra.Rings.Ideal.
 
 (** Examples *)
 
-Require Export HoTT.Algebra.Rings.Z.
\ No newline at end of file
+Require Export HoTT.Algebra.Rings.Z.
diff --git a/theories/Algebra/Rings/CRing.v b/theories/Algebra/Rings/CRing.v
index e5912be472..000429459c 100644
--- a/theories/Algebra/Rings/CRing.v
+++ b/theories/Algebra/Rings/CRing.v
@@ -5,9 +5,7 @@ Require Export Classes.theory.rings.
 
 (** Theory of commutative rings *)
 
-(** TODO: in reality we should really develop the theory of non-commutative rings seperately, and have commutative rings as a special case of that theory. Similar to how we have Group and AbGroup.
-
-But since we are only interested in commutative rings for the time being, it makes sense to only consider them.
+(** TODO: in reality we should really develop the theory of non-commutative rings seperately, and have commutative rings as a special case of that theory. Similar to how we have Group and AbGroup. But since we are only interested in commutative rings for the time being, it makes sense to only consider them.
 *)
 
 (** A commutative ring consists of the following data *)
@@ -243,4 +241,3 @@ Proof.
   + intros G H f g p q.
     exact (isequiv_adjointify f g p q).
 Defined.
-
-- 
2.29.1


From 0ab5967b8975422b843f42b34ee1e4b2e42ccb80 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Fri, 21 Aug 2020 15:30:22 +0100
Subject: [PATCH 54/76] trivial subgroup

---
 theories/Algebra/Groups/Subgroup.v |  9 +++++++++
 theories/Algebra/Rings/Ideal.v     | 10 ----------
 2 files changed, 9 insertions(+), 10 deletions(-)

diff --git a/theories/Algebra/Groups/Subgroup.v b/theories/Algebra/Groups/Subgroup.v
index b249bb5b1f..0ad02c7f74 100644
--- a/theories/Algebra/Groups/Subgroup.v
+++ b/theories/Algebra/Groups/Subgroup.v
@@ -304,3 +304,12 @@ Proof.
   2: rewrite (associativity (-y)), (negate_l G y).
   1-2: rewrite (left_identity _); reflexivity.
 Defined.
+
+(** The trivial group is always a subgroup *)
+Global Instance issubgroup_grp_trivial {G : Group} : IsSubgroup grp_trivial G.
+Proof.
+  snrapply Build_IsSubgroup.
+  1: apply grp_trivial_rec.
+  cbn; intros ???.
+  apply path_unit.
+Defined.
diff --git a/theories/Algebra/Rings/Ideal.v b/theories/Algebra/Rings/Ideal.v
index 4d0f91879d..6873ab13ae 100644
--- a/theories/Algebra/Rings/Ideal.v
+++ b/theories/Algebra/Rings/Ideal.v
@@ -23,16 +23,6 @@ Record Ideal (R : CRing) := {
 Coercion ideal_subgroup : Ideal >-> Subgroup.
 Global Existing Instances ideal_isideal.
 
-(** TODO: Move to Group.v *)
-Global Instance issubgroup_trivial {G : Group} : IsSubgroup abgroup_trivial G.
-Proof.
-  snrapply Build_IsSubgroup.
-  { snrapply (Build_GroupHomomorphism (fun _ => group_unit)).
-    intros ??; symmetry; apply left_identity. }
-  cbn; intros ???.
-  apply path_unit.
-Defined.
-
 (** TODO: Move somewhere more useful *)
 Global Instance isinj_idmap A : @IsInjective A A idmap
   := fun x y => idmap.
-- 
2.29.1


From f6c004a459cab22bfbf3e6f33ed5cfdca7862968 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Fri, 21 Aug 2020 15:30:48 +0100
Subject: [PATCH 55/76] small cleanup in CRing.v

---
 theories/Algebra/Rings/CRing.v | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/theories/Algebra/Rings/CRing.v b/theories/Algebra/Rings/CRing.v
index 000429459c..981b411901 100644
--- a/theories/Algebra/Rings/CRing.v
+++ b/theories/Algebra/Rings/CRing.v
@@ -5,8 +5,7 @@ Require Export Classes.theory.rings.
 
 (** Theory of commutative rings *)
 
-(** TODO: in reality we should really develop the theory of non-commutative rings seperately, and have commutative rings as a special case of that theory. Similar to how we have Group and AbGroup. But since we are only interested in commutative rings for the time being, it makes sense to only consider them.
-*)
+(** TODO: in reality we should really develop the theory of non-commutative rings seperately, and have commutative rings as a special case of that theory. Similar to how we have Group and AbGroup. But since we are only interested in commutative rings for the time being, it makes sense to only consider them. *)
 
 (** A commutative ring consists of the following data *)
 Record CRing := {
@@ -26,7 +25,6 @@ Record CRing := {
   cring_isring : IsRing cring_type;
 }.
 
-Arguments cring_type {_}.
 Arguments cring_plus {_}.
 Arguments cring_mult {_}.
 Arguments cring_zero {_}.
-- 
2.29.1


From d393a0d8be27095c80cf6f8b1f2a49e1fb8686c6 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Fri, 21 Aug 2020 17:20:54 +0100
Subject: [PATCH 56/76] trivial subgroups

---
 theories/Algebra/Groups/Subgroup.v | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/theories/Algebra/Groups/Subgroup.v b/theories/Algebra/Groups/Subgroup.v
index 0ad02c7f74..05a5bf03e9 100644
--- a/theories/Algebra/Groups/Subgroup.v
+++ b/theories/Algebra/Groups/Subgroup.v
@@ -313,3 +313,17 @@ Proof.
   cbn; intros ???.
   apply path_unit.
 Defined.
+
+(** Every group is a subgroup of itself *)
+(** We make this a low priority instance so it doesn't get picked up before other subgroup instances. *)
+Global Instance issubgroup_group {G : Group} : IsSubgroup G G | 100
+  := Build_IsSubgroup _ _ grp_homo_id _.
+
+(** Trivial subgroup (actual trivial group) *)
+Definition trivial_subgroup {G} : Subgroup G
+  := Build_Subgroup G grp_trivial _.
+
+(** The other trivial subgroup (the actual group itself) *)
+Definition trivial_subgroup' {G} : Subgroup G
+  := Build_Subgroup G G _.
+
-- 
2.29.1


From 3fd42f2fecb6b273a10cd71a323161c621c0e506 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Fri, 21 Aug 2020 17:21:24 +0100
Subject: [PATCH 57/76] idmap is injective

---
 theories/Classes/interfaces/abstract_algebra.v | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/theories/Classes/interfaces/abstract_algebra.v b/theories/Classes/interfaces/abstract_algebra.v
index 6dd9851750..a9c97315a3 100644
--- a/theories/Classes/interfaces/abstract_algebra.v
+++ b/theories/Classes/interfaces/abstract_algebra.v
@@ -275,8 +275,12 @@ Section jections.
     apply injective.
     assumption.
   Qed.
+
 End jections.
 
+Global Instance isinj_idmap A : @IsInjective A A idmap
+  := fun x y => idmap.
+
 Section strong_injective.
   Context {A B} {Aap : Apart A} {Bap : Apart B} (f : A -> B) .
   Class IsStrongInjective :=
-- 
2.29.1


From 835eeb549ca9c307928ed02951d7897b4bf163bb Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Fri, 21 Aug 2020 17:21:33 +0100
Subject: [PATCH 58/76] general cleanup in Algebra

---
 theories/Algebra/Rings/CRing.v        |  2 +-
 theories/Algebra/Rings/Ideal.v        | 19 -------------------
 theories/Algebra/Rings/QuotientRing.v |  3 +--
 theories/Algebra/Rings/Z.v            |  9 +++------
 4 files changed, 5 insertions(+), 28 deletions(-)

diff --git a/theories/Algebra/Rings/CRing.v b/theories/Algebra/Rings/CRing.v
index 981b411901..82e80a08b7 100644
--- a/theories/Algebra/Rings/CRing.v
+++ b/theories/Algebra/Rings/CRing.v
@@ -5,7 +5,7 @@ Require Export Classes.theory.rings.
 
 (** Theory of commutative rings *)
 
-(** TODO: in reality we should really develop the theory of non-commutative rings seperately, and have commutative rings as a special case of that theory. Similar to how we have Group and AbGroup. But since we are only interested in commutative rings for the time being, it makes sense to only consider them. *)
+(** TODO: We should really develop the theory of non-commutative rings seperately, and have commutative rings as a special case of that theory. Similar to how we have Group and AbGroup. But since we are only interested in commutative rings for the time being, it makes sense to only consider them. *)
 
 (** A commutative ring consists of the following data *)
 Record CRing := {
diff --git a/theories/Algebra/Rings/Ideal.v b/theories/Algebra/Rings/Ideal.v
index 6873ab13ae..d553d7c5b3 100644
--- a/theories/Algebra/Rings/Ideal.v
+++ b/theories/Algebra/Rings/Ideal.v
@@ -23,23 +23,6 @@ Record Ideal (R : CRing) := {
 Coercion ideal_subgroup : Ideal >-> Subgroup.
 Global Existing Instances ideal_isideal.
 
-(** TODO: Move somewhere more useful *)
-Global Instance isinj_idmap A : @IsInjective A A idmap
-  := fun x y => idmap.
-
-(** TODO: Move to Subgroup.v *)
-Global Instance issubgroup_group {G : Group} : IsSubgroup G G
-  := Build_IsSubgroup _ _ grp_homo_id _.
-
-(** TODO: Move to Subgroup.v *)
-Definition trivial_subgroup {G} : Subgroup G
-  := Build_Subgroup G abgroup_trivial _.
-
-(** TODO: Move to Subgroup.v *)
-(** TODO: Rename? *)
-Definition trivial_subgroup' {G} : Subgroup G
-  := Build_Subgroup G G _.
-
 Section Examples.
 
   Context (R : CRing).
@@ -75,9 +58,7 @@ Section Examples.
     := Build_Ideal R _ isideal_trivial_subgroup'.
 
 (** TODO: Intersection of ideals *)
-
 (** TODO: Sum of ideals *)
-
 (** TODO: Product of ideals *)
 
 End Examples.
diff --git a/theories/Algebra/Rings/QuotientRing.v b/theories/Algebra/Rings/QuotientRing.v
index eebfc19729..9c4955c91e 100644
--- a/theories/Algebra/Rings/QuotientRing.v
+++ b/theories/Algebra/Rings/QuotientRing.v
@@ -143,11 +143,10 @@ Proof.
   apply right_identity.
 Defined.
 
-(** TODO: why is this taking so long? *)
 (** First isomorphism theorem for commutative rings *)
 Definition rng_first_iso `{Funext} {A B : CRing} (phi : A $-> B)
   : CRingIsomorphism (QuotientRing A (ideal_kernel phi)) (rng_image phi).
- Proof.
+Proof.
   snrapply Build_CRingIsomorphism''.
   { etransitivity.
     2: exact (grp_first_iso phi).
diff --git a/theories/Algebra/Rings/Z.v b/theories/Algebra/Rings/Z.v
index bfc7317de2..15ef7561c4 100644
--- a/theories/Algebra/Rings/Z.v
+++ b/theories/Algebra/Rings/Z.v
@@ -4,6 +4,8 @@ Require Import Algebra.Rings.CRing.
 Require Import Spaces.Int Spaces.Pos.
 Require Import WildCat.
 
+(** In this file we define the ring Z of integers. The underlying abelian group is already defined in Algebra.AbGroups.Z. Many of the ring axioms are proven and made opaque. Typically, everything inside IsRing can be opaque since we will only ever rewrite along them and they are hprops. This also means we don't have to be too careful with how our proofs are structured. This allows us to freely use tactics such as rewrite. It would perhaps be possible to shorten many of the proofs here, but it would probably be unneeded due to the opacicty. *)
+
 (** The ring of integers *)
 Definition cring_Z : CRing.
 Proof.
@@ -37,7 +39,6 @@ Definition cring_int_mul (R : CRing) (z : cring_Z) : R
      | pos z => pos_peano_rec R 1 (fun n nr => 1 + nr) z
      end.
 
-(** TODO: clean up *)
 (** Preservation of + *)
 Global Instance issemigrouppreserving_cring_int_mul_plus (R : CRing)
   : IsSemiGroupPreserving (Aop:=cring_plus) (Bop:=cring_plus)
@@ -155,12 +156,8 @@ Proof.
   change (cring_int_mul R (pos (pos_succ x * y)%pos)
     = cring_int_mul R (pos (pos_succ x)) * cring_int_mul R (pos y)).
   rewrite pos_mul_succ_l.
-  change (cring_int_mul R ((pos (x * y)%pos : cring_Z) + pos y)
-    = cring_int_mul R (pos (pos_succ x)) * cring_int_mul R (pos y)).
   refine (issemigrouppreserving_cring_int_mul_plus
     R (pos (x * y)%pos) (pos y) @ _).
-  change (cring_int_mul R (pos (x * y)%pos) + cring_int_mul R (pos y)
-    = cring_int_mul R (pos (pos_succ x)) * cring_int_mul R (pos y)).
   rewrite IHx.
   transitivity ((1 + cring_int_mul R (pos x)) * cring_int_mul R (pos y)).
   2: simpl; by rewrite pos_peano_rec_beta_pos_succ.
@@ -169,7 +166,7 @@ Proof.
   apply commutativity.
 Qed.
 
-(** Preservation of * *)
+(** Preservation of * (multiplication) *)
 Global Instance issemigrouppreserving_cring_int_mul_mult (R : CRing)
   : IsSemiGroupPreserving (Aop:=cring_mult) (Bop:=cring_mult)
       (cring_int_mul R : cring_Z -> R).
-- 
2.29.1


From 57db0de706dad3ffaf5858f243fa7358d2f51d1e Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Fri, 21 Aug 2020 17:25:45 +0100
Subject: [PATCH 59/76] added QuotientRing.v to index file

---
 theories/Algebra/Rings.v | 1 +
 1 file changed, 1 insertion(+)

diff --git a/theories/Algebra/Rings.v b/theories/Algebra/Rings.v
index 728a2358ac..bcaf2198aa 100644
--- a/theories/Algebra/Rings.v
+++ b/theories/Algebra/Rings.v
@@ -2,6 +2,7 @@
 
 Require Export HoTT.Algebra.Rings.CRing.
 Require Export HoTT.Algebra.Rings.Ideal.
+Require Export HoTT.Algebra.Rings.QuotientRing.
 
 (** Examples *)
 
-- 
2.29.1


From b0844958871ee040f988e94102d068f02ca8b74f Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Sat, 29 Aug 2020 20:41:28 +0200
Subject: [PATCH 60/76] added libzarith-ocaml dependency to ci

---
 .github/workflows/ci.yml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 8630f418ca..6601913107 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -54,7 +54,7 @@ jobs:
       run: |
         # Work around issue with npm as per https://bugs.launchpad.net/ubuntu/+source/npm/+bug/1809828 and https://askubuntu.com/a/1092849/223605
         sudo apt-get install -y --allow-unauthenticated nodejs-dev node-gyp libssl1.0-dev
-        sudo apt-get install -y --allow-unauthenticated npm aspcud ghc cabal-install graphviz xsltproc python-lxml python-pexpect libxml2-dev libxslt1-dev time ocaml camlp5 camlp4 ocaml-findlib libocamlgraph-ocaml-dev lua5.1
+        sudo apt-get install -y --allow-unauthenticated npm aspcud ghc cabal-install graphviz xsltproc python-lxml python-pexpect libxml2-dev libxslt1-dev time ocaml camlp5 camlp4 ocaml-findlib libocamlgraph-ocaml-dev lua5.1 libzarith-ocaml
 
     - name: Upgrade and autoremove packages
       run: |
-- 
2.29.1


From 7edb3391d28597157a1a9bdf092f998fde68128d Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Sun, 30 Aug 2020 20:28:01 +0200
Subject: [PATCH 61/76] replace libzarith-ocaml with libzarith-ocaml-dev in ci

Co-authored-by: Jason Gross <jasongross9@gmail.com>
---
 .github/workflows/ci.yml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 6601913107..7edafa5231 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -54,7 +54,7 @@ jobs:
       run: |
         # Work around issue with npm as per https://bugs.launchpad.net/ubuntu/+source/npm/+bug/1809828 and https://askubuntu.com/a/1092849/223605
         sudo apt-get install -y --allow-unauthenticated nodejs-dev node-gyp libssl1.0-dev
-        sudo apt-get install -y --allow-unauthenticated npm aspcud ghc cabal-install graphviz xsltproc python-lxml python-pexpect libxml2-dev libxslt1-dev time ocaml camlp5 camlp4 ocaml-findlib libocamlgraph-ocaml-dev lua5.1 libzarith-ocaml
+        sudo apt-get install -y --allow-unauthenticated npm aspcud ghc cabal-install graphviz xsltproc python-lxml python-pexpect libxml2-dev libxslt1-dev time ocaml camlp5 camlp4 ocaml-findlib libocamlgraph-ocaml-dev lua5.1 libzarith-ocaml-dev
 
     - name: Upgrade and autoremove packages
       run: |
-- 
2.29.1


From 8cf56f4376b10b21eebb9fa5178553d7c81f3c23 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Sun, 30 Aug 2020 22:36:21 +0200
Subject: [PATCH 62/76] renamed trivial_subgroup' to maximal_subgroup

---
 theories/Algebra/Groups/Subgroup.v | 6 +++---
 theories/Algebra/Rings/Ideal.v     | 6 +++---
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/theories/Algebra/Groups/Subgroup.v b/theories/Algebra/Groups/Subgroup.v
index 05a5bf03e9..6349dcb516 100644
--- a/theories/Algebra/Groups/Subgroup.v
+++ b/theories/Algebra/Groups/Subgroup.v
@@ -319,11 +319,11 @@ Defined.
 Global Instance issubgroup_group {G : Group} : IsSubgroup G G | 100
   := Build_IsSubgroup _ _ grp_homo_id _.
 
-(** Trivial subgroup (actual trivial group) *)
+(** Trivial subgroup *)
 Definition trivial_subgroup {G} : Subgroup G
   := Build_Subgroup G grp_trivial _.
 
-(** The other trivial subgroup (the actual group itself) *)
-Definition trivial_subgroup' {G} : Subgroup G
+(**  THe maximal subgroup *)
+Definition maximal_subgroup {G} : Subgroup G
   := Build_Subgroup G G _.
 
diff --git a/theories/Algebra/Rings/Ideal.v b/theories/Algebra/Rings/Ideal.v
index d553d7c5b3..8fa922d195 100644
--- a/theories/Algebra/Rings/Ideal.v
+++ b/theories/Algebra/Rings/Ideal.v
@@ -44,8 +44,8 @@ Section Examples.
     := Build_Ideal R _ isideal_trivial_subgroup.
 
   (** The unit ideal is an ideal *)
-  Global Instance isideal_trivial_subgroup'
-    : IsIdeal (R:=R) trivial_subgroup'.
+  Global Instance isideal_maximal_subgroup
+    : IsIdeal (R:=R) maximal_subgroup.
   Proof.
     split.
     cbn; intros r r'.
@@ -55,7 +55,7 @@ Section Examples.
 
   (** Unit ideal *)
   Definition ideal_unit : Ideal R
-    := Build_Ideal R _ isideal_trivial_subgroup'.
+    := Build_Ideal R _ isideal_maximal_subgroup.
 
 (** TODO: Intersection of ideals *)
 (** TODO: Sum of ideals *)
-- 
2.29.1


From 96f46eb873ac1e284eb3bb3b3ec2a1942aba8288 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Sat, 29 Aug 2020 10:19:27 +0200
Subject: [PATCH 63/76] Added link to actions page for github actions branch

Clicking the github actions badge should now take users to the latest CI builds on master.
---
 README.md | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/README.md b/README.md
index 5bc62bfaca..8e9d54b744 100644
--- a/README.md
+++ b/README.md
@@ -1,4 +1,4 @@
-![Github Actions CI](https://github.com/HoTT/HoTT/workflows/CI/badge.svg) [![HoTT Zulip chat](https://img.shields.io/badge/zulip-join_chat-brightgreen.svg)](https://hott.zulipchat.com/)
+[![Github Actions CI](https://github.com/HoTT/HoTT/workflows/CI/badge.svg?branch=master)](https://github.com/HoTT/HoTT/actions?query=workflow%3ACI+branch%3Amaster) [![HoTT Zulip chat](https://img.shields.io/badge/zulip-join_chat-brightgreen.svg)](https://hott.zulipchat.com/)
 
 [Homotopy Type Theory](http://homotopytypetheory.org/) is an interpretation of
 Martin-Löf’s intensional type theory into abstract homotopy theory. Propositional equality
-- 
2.29.1


From 35453e0499d248430f0afee048c043b0ca9144f4 Mon Sep 17 00:00:00 2001
From: "Jarl G. Taxeraas Flaten" <jtaxers@uwo.ca>
Date: Mon, 31 Aug 2020 20:01:03 -0400
Subject: [PATCH 64/76] Define and characterize projective types

Co-authored-by: Dan Christensen <jdc@uwo.ca>
---
 _CoqProject                     |   1 +
 contrib/HoTTBookExercises.v     |   1 +
 theories/HSet.v                 |   7 ++
 theories/Modalities/Separated.v |   8 ++
 theories/Spaces/Projective.v    | 142 ++++++++++++++++++++++++++++++++
 5 files changed, 159 insertions(+)
 create mode 100644 theories/Spaces/Projective.v

diff --git a/_CoqProject b/_CoqProject
index 559ce0d18e..ec09e50a6a 100644
--- a/_CoqProject
+++ b/_CoqProject
@@ -111,6 +111,7 @@ theories/Spaces/Card.v
 theories/Spaces/Circle.v
 theories/Spaces/TwoSphere.v
 theories/Spaces/Spheres.v
+theories/Spaces/Projective.v
 
 theories/Spaces/Int.v
 theories/Spaces/Int/Core.v
diff --git a/contrib/HoTTBookExercises.v b/contrib/HoTTBookExercises.v
index 1b0f8878ba..63d05ad3f9 100644
--- a/contrib/HoTTBookExercises.v
+++ b/contrib/HoTTBookExercises.v
@@ -1619,6 +1619,7 @@ End Book_7_1.
 
 (* ================================================== ex:acnm-surjset *)
 (** Exercise 7.9 *)
+(* Solved for AC_(oo,-1) by projective_cover_AC in Spaces/Projective.v *)
 
 
 
diff --git a/theories/HSet.v b/theories/HSet.v
index 16d8cb5ff1..be18851287 100644
--- a/theories/HSet.v
+++ b/theories/HSet.v
@@ -121,6 +121,13 @@ Proof.
   exact (ap pr1 q).
 Defined.
 
+Definition isinj_section {A B : Type} {s : A -> B} {r : B -> A}
+      (H : r o s == idmap) : isinj s.
+Proof.
+  intros a a' alpha.
+  exact ((H a)^ @ ap r alpha @ H a').
+Defined.
+
 Lemma isembedding_isinj_hset {A B : Type} `{IsHSet B} (m : A -> B)
 : isinj m -> IsEmbedding m.
 Proof.
diff --git a/theories/Modalities/Separated.v b/theories/Modalities/Separated.v
index b75bc3383e..a6749b78a3 100644
--- a/theories/Modalities/Separated.v
+++ b/theories/Modalities/Separated.v
@@ -98,6 +98,13 @@ Proof.
   refine (inO_equiv_inO' _ (equiv_ap_isembedding i x y)^-1).
 Defined.
 
+(* As a special case, if X embeds into an n-type for n >= -1 then X is an n-type. Note that this doesn't hold for n = -2. *)
+Corollary istrunc_embedding_trunc `{Funext} {X Y : Type} {n : trunc_index} `{IsTrunc n.+1 Y}
+      (i : X -> Y) `{IsEmbedding i} : IsTrunc n.+1 X.
+Proof.
+  exact (@in_SepO_embedding (Tr n) _ _ i IsEmbedding0 H0).
+Defined.
+
 Global Instance in_SepO_hprop (O : ReflectiveSubuniverse)
        {A : Type} `{IsHProp A}
   : In (Sep O) A.
@@ -106,6 +113,7 @@ Proof.
   intros x y; exact _.
 Defined.
 
+
 (** Remark 2.16(4) of CORS *)
 Definition sigma_closed_SepO (O : Modality) {A : Type} (B : A -> Type)
            `{A_inO : In (Sep O) A} `{B_inO : forall a, In (Sep O) (B a)}
diff --git a/theories/Spaces/Projective.v b/theories/Spaces/Projective.v
new file mode 100644
index 0000000000..67ad41f302
--- /dev/null
+++ b/theories/Spaces/Projective.v
@@ -0,0 +1,142 @@
+Require Import Basics Types HProp HSet HFiber Truncations.
+Require Import Modalities.Descent Modalities.Separated.
+Require Import Limits.Pullback Spaces.Finite.
+
+
+(** * Projective types *)
+
+Definition IsProjective (X : Type)
+  := forall A B : Type, forall f : X -> B, forall p : A -> B,
+        IsSurjection p -> merely (exists s : X -> A, p o s == f).
+
+(** A type X is projective if and only if surjections into X merely split. *)
+Proposition equiv_isprojective_surjections_split `{Funext} (X : Type)
+  : IsProjective X <~>
+    (forall (Y:Type), forall (p : Y -> X),
+          IsSurjection p -> merely (exists s : X -> Y, p o s == idmap)).
+Proof.
+  srapply equiv_iff_hprop.
+  - intro isprojX. unfold IsProjective in isprojX.
+    intros Y p S.
+    exact (isprojX Y X idmap p S).
+  - intro splits. unfold IsProjective.
+    intros A B f p S.
+    pose proof (splits (Pullback p f) pullback_pr2 _) as s'.
+    strip_truncations.
+    destruct s' as [s E].
+    refine (tr (pullback_pr1 o s; _)).
+    intro x.
+    refine (pullback_commsq p f (s x) @ _).
+    apply (ap f).
+    apply E.
+Defined.
+
+(** ** Projectivity and choice *)
+
+Definition choice (X : Type) := forall P : X -> Type,
+      (forall x, merely (P x)) -> merely (forall x, P x).
+
+(* The following two lemmas make the proof of equiv_isprojective_choice below easier to follow. *)
+Lemma equiv_contr_hprop `{Funext} (A : Type) `{IsHProp A}
+  : Contr A <~> A.
+Proof.
+  rapply equiv_iff_hprop.
+  - apply center.
+  - rapply contr_inhabited_hprop.
+Defined.
+
+Lemma equiv_isconnmap_merely `{Funext} {X : Type} (P : X -> Type)
+  : IsConnMap (Tr (-1)) (pr1 : {x : X & P x} -> X) <~> forall x : X, merely (P x).
+Proof.
+  apply equiv_functor_forall_id; intro x.
+  unfold IsConnected.
+  refine (_ oE equiv_contr_hprop _).
+  apply Trunc_functor_equiv.
+  symmetry; apply hfiber_fibration.
+Defined.
+
+Proposition equiv_isprojective_choice `{Funext} (X : Type)
+  : IsProjective X <~> choice X.
+Proof.
+  refine (_ oE equiv_isprojective_surjections_split X).
+  srapply equiv_iff_hprop.
+  - intros splits P S.
+    specialize splits with {x : X & P x} pr1.
+    pose proof (splits ((equiv_isconnmap_merely P)^-1%equiv S)) as M.
+    clear S splits.
+    strip_truncations; apply tr.
+    destruct M as [s p].
+    intro x.
+    exact (transport _ (p x) (s x).2).
+  - intros choiceX Y p S.
+    unfold IsConnMap, IsConnected in S.
+    pose proof (fun b => (@center _ (S b))) as S'; clear S.
+    pose proof (choiceX (hfiber p) S') as M; clear S'.
+    strip_truncations; apply tr.
+    exists (fun x => (M x).1).
+    exact (fun x => (M x).2).
+Defined.
+
+(** Finite sets (as in Spaces/Finite.v) are projective. *)
+Theorem isprojective_fin_n `{Funext} (n : nat) : IsProjective (Fin n).
+Proof.
+  apply (equiv_isprojective_choice (Fin n))^-1.
+  rapply finite_choice.
+Defined.
+
+Proposition isprojective_unit `{Funext} : IsProjective Unit.
+Proof.
+  apply (equiv_isprojective_choice Unit)^-1.
+  intros P S.
+  specialize S with tt.
+  strip_truncations; apply tr.
+  apply Unit_ind.
+  exact S.
+Defined.
+
+
+Section AC_oo_neg1.
+  (** ** Projectivity and AC_(oo,-1) (defined in HoTT book, Exercise 7.8) *)
+  (* TODO: Generalize to n, m. *)
+
+  Context {AC : forall X : hSet, choice X}.
+
+  (** (Exercise 7.9) Assuming AC_(oo,-1) every type merely has a projective cover. *)
+  Proposition projective_cover_AC `{Univalence} (A : Type)
+    : merely (exists X:hSet, exists p : X -> A, IsSurjection p).
+  Proof.
+    pose (X := BuildhSet (Tr 0 A)).
+    pose proof ((equiv_isprojective_choice X)^-1 (AC X)) as P.
+    pose proof (P A X idmap tr _) as F; clear P.
+    strip_truncations.
+    destruct F as [f p].
+    apply tr; refine (X; (f; _)).
+    unfold IsConnMap, IsConnected.
+    intro a.
+    rapply contr_inhabited_hprop.
+    unfold hfiber.
+    apply equiv_O_sigma_O.
+    refine (tr (tr a; _)).
+    rapply (equiv_path_Tr _ _)^-1%equiv.  (* Uses Univalence. *)
+    apply p.
+  Defined.
+
+  (** Assuming AC_(oo,-1), projective types are exactly sets. *)
+  Theorem equiv_isprojective_ishset_AC `{Univalence} (X : Type)
+    : IsProjective X <~> IsHSet X.
+  Proof.
+    apply equiv_iff_hprop.
+    - intro isprojX. unfold IsProjective in isprojX.
+      pose proof (projective_cover_AC X) as P; strip_truncations.
+      destruct P as [P [p issurj_p]].
+      pose proof (isprojX P X idmap p issurj_p) as S; strip_truncations.
+      destruct S as [s h].
+      rapply (istrunc_embedding_trunc s).
+      apply isembedding_isinj_hset.
+      exact (isinj_section h).
+    - intro ishsetX.
+      apply (equiv_isprojective_choice X)^-1.
+      rapply AC.
+  Defined.
+
+End AC_oo_neg1.
-- 
2.29.1


From cae55faf9bab59f6753195c457028cd416389f60 Mon Sep 17 00:00:00 2001
From: "Jarl G. Taxeraas Flaten" <jtaxers@uwo.ca>
Date: Fri, 4 Sep 2020 12:26:33 -0400
Subject: [PATCH 65/76] Prove O-connected types form a subuniverse (for O :
 RSU); refactor

Co-authored-by: Dan Christensen <jdc@uwo.ca>
---
 _CoqProject                                 |  2 +-
 theories/Basics/Trunc.v                     |  8 ++
 theories/HoTT.v                             |  1 +
 theories/Modalities/ReflectiveSubuniverse.v | 97 ++++++++++++++-------
 theories/{Spaces => }/Projective.v          | 64 +++++---------
 theories/Spaces/Finite.v                    | 11 ++-
 theories/Truncations/Core.v                 |  9 ++
 7 files changed, 115 insertions(+), 77 deletions(-)
 rename theories/{Spaces => }/Projective.v (67%)

diff --git a/_CoqProject b/_CoqProject
index ec09e50a6a..26ffa9e265 100644
--- a/_CoqProject
+++ b/_CoqProject
@@ -111,7 +111,6 @@ theories/Spaces/Card.v
 theories/Spaces/Circle.v
 theories/Spaces/TwoSphere.v
 theories/Spaces/Spheres.v
-theories/Spaces/Projective.v
 
 theories/Spaces/Int.v
 theories/Spaces/Int/Core.v
@@ -244,6 +243,7 @@ theories/HFiber.v
 theories/HProp.v
 theories/Extensions.v
 theories/HSet.v
+theories/Projective.v
 theories/TruncType.v
 theories/DProp.v
 theories/EquivGroupoids.v
diff --git a/theories/Basics/Trunc.v b/theories/Basics/Trunc.v
index 9b27d68225..faa034a289 100644
--- a/theories/Basics/Trunc.v
+++ b/theories/Basics/Trunc.v
@@ -400,6 +400,14 @@ Definition equiv_iff_hprop `{IsHProp A} `{IsHProp B}
   : (A -> B) -> (B -> A) -> (A <~> B)
   := fun f g => equiv_iff_hprop_uncurried (f, g).
 
+Corollary equiv_contr_hprop (A : Type) `{Funext} `{IsHProp A}
+  : Contr A <~> A.
+Proof.
+  rapply equiv_iff_hprop.
+  - apply center.
+  - rapply contr_inhabited_hprop.
+Defined.
+
 (** Truncatedness is an hprop. *)
 Global Instance ishprop_istrunc `{Funext} (n : trunc_index) (A : Type)
   : IsHProp (IsTrunc n A) | 0.
diff --git a/theories/HoTT.v b/theories/HoTT.v
index 643e56908a..95e0c5874a 100644
--- a/theories/HoTT.v
+++ b/theories/HoTT.v
@@ -12,6 +12,7 @@ Require Export HoTT.Truncations.
 
 Require Export HoTT.HFiber.
 Require Export HoTT.HProp.
+Require Export HoTT.Projective.
 Require Export HoTT.HSet.
 Require Export HoTT.EquivGroupoids.
 
diff --git a/theories/Modalities/ReflectiveSubuniverse.v b/theories/Modalities/ReflectiveSubuniverse.v
index 8084127a24..64c5067d9f 100644
--- a/theories/Modalities/ReflectiveSubuniverse.v
+++ b/theories/Modalities/ReflectiveSubuniverse.v
@@ -51,6 +51,14 @@ Definition inO_equiv_inO' {O : Subuniverse}
   : In O U
   := inO_equiv_inO T f.
 
+Definition inO_equiv_inO'' `{Funext} (O : Subuniverse) {T U : Type} (f : T <~> U)
+  : In O T <~> In O U.
+Proof.
+  apply equiv_iff_hprop.
+  - intro T_inO; exact (inO_equiv_inO' T f).
+  - intro U_inO; exact (inO_equiv_inO' U f^-1%equiv).
+Defined.
+
 (** The universe of types in the subuniverse *)
 Definition Type_@{i j} (O : Subuniverse@{i}) : Type@{j}
   := @sig@{j i} Type@{i} (fun (T : Type@{i}) => In O T).
@@ -70,6 +78,54 @@ Definition equiv_path_TypeO@{i j} {fs : Funext} O (T T' : Type_ O)
 Global Instance inO_TypeO {O : Subuniverse} (A : Type_ O) : In O A
   := A.2.
 
+(** ** Properties of Subuniverses *)
+
+(** A map is O-local if all its fibers are. *)
+Class MapIn (O : Subuniverse) {A B : Type} (f : A -> B)
+  := inO_hfiber_ino_map : forall (b:B), In O (hfiber f b).
+
+Global Existing Instance inO_hfiber_ino_map.
+
+Section Subuniverse.
+  Context (O : Subuniverse).
+
+  (** Anything homotopic to a local map is local. *)
+  Definition mapinO_homotopic {A B : Type} (f : A -> B) {g : A -> B}
+             (p : f == g) `{MapIn O _ _ f}
+  : MapIn O g.
+  Proof.
+    intros b.
+    refine (inO_equiv_inO (hfiber f b)
+                          (equiv_hfiber_homotopic f g p b)).
+  Defined.
+
+  (** The projection from a family of local types is local. *)
+  Global Instance mapinO_pr1 {A : Type} {B : A -> Type}
+         `{forall a, In O (B a)}
+  : MapIn O (@pr1 A B).
+  Proof.
+    intros a.
+    exact (inO_equiv_inO (B a) (hfiber_fibration a B)).
+  Defined.
+
+  Lemma equiv_forall_inO_mapinO_pr1 `{Funext} {A : Type} (B : A -> Type)
+    : (forall a, In O (B a)) <~> MapIn O (@pr1 A B).
+  Proof.
+    unfold MapIn.
+    apply equiv_functor_forall_id; intro a.
+    apply inO_equiv_inO''.
+    exact (hfiber_fibration a B).
+  Defined.
+
+  (** Being a local map is an hprop *)
+  Global Instance ishprop_mapinO `{Funext} {A B : Type} (f : A -> B)
+  : IsHProp (MapIn O f).
+  Proof.
+    apply trunc_forall.
+  Defined.
+
+End Subuniverse.
+
 (** *** Reflections *)
 
 (** A pre-reflection is a map to a type in the subuniverse. *)
@@ -1210,6 +1266,14 @@ Section ConnectedTypes.
   : IsConnected O A -> IsConnected O B
     := isconnected_equiv A f.
 
+  (** The O-connected types form a subuniverse. *)
+  Definition Conn : Subuniverse.
+  Proof.
+    rapply (Build_Subuniverse (IsConnected O)).
+    simpl; intros T U isconnT f isequivf.
+    exact (isconnected_equiv T f isconnT).
+  Defined.
+
   (** Connectedness of a type [A] can equivalently be characterized by the fact that any map to an [O]-type [C] is nullhomotopic.  Here is one direction of that equivalence. *)
   Definition isconnected_elim {A : Type} `{IsConnected O A} (C : Type) `{In O C} (f : A -> C)
   : NullHomotopy f.
@@ -1310,13 +1374,6 @@ End ConnectedTypes.
 
 (** ** Modally truncated maps *)
 
-(** A map is "in [O]" if each of its fibers is. *)
-
-Class MapIn (O : ReflectiveSubuniverse) {A B : Type} (f : A -> B)
-  := inO_hfiber_ino_map : forall (b:B), In O (hfiber f b).
-
-Global Existing Instance inO_hfiber_ino_map.
-
 Section ModalMaps.
   Context (O : ReflectiveSubuniverse).
 
@@ -1327,25 +1384,6 @@ Section ModalMaps.
     intros b; exact _.
   Defined.
 
-  (** Anything homotopic to a modal map is modal. *)
-  Definition mapinO_homotopic {A B : Type} (f : A -> B) {g : A -> B}
-             (p : f == g) `{MapIn O _ _ f}
-  : MapIn O g.
-  Proof.
-    intros b.
-    refine (inO_equiv_inO (hfiber f b)
-                          (equiv_hfiber_homotopic f g p b)).
-  Defined.
-
-  (** The projection from a family of modal types is modal. *)
-  Global Instance mapinO_pr1 {A : Type} {B : A -> Type}
-         `{forall a, In O (B a)}
-  : MapIn O (@pr1 A B).
-  Proof.
-    intros a.
-    refine (inO_equiv_inO (B a) (hfiber_fibration a B)).
-  Defined.
-
   (** A slightly specialized result: if [Empty] is modal, then a map with decidable hprop fibers (such as [inl] or [inr]) is modal. *)
   Global Instance mapinO_hfiber_decidable_hprop {A B : Type} (f : A -> B)
          `{In O Empty}
@@ -1359,13 +1397,6 @@ Section ModalMaps.
     - exact (inO_equiv_inO Empty e^-1).
   Defined.
 
-  (** Being modal is an hprop *)
-  Global Instance ishprop_mapinO `{Funext} {A B : Type} (f : A -> B)
-  : IsHProp (MapIn O f).
-  Proof.
-    apply trunc_forall.
-  Defined.
-
   (** Any map between modal types is modal. *)
   Global Instance mapinO_between_inO {A B : Type} (f : A -> B)
              `{In O A} `{In O B}
diff --git a/theories/Spaces/Projective.v b/theories/Projective.v
similarity index 67%
rename from theories/Spaces/Projective.v
rename to theories/Projective.v
index 67ad41f302..358e650df9 100644
--- a/theories/Spaces/Projective.v
+++ b/theories/Projective.v
@@ -1,23 +1,23 @@
-Require Import Basics Types HProp HSet HFiber Truncations.
+Require Import Basics Types HProp HFiber HSet.
+Require Import Truncations.
 Require Import Modalities.Descent Modalities.Separated.
-Require Import Limits.Pullback Spaces.Finite.
+Require Import Limits.Pullback.
 
 
 (** * Projective types *)
 
-Definition IsProjective (X : Type)
+Definition IsProjective (X : Type) : Type
   := forall A B : Type, forall f : X -> B, forall p : A -> B,
         IsSurjection p -> merely (exists s : X -> A, p o s == f).
 
 (** A type X is projective if and only if surjections into X merely split. *)
-Proposition equiv_isprojective_surjections_split `{Funext} (X : Type)
-  : IsProjective X <~>
-    (forall (Y:Type), forall (p : Y -> X),
+Proposition iff_isprojective_surjections_split (X : Type)
+  : IsProjective X <->
+    (forall (Y : Type), forall (p : Y -> X),
           IsSurjection p -> merely (exists s : X -> Y, p o s == idmap)).
 Proof.
-  srapply equiv_iff_hprop.
-  - intro isprojX. unfold IsProjective in isprojX.
-    intros Y p S.
+  split.
+  - intros isprojX Y p S; unfold IsProjective in isprojX.
     exact (isprojX Y X idmap p S).
   - intro splits. unfold IsProjective.
     intros A B f p S.
@@ -31,38 +31,28 @@ Proof.
     apply E.
 Defined.
 
-(** ** Projectivity and choice *)
-
-Definition choice (X : Type) := forall P : X -> Type,
-      (forall x, merely (P x)) -> merely (forall x, P x).
-
-(* The following two lemmas make the proof of equiv_isprojective_choice below easier to follow. *)
-Lemma equiv_contr_hprop `{Funext} (A : Type) `{IsHProp A}
-  : Contr A <~> A.
+Corollary equiv_isprojective_surjections_split `{Funext} (X : Type)
+  : IsProjective X <~>
+    (forall (Y : Type), forall (p : Y -> X),
+          IsSurjection p -> merely (exists s : X -> Y, p o s == idmap)).
 Proof.
-  rapply equiv_iff_hprop.
-  - apply center.
-  - rapply contr_inhabited_hprop.
+  exact (equiv_iff_hprop_uncurried (iff_isprojective_surjections_split X)).
 Defined.
 
-Lemma equiv_isconnmap_merely `{Funext} {X : Type} (P : X -> Type)
-  : IsConnMap (Tr (-1)) (pr1 : {x : X & P x} -> X) <~> forall x : X, merely (P x).
-Proof.
-  apply equiv_functor_forall_id; intro x.
-  unfold IsConnected.
-  refine (_ oE equiv_contr_hprop _).
-  apply Trunc_functor_equiv.
-  symmetry; apply hfiber_fibration.
-Defined.
+
+(** ** Projectivity and choice *)
+
+Definition Choice (X : Type) : Type := forall P : X -> Type,
+    (forall x, merely (P x)) -> merely (forall x, P x).
 
 Proposition equiv_isprojective_choice `{Funext} (X : Type)
-  : IsProjective X <~> choice X.
+  : IsProjective X <~> Choice X.
 Proof.
   refine (_ oE equiv_isprojective_surjections_split X).
   srapply equiv_iff_hprop.
   - intros splits P S.
     specialize splits with {x : X & P x} pr1.
-    pose proof (splits ((equiv_isconnmap_merely P)^-1%equiv S)) as M.
+    pose proof (splits ((equiv_merely_issurjection P) S)) as M.
     clear S splits.
     strip_truncations; apply tr.
     destruct M as [s p].
@@ -77,14 +67,7 @@ Proof.
     exact (fun x => (M x).2).
 Defined.
 
-(** Finite sets (as in Spaces/Finite.v) are projective. *)
-Theorem isprojective_fin_n `{Funext} (n : nat) : IsProjective (Fin n).
-Proof.
-  apply (equiv_isprojective_choice (Fin n))^-1.
-  rapply finite_choice.
-Defined.
-
-Proposition isprojective_unit `{Funext} : IsProjective Unit.
+Proposition isprojective_unit `{Univalence} : IsProjective Unit.
 Proof.
   apply (equiv_isprojective_choice Unit)^-1.
   intros P S.
@@ -94,12 +77,11 @@ Proof.
   exact S.
 Defined.
 
-
 Section AC_oo_neg1.
   (** ** Projectivity and AC_(oo,-1) (defined in HoTT book, Exercise 7.8) *)
   (* TODO: Generalize to n, m. *)
 
-  Context {AC : forall X : hSet, choice X}.
+  Context {AC : forall X : hSet, Choice X}.
 
   (** (Exercise 7.9) Assuming AC_(oo,-1) every type merely has a projective cover. *)
   Proposition projective_cover_AC `{Univalence} (A : Type)
diff --git a/theories/Spaces/Finite.v b/theories/Spaces/Finite.v
index 064251b4c9..7bd2d90077 100644
--- a/theories/Spaces/Finite.v
+++ b/theories/Spaces/Finite.v
@@ -10,6 +10,7 @@ Require Import Factorization.
 Require Import Equiv.PathSplit.
 Require Import Truncations.
 Require Import Colimits.Quotient.
+Require Import Projective.
 
 Local Open Scope path_scope.
 Local Open Scope nat_scope.
@@ -566,10 +567,10 @@ Proof.
   - refine (transport (P (Fin n.+1)) (path_ishprop _ _) (fs _ _ IH)).
 Defined.
 
-(** ** The finite axiom of choice *)
+(** ** The finite axiom of choice, and projectivity *)
 
 Definition finite_choice {X} `{Finite X} (P : X -> Type)
-: (forall x, merely (P x)) -> merely (forall x, P x).
+  : (forall x, merely (P x)) -> merely (forall x, P x).
 Proof.
   intros f.
   assert (e := merely_equiv_fin X).
@@ -588,6 +589,12 @@ Proof.
       exact (tr (sum_ind P IH (Unit_ind e))).
 Defined.
 
+Corollary isprojective_fin_n `{Funext} (n : nat) : IsProjective (Fin n).
+Proof.
+  apply (equiv_isprojective_choice (Fin n))^-1.
+  rapply finite_choice.
+Defined.
+
 (** ** Constructions on finite sets *)
 
 (** Finite sets are closed under sums, products, function spaces, and equivalence spaces.  There are multiple choices we could make regarding how to prove these facts.  Since we know what the cardinalities ought to be in all cases (since we know how to add, multiply, exponentiate, and take factorials of natural numbers), we could specify those off the bat, and then reduce to the case of canonical finite sets.  However, it's more amusing to instead prove finiteness of these constructions by "finite-set induction", and then *deduce* that their cardinalities are given by the corresponding operations on natural numbers (because they satisfy the same recurrences). *)
diff --git a/theories/Truncations/Core.v b/theories/Truncations/Core.v
index ba4414475e..16f5fbc46e 100644
--- a/theories/Truncations/Core.v
+++ b/theories/Truncations/Core.v
@@ -191,6 +191,15 @@ Proof.
   apply H.
 Defined.
 
+(** A family of types is pointwise merely inhabited if and only if the corresponding fibration is surjective. *)
+Lemma equiv_merely_issurjection `{Funext} {X : Type} (P : X -> Type)
+  : (forall x, merely (P x)) <~> IsSurjection (pr1 : {x : X & P x} -> X).
+Proof.
+  refine (equiv_forall_inO_mapinO_pr1 (Conn _) _ oE _).
+  apply equiv_functor_forall_id; intro x.
+  exact (equiv_contr_hprop _)^-1%equiv.
+Defined.
+
 Definition isequiv_surj_emb {A B} (f : A -> B)
   `{IsSurjection f} `{IsEmbedding f}
   : IsEquiv f.
-- 
2.29.1


From d49cceefaa9805c485e3254f3a0e0a05bf1a1b30 Mon Sep 17 00:00:00 2001
From: "Jarl G. Taxeraas Flaten" <jtaxers@uwo.ca>
Date: Sat, 5 Sep 2020 12:03:16 -0400
Subject: [PATCH 66/76] Add partial solution to exercise 7.9

Co-authored-by: Dan Christensen <jdc@uwo.ca>
---
 contrib/HoTTBookExercises.v                 | 10 +++++++++-
 theories/Modalities/ReflectiveSubuniverse.v |  1 +
 theories/Projective.v                       |  4 ++--
 3 files changed, 12 insertions(+), 3 deletions(-)

diff --git a/contrib/HoTTBookExercises.v b/contrib/HoTTBookExercises.v
index 63d05ad3f9..dbc9c95ba0 100644
--- a/contrib/HoTTBookExercises.v
+++ b/contrib/HoTTBookExercises.v
@@ -1619,9 +1619,17 @@ End Book_7_1.
 
 (* ================================================== ex:acnm-surjset *)
 (** Exercise 7.9 *)
-(* Solved for AC_(oo,-1) by projective_cover_AC in Spaces/Projective.v *)
 
+Section Book_7_9.
+  (** Solution for the case (oo,-1). *)
 
+  Axiom AC_oo_neg1 : forall X : hSet, Choice X.
+
+  Definition Book_7_9_oo_neg1 `{Univalence} (A : Type)
+    : merely (exists X : hSet, exists p : X -> A, IsSurjection p)
+    := @HoTT.Projective.projective_cover_AC AC_oo_neg1 _ A.
+
+End Book_7_9.
 
 (* ================================================== ex:acconn *)
 (** Exercise 7.10 *)
diff --git a/theories/Modalities/ReflectiveSubuniverse.v b/theories/Modalities/ReflectiveSubuniverse.v
index 64c5067d9f..b0cc68ee45 100644
--- a/theories/Modalities/ReflectiveSubuniverse.v
+++ b/theories/Modalities/ReflectiveSubuniverse.v
@@ -108,6 +108,7 @@ Section Subuniverse.
     exact (inO_equiv_inO (B a) (hfiber_fibration a B)).
   Defined.
 
+  (** A family of types is local if and only if the associated projection map is local. *)
   Lemma equiv_forall_inO_mapinO_pr1 `{Funext} {A : Type} (B : A -> Type)
     : (forall a, In O (B a)) <~> MapIn O (@pr1 A B).
   Proof.
diff --git a/theories/Projective.v b/theories/Projective.v
index 358e650df9..9f6440cf18 100644
--- a/theories/Projective.v
+++ b/theories/Projective.v
@@ -52,7 +52,7 @@ Proof.
   srapply equiv_iff_hprop.
   - intros splits P S.
     specialize splits with {x : X & P x} pr1.
-    pose proof (splits ((equiv_merely_issurjection P) S)) as M.
+    pose proof (splits (equiv_merely_issurjection P S)) as M.
     clear S splits.
     strip_truncations; apply tr.
     destruct M as [s p].
@@ -67,7 +67,7 @@ Proof.
     exact (fun x => (M x).2).
 Defined.
 
-Proposition isprojective_unit `{Univalence} : IsProjective Unit.
+Proposition isprojective_unit `{Funext} : IsProjective Unit.
 Proof.
   apply (equiv_isprojective_choice Unit)^-1.
   intros P S.
-- 
2.29.1


From 047d1779d47d3b071630a0fe48f26b9d3182a474 Mon Sep 17 00:00:00 2001
From: "Jarl G. Taxeraas Flaten" <jtaxers@uwo.ca>
Date: Thu, 10 Sep 2020 10:51:35 -0400
Subject: [PATCH 67/76] Add iff_forall_inO_mapinO_pr1 and
 iff_merely_issurjection

Co-authored-by: Dan Christensen <jdc@uwo.ca>
---
 contrib/HoTTBookExercises.v                 | 14 +++-----
 theories/Basics/Trunc.v                     | 12 +++++--
 theories/Modalities/ReflectiveSubuniverse.v | 36 ++++++++++-----------
 theories/Projective.v                       | 20 ++++++++----
 theories/Spaces/Finite.v                    |  4 +--
 theories/Truncations/Core.v                 | 14 +++++---
 6 files changed, 56 insertions(+), 44 deletions(-)

diff --git a/contrib/HoTTBookExercises.v b/contrib/HoTTBookExercises.v
index dbc9c95ba0..3562ee1f9a 100644
--- a/contrib/HoTTBookExercises.v
+++ b/contrib/HoTTBookExercises.v
@@ -1620,16 +1620,10 @@ End Book_7_1.
 (* ================================================== ex:acnm-surjset *)
 (** Exercise 7.9 *)
 
-Section Book_7_9.
-  (** Solution for the case (oo,-1). *)
-
-  Axiom AC_oo_neg1 : forall X : hSet, Choice X.
-
-  Definition Book_7_9_oo_neg1 `{Univalence} (A : Type)
-    : merely (exists X : hSet, exists p : X -> A, IsSurjection p)
-    := @HoTT.Projective.projective_cover_AC AC_oo_neg1 _ A.
-
-End Book_7_9.
+(** Solution for the case (oo,-1). *)
+Definition Book_7_9_oo_neg1 `{Univalence} (AC_oo_neg1 : forall X : hSet, Choice X) (A : Type)
+  : merely (exists X : hSet, exists p : X -> A, IsSurjection p)
+  := @HoTT.Projective.projective_cover_AC AC_oo_neg1 _ A.
 
 (* ================================================== ex:acconn *)
 (** Exercise 7.10 *)
diff --git a/theories/Basics/Trunc.v b/theories/Basics/Trunc.v
index faa034a289..a0d9a0aa0a 100644
--- a/theories/Basics/Trunc.v
+++ b/theories/Basics/Trunc.v
@@ -400,14 +400,20 @@ Definition equiv_iff_hprop `{IsHProp A} `{IsHProp B}
   : (A -> B) -> (B -> A) -> (A <~> B)
   := fun f g => equiv_iff_hprop_uncurried (f, g).
 
-Corollary equiv_contr_hprop (A : Type) `{Funext} `{IsHProp A}
-  : Contr A <~> A.
+Corollary iff_contr_hprop (A : Type) `{IsHProp A}
+  : Contr A <-> A.
 Proof.
-  rapply equiv_iff_hprop.
+  split.
   - apply center.
   - rapply contr_inhabited_hprop.
 Defined.
 
+Corollary equiv_contr_hprop (A : Type) `{Funext} `{IsHProp A}
+  : Contr A <~> A.
+Proof.
+  exact (equiv_iff_hprop_uncurried (iff_contr_hprop A)).
+Defined.
+
 (** Truncatedness is an hprop. *)
 Global Instance ishprop_istrunc `{Funext} (n : trunc_index) (A : Type)
   : IsHProp (IsTrunc n A) | 0.
diff --git a/theories/Modalities/ReflectiveSubuniverse.v b/theories/Modalities/ReflectiveSubuniverse.v
index b0cc68ee45..3edf64e6db 100644
--- a/theories/Modalities/ReflectiveSubuniverse.v
+++ b/theories/Modalities/ReflectiveSubuniverse.v
@@ -51,14 +51,6 @@ Definition inO_equiv_inO' {O : Subuniverse}
   : In O U
   := inO_equiv_inO T f.
 
-Definition inO_equiv_inO'' `{Funext} (O : Subuniverse) {T U : Type} (f : T <~> U)
-  : In O T <~> In O U.
-Proof.
-  apply equiv_iff_hprop.
-  - intro T_inO; exact (inO_equiv_inO' T f).
-  - intro U_inO; exact (inO_equiv_inO' U f^-1%equiv).
-Defined.
-
 (** The universe of types in the subuniverse *)
 Definition Type_@{i j} (O : Subuniverse@{i}) : Type@{j}
   := @sig@{j i} Type@{i} (fun (T : Type@{i}) => In O T).
@@ -89,6 +81,13 @@ Global Existing Instance inO_hfiber_ino_map.
 Section Subuniverse.
   Context (O : Subuniverse).
 
+  (** Being a local map is an hprop *)
+  Global Instance ishprop_mapinO `{Funext} {A B : Type} (f : A -> B)
+  : IsHProp (MapIn O f).
+  Proof.
+    apply trunc_forall.
+  Defined.
+
   (** Anything homotopic to a local map is local. *)
   Definition mapinO_homotopic {A B : Type} (f : A -> B) {g : A -> B}
              (p : f == g) `{MapIn O _ _ f}
@@ -109,20 +108,21 @@ Section Subuniverse.
   Defined.
 
   (** A family of types is local if and only if the associated projection map is local. *)
-  Lemma equiv_forall_inO_mapinO_pr1 `{Funext} {A : Type} (B : A -> Type)
-    : (forall a, In O (B a)) <~> MapIn O (@pr1 A B).
+  Lemma iff_forall_inO_mapinO_pr1 {A : Type} (B : A -> Type)
+    : (forall a, In O (B a)) <-> MapIn O (@pr1 A B).
   Proof.
-    unfold MapIn.
-    apply equiv_functor_forall_id; intro a.
-    apply inO_equiv_inO''.
-    exact (hfiber_fibration a B).
+    split.
+    - exact _. (* Uses the instance mapinO_pr1 above. *)
+    - rapply functor_forall; intros a x.
+      exact (inO_equiv_inO (hfiber pr1 a)
+                           (hfiber_fibration a B)^-1%equiv).
   Defined.
 
-  (** Being a local map is an hprop *)
-  Global Instance ishprop_mapinO `{Funext} {A B : Type} (f : A -> B)
-  : IsHProp (MapIn O f).
+  Lemma equiv_forall_inO_mapinO_pr1 `{Funext} {A : Type} (B : A -> Type)
+    : (forall a, In O (B a)) <~> MapIn O (@pr1 A B).
   Proof.
-    apply trunc_forall.
+    apply equiv_iff_hprop_uncurried.
+    apply iff_forall_inO_mapinO_pr1.
   Defined.
 
 End Subuniverse.
diff --git a/theories/Projective.v b/theories/Projective.v
index 9f6440cf18..6bb02a0b68 100644
--- a/theories/Projective.v
+++ b/theories/Projective.v
@@ -45,14 +45,14 @@ Defined.
 Definition Choice (X : Type) : Type := forall P : X -> Type,
     (forall x, merely (P x)) -> merely (forall x, P x).
 
-Proposition equiv_isprojective_choice `{Funext} (X : Type)
-  : IsProjective X <~> Choice X.
+Proposition iff_isprojective_choice (X : Type)
+  : IsProjective X <-> Choice X.
 Proof.
-  refine (_ oE equiv_isprojective_surjections_split X).
-  srapply equiv_iff_hprop.
+  refine (iff_compose (iff_isprojective_surjections_split X) _).
+  split.
   - intros splits P S.
     specialize splits with {x : X & P x} pr1.
-    pose proof (splits (equiv_merely_issurjection P S)) as M.
+    pose proof (splits (fst (iff_merely_issurjection P) S)) as M.
     clear S splits.
     strip_truncations; apply tr.
     destruct M as [s p].
@@ -67,9 +67,15 @@ Proof.
     exact (fun x => (M x).2).
 Defined.
 
-Proposition isprojective_unit `{Funext} : IsProjective Unit.
+Proposition equiv_isprojective_choice `{Funext} (X : Type)
+  : IsProjective X <~> Choice X.
+Proof.
+  exact (equiv_iff_hprop_uncurried (iff_isprojective_choice X)).
+Defined.
+
+Proposition isprojective_unit : IsProjective Unit.
 Proof.
-  apply (equiv_isprojective_choice Unit)^-1.
+  apply (iff_isprojective_choice Unit).
   intros P S.
   specialize S with tt.
   strip_truncations; apply tr.
diff --git a/theories/Spaces/Finite.v b/theories/Spaces/Finite.v
index 7bd2d90077..26b824375a 100644
--- a/theories/Spaces/Finite.v
+++ b/theories/Spaces/Finite.v
@@ -589,9 +589,9 @@ Proof.
       exact (tr (sum_ind P IH (Unit_ind e))).
 Defined.
 
-Corollary isprojective_fin_n `{Funext} (n : nat) : IsProjective (Fin n).
+Corollary isprojective_fin_n (n : nat) : IsProjective (Fin n).
 Proof.
-  apply (equiv_isprojective_choice (Fin n))^-1.
+  apply (iff_isprojective_choice (Fin n)).
   rapply finite_choice.
 Defined.
 
diff --git a/theories/Truncations/Core.v b/theories/Truncations/Core.v
index 16f5fbc46e..c283df7cf3 100644
--- a/theories/Truncations/Core.v
+++ b/theories/Truncations/Core.v
@@ -192,12 +192,18 @@ Proof.
 Defined.
 
 (** A family of types is pointwise merely inhabited if and only if the corresponding fibration is surjective. *)
+Lemma iff_merely_issurjection {X : Type} (P : X -> Type)
+  : (forall x, merely (P x)) <-> IsSurjection (pr1 : {x : X & P x} -> X).
+Proof.
+  refine (iff_compose _ (iff_forall_inO_mapinO_pr1 (Conn _) P)).
+  apply iff_functor_forall; intro a.
+  symmetry; apply (iff_contr_hprop (Tr (-1) (P a))).
+Defined.
+
 Lemma equiv_merely_issurjection `{Funext} {X : Type} (P : X -> Type)
   : (forall x, merely (P x)) <~> IsSurjection (pr1 : {x : X & P x} -> X).
-Proof.
-  refine (equiv_forall_inO_mapinO_pr1 (Conn _) _ oE _).
-  apply equiv_functor_forall_id; intro x.
-  exact (equiv_contr_hprop _)^-1%equiv.
+Proof. (* Can also be proved from equiv_forall_inO_mapinO_pr1. *)
+  exact (equiv_iff_hprop_uncurried (iff_merely_issurjection P)).
 Defined.
 
 Definition isequiv_surj_emb {A B} (f : A -> B)
-- 
2.29.1


From 32005c28816d13f0d392b7cea38285e42eb9663a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jarl=20G=2E=20Taxer=C3=A5s=20Flaten?=
 <1269436+jarlg@users.noreply.github.com>
Date: Sat, 12 Sep 2020 17:59:05 -0400
Subject: [PATCH 68/76] Replace refine by exact in
 theories/Modalities/ReflectiveSubuniverse.v

Co-authored-by: Dan Christensen <jdc+github@uwo.ca>
---
 theories/Modalities/ReflectiveSubuniverse.v | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/theories/Modalities/ReflectiveSubuniverse.v b/theories/Modalities/ReflectiveSubuniverse.v
index 3edf64e6db..a555106423 100644
--- a/theories/Modalities/ReflectiveSubuniverse.v
+++ b/theories/Modalities/ReflectiveSubuniverse.v
@@ -94,7 +94,7 @@ Section Subuniverse.
   : MapIn O g.
   Proof.
     intros b.
-    refine (inO_equiv_inO (hfiber f b)
+    exact (inO_equiv_inO (hfiber f b)
                           (equiv_hfiber_homotopic f g p b)).
   Defined.
 
-- 
2.29.1


From ec537ba9cfde30ac2fba2a5baabca20964b06efd Mon Sep 17 00:00:00 2001
From: "Jarl G. Taxeraas Flaten" <jtaxers@uwo.ca>
Date: Sun, 13 Sep 2020 15:33:13 -0400
Subject: [PATCH 69/76] Rename Choice to IsProjective'

---
 contrib/HoTTBookExercises.v                 |  2 +-
 theories/Modalities/ReflectiveSubuniverse.v |  3 +--
 theories/Projective.v                       | 18 ++++++++----------
 3 files changed, 10 insertions(+), 13 deletions(-)

diff --git a/contrib/HoTTBookExercises.v b/contrib/HoTTBookExercises.v
index 3562ee1f9a..f42b9ede52 100644
--- a/contrib/HoTTBookExercises.v
+++ b/contrib/HoTTBookExercises.v
@@ -1621,7 +1621,7 @@ End Book_7_1.
 (** Exercise 7.9 *)
 
 (** Solution for the case (oo,-1). *)
-Definition Book_7_9_oo_neg1 `{Univalence} (AC_oo_neg1 : forall X : hSet, Choice X) (A : Type)
+Definition Book_7_9_oo_neg1 `{Univalence} (AC_oo_neg1 : forall X : hSet, IsProjective' X) (A : Type)
   : merely (exists X : hSet, exists p : X -> A, IsSurjection p)
   := @HoTT.Projective.projective_cover_AC AC_oo_neg1 _ A.
 
diff --git a/theories/Modalities/ReflectiveSubuniverse.v b/theories/Modalities/ReflectiveSubuniverse.v
index a555106423..71540d9791 100644
--- a/theories/Modalities/ReflectiveSubuniverse.v
+++ b/theories/Modalities/ReflectiveSubuniverse.v
@@ -121,8 +121,7 @@ Section Subuniverse.
   Lemma equiv_forall_inO_mapinO_pr1 `{Funext} {A : Type} (B : A -> Type)
     : (forall a, In O (B a)) <~> MapIn O (@pr1 A B).
   Proof.
-    apply equiv_iff_hprop_uncurried.
-    apply iff_forall_inO_mapinO_pr1.
+    exact (equiv_iff_hprop_uncurried (iff_forall_inO_mapinO_pr1 B)).
   Defined.
 
 End Subuniverse.
diff --git a/theories/Projective.v b/theories/Projective.v
index 6bb02a0b68..82faf673cd 100644
--- a/theories/Projective.v
+++ b/theories/Projective.v
@@ -40,13 +40,14 @@ Proof.
 Defined.
 
 
-(** ** Projectivity and choice *)
+(** ** Projectivity and the axiom of choice *)
 
-Definition Choice (X : Type) : Type := forall P : X -> Type,
+(** In topos theory, an object X is said to be projective if the axiom of choice holds when making choices indexed by X. *)
+Definition IsProjective' (X : Type) : Type := forall P : X -> Type,
     (forall x, merely (P x)) -> merely (forall x, P x).
 
 Proposition iff_isprojective_choice (X : Type)
-  : IsProjective X <-> Choice X.
+  : IsProjective X <-> IsProjective' X.
 Proof.
   refine (iff_compose (iff_isprojective_surjections_split X) _).
   split.
@@ -68,7 +69,7 @@ Proof.
 Defined.
 
 Proposition equiv_isprojective_choice `{Funext} (X : Type)
-  : IsProjective X <~> Choice X.
+  : IsProjective X <~> IsProjective' X.
 Proof.
   exact (equiv_iff_hprop_uncurried (iff_isprojective_choice X)).
 Defined.
@@ -87,7 +88,7 @@ Section AC_oo_neg1.
   (** ** Projectivity and AC_(oo,-1) (defined in HoTT book, Exercise 7.8) *)
   (* TODO: Generalize to n, m. *)
 
-  Context {AC : forall X : hSet, Choice X}.
+  Context {AC : forall X : hSet, IsProjective' X}.
 
   (** (Exercise 7.9) Assuming AC_(oo,-1) every type merely has a projective cover. *)
   Proposition projective_cover_AC `{Univalence} (A : Type)
@@ -98,11 +99,8 @@ Section AC_oo_neg1.
     pose proof (P A X idmap tr _) as F; clear P.
     strip_truncations.
     destruct F as [f p].
-    apply tr; refine (X; (f; _)).
-    unfold IsConnMap, IsConnected.
-    intro a.
-    rapply contr_inhabited_hprop.
-    unfold hfiber.
+    refine (tr (X; (f; BuildIsSurjection f _))).
+    intro a; unfold hfiber.
     apply equiv_O_sigma_O.
     refine (tr (tr a; _)).
     rapply (equiv_path_Tr _ _)^-1%equiv.  (* Uses Univalence. *)
-- 
2.29.1


From 8c2f0868fb47fd6c6780d2a805dc88c28a82d320 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Thu, 17 Sep 2020 21:30:47 +0200
Subject: [PATCH 70/76] Apply suggestions from code review

Co-authored-by: Mike Shulman <viritrilbia@gmail.com>
---
 theories/Algebra/Rings/CRing.v        | 14 +++-----------
 theories/Algebra/Rings/QuotientRing.v |  2 +-
 theories/Algebra/Rings/Z.v            |  2 +-
 theories/Spaces/Int/Spec.v            |  3 +--
 4 files changed, 6 insertions(+), 15 deletions(-)

diff --git a/theories/Algebra/Rings/CRing.v b/theories/Algebra/Rings/CRing.v
index 82e80a08b7..46b685dd4e 100644
--- a/theories/Algebra/Rings/CRing.v
+++ b/theories/Algebra/Rings/CRing.v
@@ -9,19 +9,12 @@ Require Export Classes.theory.rings.
 
 (** A commutative ring consists of the following data *)
 Record CRing := {
-  (** A type *)
   cring_type : Type;
-  (** A plus operation *)
   cring_plus : Plus cring_type;
-  (** A mult operation *)
   cring_mult : Mult cring_type;
-  (** A zero *)
   cring_zero : Zero cring_type;
-  (** A one *)
   cring_one  : One  cring_type;
-  (** A negation *)
   cring_negate : Negate cring_type;
-  (** Such that this data satisfies the axioms of a commmutative ring. *)
   cring_isring : IsRing cring_type;
 }.
 
@@ -51,9 +44,8 @@ Definition issig_CRingHomomorphism (A B : CRing)
   : _ <~> CRingHomomorphism A B
   := ltac:(issig).
 
-(** We coerce ring homomorphisms to their underlyig maps *)
+(** We coerce ring homomorphisms to their underlying maps *)
 Coercion rng_homo_map : CRingHomomorphism >-> Funclass.
-(** And we make rng_homo_ishomo a global instance. *)
 Global Existing Instance rng_homo_ishomo.
 
 Definition equiv_path_cringhomomorphism `{Funext} {A B : CRing}
@@ -80,7 +72,7 @@ Defined.
 
 Section RingLaws.
 
-  (** Many of these ring laws have already been prove. But we give them names here so that they are easy to find and use. *)
+  (** Many of these ring laws have already been proven. But we give them names here so that they are easy to find and use. *)
 
   Context {A B : CRing} (f : CRingHomomorphism A B) (x y z : A).
 
@@ -162,7 +154,7 @@ Definition grp_homo_rng_homo {R S : CRing}
 
 Coercion grp_homo_rng_homo : CRingHomomorphism >-> GroupHomomorphism.
 
-(** We can construct a ring homomorphism a group homomorphism that preserves multiplication *)
+(** We can construct a ring homomorphism from a group homomorphism that preserves multiplication *)
 Definition Build_CRingHomomorphism' (A B : CRing) (map : GroupHomomorphism A B)
   {H : IsMonoidPreserving (Aop:=cring_mult) (Bop:=cring_mult)
     (Aunit:=one) (Bunit:=one) map}
diff --git a/theories/Algebra/Rings/QuotientRing.v b/theories/Algebra/Rings/QuotientRing.v
index 9c4955c91e..ec0e4dc341 100644
--- a/theories/Algebra/Rings/QuotientRing.v
+++ b/theories/Algebra/Rings/QuotientRing.v
@@ -4,7 +4,7 @@ Require Import Algebra.AbGroups.
 Require Import Algebra.Rings.CRing.
 Require Import Algebra.Rings.Ideal.
 
-(** In this file we define the quotient of a commuative ring by an ideal *)
+(** In this file we define the quotient of a commutative ring by an ideal *)
 
 Section QuotientRing.
 
diff --git a/theories/Algebra/Rings/Z.v b/theories/Algebra/Rings/Z.v
index 15ef7561c4..e446e80a43 100644
--- a/theories/Algebra/Rings/Z.v
+++ b/theories/Algebra/Rings/Z.v
@@ -31,7 +31,7 @@ Defined.
 
 Local Open Scope mc_scope.
 
-(** Standard integer operations on commutative rings *)
+(** Multiplication of a ring element by an integer. *)
 Definition cring_int_mul (R : CRing) (z : cring_Z) : R
   := match z with
      | neg z => pos_peano_rec R (-1) (fun n nr => -1 + nr) z
diff --git a/theories/Spaces/Int/Spec.v b/theories/Spaces/Int/Spec.v
index b7e07f6237..c8f1c3e7b6 100644
--- a/theories/Spaces/Int/Spec.v
+++ b/theories/Spaces/Int/Spec.v
@@ -354,7 +354,7 @@ Global Instance isequiv_int_succ : IsEquiv int_succ | 0
 Definition equiv_int_succ : Int <~> Int
   := Build_Equiv _ _ _ isequiv_int_succ.
 
-(** ** Commutativity of multplication *)
+(** ** Commutativity of multiplication *)
 Lemma int_mul_comm n m : n * m = m * n.
 Proof.
   destruct n, m; cbn; try reflexivity;
@@ -434,4 +434,3 @@ Lemma int_mul_assoc n m p : n * (m * p) = n * m * p.
 Proof.
   destruct n, m, p; cbn; trivial; f_ap; apply pos_mul_assoc.
 Qed.
-
-- 
2.29.1


From d49abb4e291bf63ad84a614023c0a46fe1283136 Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Wed, 23 Sep 2020 15:03:30 +0200
Subject: [PATCH 71/76] renamed cring_int_mul to cring_catamorphism_fun

---
 theories/Algebra/Rings/Z.v | 61 +++++++++++++++++++-------------------
 1 file changed, 31 insertions(+), 30 deletions(-)

diff --git a/theories/Algebra/Rings/Z.v b/theories/Algebra/Rings/Z.v
index e446e80a43..bc08c8c6f3 100644
--- a/theories/Algebra/Rings/Z.v
+++ b/theories/Algebra/Rings/Z.v
@@ -32,7 +32,8 @@ Defined.
 Local Open Scope mc_scope.
 
 (** Multiplication of a ring element by an integer. *)
-Definition cring_int_mul (R : CRing) (z : cring_Z) : R
+(** We call this a "catamorphism" which is the name of the map from an initial object. It seems to be a more common terminology in computer science. *)
+Definition cring_catamorphism_fun (R : CRing) (z : cring_Z) : R
   := match z with
      | neg z => pos_peano_rec R (-1) (fun n nr => -1 + nr) z
      | 0%int => 0
@@ -40,9 +41,9 @@ Definition cring_int_mul (R : CRing) (z : cring_Z) : R
      end.
 
 (** Preservation of + *)
-Global Instance issemigrouppreserving_cring_int_mul_plus (R : CRing)
+Global Instance issemigrouppreserving_cring_catamorphism_fun_plus (R : CRing)
   : IsSemiGroupPreserving (Aop:=cring_plus) (Bop:=cring_plus)
-      (cring_int_mul R : cring_Z -> R).
+      (cring_catamorphism_fun R : cring_Z -> R).
 Proof.
   (** Unfortunately, due to how we have defined things we need to seperate this out into 9 cases. *)
   hnf. intros [x| |x] [y| |y].
@@ -51,8 +52,8 @@ Proof.
   3,4: symmetry; apply left_identity.
   (** This leaves us with four cases to consider *)
   (** x < 0 , y < 0 *)
-  { change (cring_int_mul R ((neg x) + (neg y))%int
-      = (cring_int_mul R (neg x)) + (cring_int_mul R (neg y))).
+  { change (cring_catamorphism_fun R ((neg x) + (neg y))%int
+      = (cring_catamorphism_fun R (neg x)) + (cring_catamorphism_fun R (neg y))).
     induction y as [|y IHy] using pos_peano_ind.
     { simpl.
       rewrite pos_add_1_r.
@@ -135,8 +136,8 @@ Proof.
     reflexivity.
 Qed.
 
-Lemma cring_int_mul_negate {R} x
-  : cring_int_mul R (- x) = - cring_int_mul R x.
+Lemma cring_catamorphism_fun_negate {R} x
+  : cring_catamorphism_fun R (- x) = - cring_catamorphism_fun R x.
 Proof.
   snrapply (groups.preserves_negate _).
   1-6: exact _.
@@ -145,21 +146,21 @@ Proof.
   split.
 Defined.
 
-Lemma cring_int_mul_pos_mult {R} x y
-  : cring_int_mul R (pos x * pos y)%int
-    = cring_int_mul R (pos x) * cring_int_mul R (pos y).
+Lemma cring_catamorphism_fun_pos_mult {R} x y
+  : cring_catamorphism_fun R (pos x * pos y)%int
+    = cring_catamorphism_fun R (pos x) * cring_catamorphism_fun R (pos y).
 Proof.
   revert y.
   induction x as [|x IHx] using pos_peano_ind; intro y.
   { symmetry.
     apply left_identity. }
-  change (cring_int_mul R (pos (pos_succ x * y)%pos)
-    = cring_int_mul R (pos (pos_succ x)) * cring_int_mul R (pos y)).
+  change (cring_catamorphism_fun R (pos (pos_succ x * y)%pos)
+    = cring_catamorphism_fun R (pos (pos_succ x)) * cring_catamorphism_fun R (pos y)).
   rewrite pos_mul_succ_l.
-  refine (issemigrouppreserving_cring_int_mul_plus
+  refine (issemigrouppreserving_cring_catamorphism_fun_plus
     R (pos (x * y)%pos) (pos y) @ _).
   rewrite IHx.
-  transitivity ((1 + cring_int_mul R (pos x)) * cring_int_mul R (pos y)).
+  transitivity ((1 + cring_catamorphism_fun R (pos x)) * cring_catamorphism_fun R (pos y)).
   2: simpl; by rewrite pos_peano_rec_beta_pos_succ.
   rewrite rng_dist_r.
   rewrite rng_mult_one_l.
@@ -167,34 +168,34 @@ Proof.
 Qed.
 
 (** Preservation of * (multiplication) *)
-Global Instance issemigrouppreserving_cring_int_mul_mult (R : CRing)
+Global Instance issemigrouppreserving_cring_catamorphism_fun_mult (R : CRing)
   : IsSemiGroupPreserving (Aop:=cring_mult) (Bop:=cring_mult)
-      (cring_int_mul R : cring_Z -> R).
+      (cring_catamorphism_fun R : cring_Z -> R).
 Proof.
   hnf. intros [x| |x] [y| |y].
   2,5,8: symmetry; apply rng_mult_zero_r.
   3,4: cbn; symmetry; rewrite (commutativity 0); apply rng_mult_zero_r.
-  { change (cring_int_mul R (pos (x * y)%pos)
-      = cring_int_mul R (- (pos x : cring_Z))
-        * cring_int_mul R (- (pos y : cring_Z))).
-    by rewrite 2 cring_int_mul_negate, cring_int_mul_pos_mult,
+  { change (cring_catamorphism_fun R (pos (x * y)%pos)
+      = cring_catamorphism_fun R (- (pos x : cring_Z))
+        * cring_catamorphism_fun R (- (pos y : cring_Z))).
+    by rewrite 2 cring_catamorphism_fun_negate, cring_catamorphism_fun_pos_mult,
       rng_mult_negate_negate. }
-  { change (cring_int_mul R (- (pos (x * y)%pos : cring_Z))
-      = cring_int_mul R (- (pos x : cring_Z))
-        * cring_int_mul R (pos y)).
-    by rewrite 2 cring_int_mul_negate, cring_int_mul_pos_mult, rng_mult_negate_l. }
-  { change (cring_int_mul R (- (pos (x * y)%pos : cring_Z))
-      = cring_int_mul R (pos x)
-        * cring_int_mul R (- (pos y : cring_Z))).
-    by rewrite 2 cring_int_mul_negate, cring_int_mul_pos_mult, rng_mult_negate_r. }
-  apply cring_int_mul_pos_mult.
+  { change (cring_catamorphism_fun R (- (pos (x * y)%pos : cring_Z))
+      = cring_catamorphism_fun R (- (pos x : cring_Z))
+        * cring_catamorphism_fun R (pos y)).
+    by rewrite 2 cring_catamorphism_fun_negate, cring_catamorphism_fun_pos_mult, rng_mult_negate_l. }
+  { change (cring_catamorphism_fun R (- (pos (x * y)%pos : cring_Z))
+      = cring_catamorphism_fun R (pos x)
+        * cring_catamorphism_fun R (- (pos y : cring_Z))).
+    by rewrite 2 cring_catamorphism_fun_negate, cring_catamorphism_fun_pos_mult, rng_mult_negate_r. }
+  apply cring_catamorphism_fun_pos_mult.
 Qed.
 
 (** This is a ring homomorphism *)
 Definition rng_homo_int (R : CRing) : cring_Z $-> R.
 Proof.
   snrapply Build_CRingHomomorphism.
-  1: exact (cring_int_mul R).
+  1: exact (cring_catamorphism_fun R).
   repeat split; exact _.
 Defined.
 
-- 
2.29.1


From d54d3465732734ba8fdfbb4af92cc80af3a81b1b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ga=C3=ABtan=20Gilbert?= <gaetan.gilbert@skyskimmer.net>
Date: Thu, 15 Oct 2020 14:17:04 +0200
Subject: [PATCH 72/76] Adapt to coq/coq#13188 (Default disable automatic
 generalization of Instance type)

---
 theories/Categories/Category/Morphisms.v           | 2 +-
 theories/Categories/InitialTerminalCategory/Core.v | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/theories/Categories/Category/Morphisms.v b/theories/Categories/Category/Morphisms.v
index 1f502a8dd1..783c042feb 100644
--- a/theories/Categories/Category/Morphisms.v
+++ b/theories/Categories/Category/Morphisms.v
@@ -148,7 +148,7 @@ Section iso_contr.
   Qed.
 
   (** *** Equality between isomorphisms is equivalent to by equality between their forward components *)
-  Global Instance isequiv_path_isomorphic
+  Global Instance isequiv_path_isomorphic {i j}
   : IsEquiv (path_isomorphic i j).
   Proof.
     intros.
diff --git a/theories/Categories/InitialTerminalCategory/Core.v b/theories/Categories/InitialTerminalCategory/Core.v
index 165d9bb5fc..168e8fc740 100644
--- a/theories/Categories/InitialTerminalCategory/Core.v
+++ b/theories/Categories/InitialTerminalCategory/Core.v
@@ -34,7 +34,7 @@ Global Instance trunc_initial_category_mor `{IsInitialCategory C} x y
 Global Instance is_initial_category_0 : IsInitialCategory 0 := (fun T => @Empty_ind (fun _ => T)).
 Global Instance: IsTerminalCategory 1 | 0 := {}.
 Global Instance: Contr (object 1) | 0 := _.
-Global Instance: Contr (morphism 1 x y) | 0 := fun x y => _.
+Global Instance : `{Contr (morphism 1 x y)} | 0 := fun x y => _.
 Global Instance default_terminal C {H H1} : @IsTerminalCategory C H H1 | 10 := {}.
 
 Arguments initial_category_ind / .
-- 
2.29.1


From 6e23636a347db8c911840c3a9a88852376cde036 Mon Sep 17 00:00:00 2001
From: Pierre Roux <pierre@roux01.fr>
Date: Thu, 5 Nov 2020 17:33:52 +0100
Subject: [PATCH 73/76] Adapt to coq/coq#12218

---
 coq-HoTT                    | 2 +-
 coq/theories/Init/Numeral.v | 1 +
 coq/theories/Init/Prelude.v | 3 ++-
 3 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/coq-HoTT b/coq-HoTT
index c97b82cda0..afc828b3e2 160000
--- a/coq-HoTT
+++ b/coq-HoTT
@@ -1 +1 @@
-Subproject commit c97b82cda0ba4c0b9ad8199658c3a09461f3a8d7
+Subproject commit afc828b3e207dd39c59d1501d570a88b2012fd2c
diff --git a/coq/theories/Init/Numeral.v b/coq/theories/Init/Numeral.v
index c636a0d3e9..228a769e01 100644
--- a/coq/theories/Init/Numeral.v
+++ b/coq/theories/Init/Numeral.v
@@ -21,6 +21,7 @@ Variant numeral := Dec (d:Decimal.decimal) | Hex (h:Hexadecimal.hexadecimal).
 Register uint as num.num_uint.type.
 Register int as num.num_int.type.
 Register numeral as num.numeral.type.
+Register numeral as num.number.type.
 
 (** Pseudo-conversion functions used when declaring
     Numeral Notations on [uint] and [int]. *)
diff --git a/coq/theories/Init/Prelude.v b/coq/theories/Init/Prelude.v
index b84a19fde9..da4b9abf23 100644
--- a/coq/theories/Init/Prelude.v
+++ b/coq/theories/Init/Prelude.v
@@ -11,9 +11,10 @@ Require Coq.Init.Hexadecimal.
 Require Coq.Init.Numeral.
 Require Coq.Init.Nat.
 
-Declare ML Module "numeral_notation_plugin".
+Declare ML Module "number_string_notation_plugin".
 
 Set Warnings "-decimal-numeral-notation".
+Set Warnings "-numeral-notation".
 
 (* Parsing / printing of decimal numbers *)
 Arguments Nat.of_uint d%dec_uint_scope.
-- 
2.29.1


From 25ab93fe795673e8cea88b1665114e68247a3e7c Mon Sep 17 00:00:00 2001
From: Ali Caglayan <alizter@gmail.com>
Date: Mon, 9 Nov 2020 14:46:02 +0100
Subject: [PATCH 74/76] bump coq-dpdgraph

---
 etc/coq-dpdgraph | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/etc/coq-dpdgraph b/etc/coq-dpdgraph
index 42636fc7fd..f12bf89256 160000
--- a/etc/coq-dpdgraph
+++ b/etc/coq-dpdgraph
@@ -1 +1 @@
-Subproject commit 42636fc7fdd0cc918254308d428db594c9d7d81c
+Subproject commit f12bf892561ccffe5382d97ae2684a7dae326e64
-- 
2.29.1


From 573ea11ebe5cf7420e900a98bef8e9ef62a5b948 Mon Sep 17 00:00:00 2001
From: Lasse Blaauwbroek <lasse@blaauwbroek.eu>
Date: Sun, 15 Nov 2020 23:52:30 +0100
Subject: [PATCH 75/76] Patch for Tactician support

---
 coq/theories/Init/Notations.v | 1 -
 hoqc                          | 3 ++-
 hoqchk                        | 3 ++-
 hoqdep                        | 3 ++-
 hoqide                        | 3 ++-
 hoqidetop                     | 3 ++-
 hoqtop                        | 3 ++-
 hoqtop.byte                   | 3 ++-
 8 files changed, 14 insertions(+), 8 deletions(-)

diff --git a/coq/theories/Init/Notations.v b/coq/theories/Init/Notations.v
index f5254bbb24..0b90e1e683 100644
--- a/coq/theories/Init/Notations.v
+++ b/coq/theories/Init/Notations.v
@@ -95,5 +95,4 @@ Open Scope type_scope.
 
 Declare ML Module "ltac_plugin".
 
-Global Set Default Proof Mode "Classic".
 
diff --git a/hoqc b/hoqc
index f65c2c5143..da7b9849b4 100755
--- a/hoqc
+++ b/hoqc
@@ -46,4 +46,5 @@ fi
 # or using more evil (but portable) 'eval', do
 # $ eval 'exec "$COQC" '"$COQ_ARGS"' "$@"'
 # Instead, we duplicate code, because it's simpler.
-exec "$COQC" -coqlib "$COQLIB" -R "$HOTTLIB" HoTT -Q "$HOTTCONTRIB" "" -indices-matter "$@"
+TACTICIANDIR=$(opam var coq:lib)/user-contrib/Tactician
+exec "$COQC" -I $TACTICIANDIR -R $TACTICIANDIR Tactician -coqlib "$COQLIB" -R "$HOTTLIB" HoTT -Q "$HOTTCONTRIB" "" -indices-matter "$@"
diff --git a/hoqchk b/hoqchk
index 6cafffdd01..8893a881f8 100755
--- a/hoqchk
+++ b/hoqchk
@@ -46,4 +46,5 @@ fi
 # or using more evil (but portable) 'eval', do
 # $ eval 'exec "$COQC" '"$COQ_ARGS"' "$@"'
 # Instead, we duplicate code, because it's simpler.
-exec "$COQCHK" -coqlib "$COQLIB" -R "$HOTTLIB" HoTT -R "$HOTTCONTRIB" "" "$@"
+TACTICIANDIR=$(opam var coq:lib)/user-contrib/Tactician
+exec "$COQCHK" -R $TACTICIANDIR Tactician -coqlib "$COQLIB" -R "$HOTTLIB" HoTT -R "$HOTTCONTRIB" "" "$@"
diff --git a/hoqdep b/hoqdep
index 277dcc10f6..aef0b1f28b 100755
--- a/hoqdep
+++ b/hoqdep
@@ -46,4 +46,5 @@ fi
 # or using more evil (but portable) 'eval', do
 # $ eval 'exec "$COQDEP" '"$COQ_ARGS"' "$@"'
 # Instead, we duplicate code, because it's simpler.
-exec "$COQDEP" -coqlib "$COQLIB" -R "$HOTTLIB" HoTT -Q "$HOTTCONTRIB" "" -indices-matter "$@"
+TACTICIANDIR=$(opam var coq:lib)/user-contrib/Tactician
+exec "$COQDEP" -I $TACTICIANDIR -R $TACTICIANDIR Tactician -coqlib "$COQLIB" -R "$HOTTLIB" HoTT -Q "$HOTTCONTRIB" "" -indices-matter "$@"
diff --git a/hoqide b/hoqide
index 48395740ee..b2c8a1a19d 100755
--- a/hoqide
+++ b/hoqide
@@ -46,4 +46,5 @@ fi
 # or using more evil (but portable) 'eval', do
 # $ eval 'exec "$COQIDE" '"$COQ_ARGS"' "$@"'
 # Instead, we duplicate code, because it's simpler.
-exec "$COQIDE" -coqlib "$COQLIB" -R "$HOTTLIB" HoTT -Q "$HOTTCONTRIB" "" -indices-matter "$@"
+TACTICIANDIR=$(opam var coq:lib)/user-contrib/Tactician
+exec "$COQIDE" -I $TACTICIANDIR -R $TACTICIANDIR Tactician -coqlib "$COQLIB" -R "$HOTTLIB" HoTT -Q "$HOTTCONTRIB" "" -indices-matter "$@"
diff --git a/hoqidetop b/hoqidetop
index 19c961bfc5..488bd3e2ab 100755
--- a/hoqidetop
+++ b/hoqidetop
@@ -46,4 +46,5 @@ fi
 # or using more evil (but portable) 'eval', do
 # $ eval 'exec "$COQIDETOP" '"$COQ_ARGS"' "$@"'
 # Instead, we duplicate code, because it's simpler.
-exec "$COQIDETOP" -coqlib "$COQLIB" -R "$HOTTLIB" HoTT -Q "$HOTTCONTRIB" "" -indices-matter "$@"
+TACTICIANDIR=$(opam var coq:lib)/user-contrib/Tactician
+exec "$COQIDETOP" -I $TACTICIANDIR -R $TACTICIANDIR Tactician -coqlib "$COQLIB" -R "$HOTTLIB" HoTT -Q "$HOTTCONTRIB" "" -indices-matter "$@"
diff --git a/hoqtop b/hoqtop
index 332398a5fb..101281df58 100755
--- a/hoqtop
+++ b/hoqtop
@@ -46,4 +46,5 @@ fi
 # or using more evil (but portable) 'eval', do
 # $ eval 'exec "$COQTOP" '"$COQ_ARGS"' "$@"'
 # Instead, we duplicate code, because it's simpler.
-exec "$COQTOP" -coqlib "$COQLIB" -R "$HOTTLIB" HoTT -Q "$HOTTCONTRIB" "" -indices-matter "$@"
+TACTICIANDIR=$(opam var coq:lib)/user-contrib/Tactician
+exec "$COQTOP" -I $TACTICIANDIR -R $TACTICIANDIR Tactician -coqlib "$COQLIB" -R "$HOTTLIB" HoTT -Q "$HOTTCONTRIB" "" -indices-matter "$@"
diff --git a/hoqtop.byte b/hoqtop.byte
index 8f81e63fac..9bd2d2efe7 100755
--- a/hoqtop.byte
+++ b/hoqtop.byte
@@ -46,4 +46,5 @@ fi
 # or using more evil (but portable) 'eval', do
 # $ eval 'exec "$COQTOP.byte" '"$COQ_ARGS"' "$@"'
 # Instead, we duplicate code, because it's simpler.
-exec "$COQTOP.byte" -coqlib "$COQLIB" -R "$HOTTLIB" HoTT -Q "$HOTTCONTRIB" "" -indices-matter "$@"
+TACTICIANDIR=$(opam var coq:lib)/user-contrib/Tactician
+exec "$COQTOP.byte" -I $TACTICIANDIR -R $TACTICIANDIR Tactician -coqlib "$COQLIB" -R "$HOTTLIB" HoTT -Q "$HOTTCONTRIB" "" -indices-matter "$@"
-- 
2.29.1


From 9924b029fb5a390386f78581098abef0518590f8 Mon Sep 17 00:00:00 2001
From: Lasse Blaauwbroek <lasse@blaauwbroek.eu>
Date: Mon, 16 Nov 2020 06:22:57 +0100
Subject: [PATCH 76/76] Inject Tactician in a way that does not force the proof
 mode on subsequent files.

---
 coq/theories/Init/Logic.v     | 1 +
 coq/theories/Init/Notations.v | 1 +
 coq/theories/Init/Peano.v     | 1 +
 coq/theories/Init/Specif.v    | 1 +
 4 files changed, 4 insertions(+)

diff --git a/coq/theories/Init/Logic.v b/coq/theories/Init/Logic.v
index 9b51ccb280..249901323c 100644
--- a/coq/theories/Init/Logic.v
+++ b/coq/theories/Init/Logic.v
@@ -13,6 +13,7 @@
 Set Implicit Arguments.
 
 Require Export Notations.
+From Tactician Require Import Ltac1.Record.
 
 Global Set Universe Polymorphism.
 Global Set Asymmetric Patterns.
diff --git a/coq/theories/Init/Notations.v b/coq/theories/Init/Notations.v
index 0b90e1e683..f5254bbb24 100644
--- a/coq/theories/Init/Notations.v
+++ b/coq/theories/Init/Notations.v
@@ -95,4 +95,5 @@ Open Scope type_scope.
 
 Declare ML Module "ltac_plugin".
 
+Global Set Default Proof Mode "Classic".
 
diff --git a/coq/theories/Init/Peano.v b/coq/theories/Init/Peano.v
index df0ceb0fde..dfe782dca2 100644
--- a/coq/theories/Init/Peano.v
+++ b/coq/theories/Init/Peano.v
@@ -28,6 +28,7 @@ Require Import Datatypes.
 Local Open Scope identity_scope.
 Require Import Logic_Type.
 Require Coq.Init.Nat.
+From Tactician Require Import Ltac1.Record.
 
 Open Scope nat_scope.
 Local Notation "0" := O.
diff --git a/coq/theories/Init/Specif.v b/coq/theories/Init/Specif.v
index 1a03e6a07b..e15d9874a1 100644
--- a/coq/theories/Init/Specif.v
+++ b/coq/theories/Init/Specif.v
@@ -19,6 +19,7 @@ Require Import Datatypes.
 Local Open Scope identity_scope.
 Require Import Logic.
 Local Unset Elimination Schemes.
+From Tactician Require Import Ltac1.Record.
 
 (** [(sig A P)], or more suggestively [{x:A & (P x)}] is a Sigma-type.
     Similarly for [(sig2 A P Q)], also written [{x:A & (P x) & (Q x)}]. *)
-- 
2.29.1

